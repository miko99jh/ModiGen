{
    "model": [
        {
            "id": 1,
            "instruction": "Generate a Modelica function named `moh` to calculate the minute of an hour given a specific time. The function should correctly handle the conversion from a continuous time input to discrete minute output, factoring in the starting hour, minute, and second. The input parameters 't', 'hour_start', 'min_start', and 'sec_start' represent the current time in seconds and the initial hour, minute, and second respectively. The output 'y' should represent the minute of the current hour, ranging from 0 to 59.   Use `AES.Functions.sod` and `AES.Functions.hod` to calculate seconds of the day and hour of the day as intermediate steps(represented by two protection variables s and h), ensuring accurate minute calculation within an hour frame.\n\n//modelica\n```function moh",
            "input": "Modelica version: 4.0.0\nSource: AES.Functions.moh",
            "output": "within AES.Functions;\nfunction moh \"minute of hour (0-59)\"\n  extends Modelica.Icons.Function;\n  input Real t;\n  input Real hour_start=0;\n  input Real min_start=0;\n  input Real sec_start=0;\n  output Real y;\nprotected\n  Real s,h;\nalgorithm\n  s := Functions.sod(t,hour_start,min_start,sec_start);\n  h := Functions.hod(t,hour_start,min_start,sec_start);\n  y := 1.0*(floor((s-3600*h)/60));\nend moh;",
            "type": "function",
            "feature": "instantiation"
        },
        {
            "id": 2,
            "instruction": "Generate a Modelica function model that calculates the distances between the centers of faces in a layered structure. The model should be named `layer_fcf_distances`. The function takes an input array `s` of type `Real`, representing the thicknesses of the layers, and outputs an array `d` of type `Real` representing the distances between face centers, with `size(s, 1) + 1` elements. The function also has a protected variable n, it is an integer `n` that stores the size of the input array `s`. The function should first assign the first and last elements of `d` as half of the first and last elements of `s`, respectively. Then, for each subsequent element, calculate the average of the current and previous layer thicknesses. The model does not inherit from any other models.\n\n//modelica\n```function layer_fcf_distances",
            "input": "Modelica version: 4.0.0\nSource: AES.Functions.layer_fcf_distances",
            "output": "within AES.Functions;\nfunction layer_fcf_distances \"face-centres-face\" \n  extends Modelica.Icons.Function;\n  input Real s[:] \"layer thicknesses\";\n  output Real d[size(s,1) + 1];\nprotected\n  Integer n;\nalgorithm\n  n := size(s,1);\n  d[1] := s[1] / 2;\n  d[n + 1] := s[n] / 2;\n  for i in 2:n loop\n d[i] := s[i - 1] / 2 + s[i] / 2;\n  end for\n\n  ;\nend layer_fcf_distances;",
            "type": "function",
            "feature": ""
        },
        {
            "id": 3,
            "instruction": "Generate a Modelica block named `SignalRanker` that ranks output signals such that the output signals are ordered in descending order (y[i] >= y[i+1]). The block should extend the `Modelica.Blocks.Interfaces.MIMO` interface, ensuring that the number of outputs (nout) matches the number of inputs (nin). Use the `Modelica.Math.Vectors.sort` function to sort the input vector (u) in descending order with the 'ascending' parameter set to false.\n\n//modelica\n```block SignalRanker",
            "input": "Modelica version: 4.0.0\nSource: IDEAS.Controls.Continuous.SignalRanker",
            "output": "within IDEAS.Controls.Continuous;\nblock SignalRanker \"Ranks output signals such that y[i] >= y[i+1]\"\n   extends Modelica.Blocks.Interfaces.MIMO(final nout=nin);\nequation\n  y = Modelica.Math.Vectors.sort(u, ascending=false)\n  ;\nend SignalRanker;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 4,
            "instruction": "Generate a Modelica model named `Ctrl_Heating_TES` for a heating curve control system that manages heating based on a water storage tank. The model should extends `IDEAS.Controls.ControlHeating.Interfaces.Partial_Ctrl_Heating_TES`. The model's functionality revolves around setting temperature thresholds for both the top (`TTopSet`) and bottom (`TBotSet`) of the tank, as well as determining the heat pump setpoint (`THPSet`).\n\nKey Parameters:\n- `TTopSet`: Calculated as the maximum of `TDHWSet` (the domestic hot water setpoint) and `heatingCurve.TSup` (the supply temperature from the heating curve), plus a safety margin (`dTSafetyTop`).\n- `TBotSet`: Calculated as the maximum of `TDHWSet` (the domestic hot water setpoint) and `heatingCurve.TSup` (the supply temperature from the heating curve), plus a bottom tank safety margin (`dTSafetyBot`).\n- `THPSet`: The heat pump setpoint is derived from `TTopSet` with an additional margin (`dTHPTankSet`).\n\nControl Logic:\n- The `onOff` signal determines whether the heating system is activated (`onOff = 1`) or deactivated (`onOff = 0`).\n- The system activates (`onOff = 1`) if the top of the tank (`TTankTop`) is below `TTopSet` and the bottom (`TTankBot`) is below `TBotSet - dTSafetyBot`, ensuring that the system operates unless there is a temperature inversion (i.e., the bottom is still very hot).\n- If the heat pump is running and the top of the tank is sufficiently heated(onOff > 0.5) but the bottom is still below `TBotSet`, the system continues to run (`onOff = 1`).\n- In all other scenarios, the system is shut down (`onOff = 0`).\nThe if statement uses the `if noEvent(...` to implement.\nEnsure that the model accurately implements these temperature calculations and control logic, representing the conditions and safety margins effectively.\n\n//modelica\n```model Ctrl_Heating_TES",
            "input": "Modelica version: 4.0.0\nSource: IDEAS.Controls.ControlHeating.Ctrl_Heating_TES",
            "output": "within IDEAS.Controls.ControlHeating;\nmodel Ctrl_Heating_TES\n  \"Heating curve control for heating based on a water storage tank\"\n  extends Interfaces.Partial_Ctrl_Heating_TES;\n\nequation\n  TTopSet = max(TDHWSet, heatingCurve.TSup) + dTSafetyTop;\n  TBotSet = max(TDHWSet, heatingCurve.TSup) + dTSafetyBot;\n  THPSet = TTopSet + dTHPTankSet;\n\n  if noEvent(TTankTop < TTopSet and TTankBot < (TBotSet - dTSafetyBot)) then\n // top too cold, system MUST be on except if bottom is still very hot (temp inversion?)\n onOff = 1;\n  elseif noEvent(TTankBot < TBotSet and onOff > 0.5) then\n // HP running, top is fine, bottom too cold: keep running\n onOff = 1;\n  else\n // all other cases: shut down\n onOff = 0;\n  end if\n\n  ;\nend Ctrl_Heating_TES;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Ctrl_Heating_TES completed successfully.\nClass Ctrl_Heating_TES has 795 equation(s) and 794 variable(s).\n550 of these are trivial equation(s)."
        },
        {
            "id": 5,
            "instruction": "Create a Modelica model named `I` for an integrator with tracking mode and limiter functionality. The model extends `IndustrialControlSystems.Controllers.Interfaces.Block` and extend its features. Include the following parameters: `Real T = 1` (Integral time), `Real y_start = 0` (State initial value). The model should handle anti-windup by checking the `AntiWindup` flag. If `AntiWindup` is true and the tracking signal (`ts`) is not active, the derivative of `Y` should be computed as `der(Y) = 1/T*u + 1/eps*(y - Y)`, and the output `y` should be `max(Ymin,min(Ymax,tr))`. If `AntiWindup` is true and the tracking signal (`ts`) is active, compute `der(Y)` as `1/eps*(y - Y)` and limit the output `y` is `max(Ymin,min(Ymax,tr))`. If `AntiWindup` is false, set `Y` to 0, calculate `T*der(y) = u for inactive `ts`, and compute `eps*der(y) = (-y + tr)` for active `ts`. Also, include an initial equation setting 'y = y_start' and a Real type protected parameter Y.\n\n//modelica\n```model I",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Controllers.Blocks.I",
            "output": "within IndustrialControlSystems.Controllers.Blocks;\nmodel I \"Integrator with tracking mode (and limiter)\"\n  extends IndustrialControlSystems.Controllers.Interfaces.Block;\n  parameter Real T = 1 \"Integral time\" ;\n  parameter Real y_start = 0 \"State initial value\" ;\nprotected\n  Real Y;\ninitial equation\n  y = y_start;\nequation\n  if AntiWindup then\n if not ts then\n der(Y) = 1/T*u + 1/eps*(y - Y);\n y = max(Ymin,min(Ymax,Y));\n else\n der(Y) = 1/eps*(y - Y);\n y = max(Ymin,min(Ymax,tr));\n end if;\n\n  else\n Y = 0;\n if not ts then\n T*der(y) = u;\n else\n eps*der(y) = (-y + tr);\n end if;\n  end if\n  ;\nend I;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 6,
            "instruction": "Generate a detailed Modelica model named `TestTrackingFO` for a test mode tracking system for a Fractional Order (FO) controller block. The model is intended to simulate scenarios within industrial control systems. It should include the following components: \n\n1. **FOtr**: An instance of `IndustrialControlSystems.Controllers.Blocks.FO` with parameters `useTS=true` and `T=0.4`.\n\n2. **FOaw**: Another instance of `IndustrialControlSystems.Controllers.Blocks.FO` with parameters `mu=1`, `AntiWindup=true`, `T=0.4`, `useTS=true`, `Ymin=0`, and `Ymax=2`.\n\n3. **Signal**: A `Modelica.Blocks.Sources.Step` source with parameters `startTime=2` and `height=2`.\n\n4. **TSsignal**: A `Modelica.Blocks.Sources.BooleanPulse` source with parameters `startTime=4`, `width=10`, and `period=40`.\n\n5. **TrackRef**: A `Modelica.Blocks.Sources.Trapezoid` source with parameters `amplitude=5`, `rising=1`, `width=2`, `falling=1`, `period=8`, `nperiod=1`, and `startTime=4`.\n\n6. **FO**: A third instance of `IndustrialControlSystems.Controllers.Blocks.FO` with parameters `mu=1` and `T=0.4`.\n\nEnsure that the following connections are made in the model's equation section:\n\n- Connect `signal.y` to `FO.u`.\n- Connect `TSsignal.y` to `FOtr.TS`.\n- Connect `TrackRef.y` to `FOtr.TR`.\n- Connect `signal.y` to `FOtr.u`.\n- Connect `signal.y` to `FOaw.u`.\n- Connect `TSsignal.y` to `FOaw.TS`.\n- Connect `TrackRef.y` to `FOaw.TR`.\n\n//modelica\n```model TestTrackingFO",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Controllers.Blocks.Examples.TestTrackingFO",
            "output": "within IndustrialControlSystems.Controllers.Blocks.Examples;\nmodel TestTrackingFO \"Tracking test mode for FO block\"\n  extends Modelica.Icons.Example;\n\n  IndustrialControlSystems.Controllers.Blocks.FO FOtr(useTS=true, T=0.4)\n ;\n  IndustrialControlSystems.Controllers.Blocks.FO FOaw(\n mu=1,\n AntiWindup=true,\n T=0.4,\n useTS=true,\n Ymin=0,\n Ymax=2) ;\n  Modelica.Blocks.Sources.Step signal(startTime=2, height=2)\n ;\n  Modelica.Blocks.Sources.BooleanPulse TSsignal(\n startTime=4,\n width=10,\n period=40) ;\n  Modelica.Blocks.Sources.Trapezoid TrackRef(\n amplitude=5,\n rising=1,\n width=2,\n falling=1,\n period=8,\n nperiod=1,\n startTime=4) ;\n  IndustrialControlSystems.Controllers.Blocks.FO FO(mu=1, T=0.4)\n ;\nequation\n  connect(signal.y, FO.u) ;\n  connect(TSsignal.y, FOtr.TS) ;\n  connect(TrackRef.y, FOtr.TR) ;\n  connect(signal.y, FOtr.u) ;\n  connect(signal.y, FOaw.u) ;\n  connect(TSsignal.y, FOaw.TS) ;\n  connect(TrackRef.y, FOaw.TR) \n  ;\nend TestTrackingFO;\n",
            "type": "model",
            "feature": "connect, instance"
        },
        {
            "id": 7,
            "instruction": "Generate a Modelica model for a relay with hysteresis functionality. The model should be named `RelayHysteresis`. It should extend the `IndustrialControlSystems.Controllers.Interfaces.BaseBlock` model. The model parameters include:\n- `Ymax`: Real, the maximum output value, with a default of 1.\n- `Ymin`: Real, the minimum output value, with a default of 0.\n- `ThL`: Real, the low input threshold value, with a default of 0.\n- `ThH`: Real, the high input threshold value, with a default of 0.\n- `initState`: Boolean, the initial state of the relay, with a default of `false`.\n\nThe model should use a discrete Boolean variable `state` (initialized to `initState`) to track the relay's state, and the `state` is a protected parameter. The model should include an initial equation to set the pre-state `pre(state)` to the initial state `initState`. The model equations should support both discrete-time and continuous-time relay operations based on the sampling time `Ts`. In the discrete-time mode, when Ts is greater than zero, the relay's state is evaluated at each sampling instance. The state toggles based on the input u in relation to its thresholds: it switches on if u exceeds the high threshold ThH while the relay was previously off, or switches off if u falls below the low threshold ThL while the relay was previously on. If neither condition is met, the state remains unchanged. The output y then reflects this state, being set to Ymax when the state is true and Ymin when false. This switching is triggered by the sample(0, Ts) event. In continuous-time mode, applicable when Ts equals zero, the relay's output y directly follows its state without the need for sampling. The state toggles under similar conditions as in discrete-time: turning on when u surpasses ThH if previously off, and turning off when u drops below ThL if previously on.\n\n//modelica\n```model RelayHysteresis",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Controllers.Logic.RelayHysteresis",
            "output": "within IndustrialControlSystems.Controllers.Logic;\nmodel RelayHysteresis \"Relay with hysteresis\"\n  extends IndustrialControlSystems.Controllers.Interfaces.BaseBlock;\n  parameter Real Ymax = 1 \"maximum output value\" ;\n  parameter Real Ymin = 0 \"minimum output value\" ;\n  parameter Real ThL = 0 \"input treshold (low) value\" ;\n  parameter Real ThH = 0 \"input treshold (high) value\" ;\n  parameter Boolean initState = false \"initial state\" ;\nprotected\n  discrete Boolean state( start = initState);\ninitial equation\n  pre(state) = initState;\nequation\n  if Ts > 0 then\n // Discrete time relay\n when sample(0,Ts) then\n\n if (u >= ThH and not pre(state)) or (u <= ThL and pre(state)) then\n state = not pre(state);\n else\n state = pre(state);\n end if;\n\n if state then\n y = Ymax;\n else\n y = Ymin;\n end if;\n\n end when;\n  else\n // continuous time relay\n if state then\n y = Ymax;\n else\n y = Ymin;\n end if;\n\n when (u >= ThH and not pre(state)) or (u <= ThL and pre(state)) then\n state = not pre(state);\n end when;\n  end if\n\n  ;\nend RelayHysteresis;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 8,
            "instruction": "Generate a Modelica model named `FirstOrder` to simulate a first order process, defined by the transfer function mu/(1+tau*s). It extends from a base block `IndustrialControlSystems.LinearSystems.Interfaces.BaseBlock`. The model should include parameters for the time constant 'tau' with value 2, the gain 'mu' with value 1, and the output 'y_start' with value 0. The initial equations is initial output 'y' equals to 'y_start'. The equations should describe the dynamic behavior where the derivative of output 'y' scaled with 'tau' plus the output itself equals the input 'u' multiplied by 'mu'.\n\n//modelica\n```model FirstOrder",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.LinearSystems.Continuous.FirstOrder",
            "output": "within IndustrialControlSystems.LinearSystems.Continuous;\nmodel FirstOrder \"First order process: mu/(1+tau*s)\"\n  extends Interfaces.BaseBlock;\n  parameter Real tau = 2 \"|Block parameters| pole's time constant\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| output initial value\";\ninitial equation\n  y = y_start;\nequation\n  y + tau*der(y) = mu*u\n  ;\nend FirstOrder;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 9,
            "instruction": "Create a Modelica model named `ComplexPoles` that represents a process with complex poles. The model should extend `IndustrialControlSystems.LinearSystems.Interfaces.DiscreteBaseBlock` and include the following parameters: 'xi' (Real, Damping coefficient, 0.8), 'omegan' (Real, Natural frequency, 0.1), 'mu' (Real, Gain, 1), 'y_start' (Real, Output initial value, 0), and 'dy_start' (Real, Slope initial value, 0). The parameters also include two protected Real paramete 'u_pre1', 'y_pre1'. In the initial equation section, set 'pre(y)' to 'y_start' and 'pre(y_pre1)' to 'dy_start'. The model's main equation should ensure that the damping coefficient 'xi' is between 0 and 1 using an assertion. It should be executed during discrete time sampling events, defined with 'sample(0, Ts)'. ​The result of 'IndustrialControlSystems.LinearSystems.Discrete.Functions.fCmplx((alfa,u,pre(u),pre(u_pre1),pre(y),pre(y_pre1),Ts,mu,xi,omegan))' is assigned to 'y', representing the process output at each sample point. After calculating 'y', the variables 'u_pre1' and 'y_pre1' should be updated with the previous values of 'u' and 'y' to prepare for the next sample.\n\n//modelica\n```model ComplexPoles",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.LinearSystems.Discrete.ComplexPoles",
            "output": "within IndustrialControlSystems.LinearSystems.Discrete;\nmodel ComplexPoles \"Process with complex poles\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real xi = 0.8 \"|Block parameters| Damping coefficient\";\n  parameter Real omegan = 0.1 \"|Block parameters| Natural frequency\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\n  parameter Real dy_start = 0 \"|Initial conditions| Slope initial value\";\nprotected\n  Real u_pre1;\n  Real y_pre1;\ninitial equation\n  pre(y) = y_start;\n  pre(y_pre1) = dy_start;\nequation\n  assert(xi>= 0 and xi <= 1,\"Dumping coefficient must be between 0 and 1.\");\n\n  when sample(0,Ts) then\n y = Functions.fCmplx(alfa,u,pre(u),pre(u_pre1),pre(y),pre(y_pre1),Ts,mu,xi,omegan);\n u_pre1 = pre(u);\n y_pre1 = pre(y);\n  end when\n  ;\nend ComplexPoles;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 10,
            "instruction": "Generate a Modelica function for a lead-lag process with the transfer function k(1+sT1)/(1+sT2). The function should be named `f1p1z`. The inputs should include 'alfa' (discretization parameter), 'T1' (zero), 'T2' (pole), 'u' (current input), 'u_pre' (previous input), 'y_pre' (previous output), 'Ts' (sampling time in seconds), and 'k' (gain). The output should be 'y' (output). The function should calculate intermediate variables(protected parameter) A, B, C, D, E, and F in algorithm as follows:\n- A := alfa*Ts;\n- B := Ts - alfa*Ts;\n- C := A + T1;\n- D := B - T1;\n- E := A + T2;\n- F := B - T2;\nThe output 'y' should be computed using the formula: y := (C*k*u + D*k*u_pre - F*y_pre)/E. All parameter variables involved in this function are Real.\n\n//modelica\n```function f1p1z",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.LinearSystems.Discrete.Functions.f1p1z",
            "output": "within IndustrialControlSystems.LinearSystems.Discrete.Functions;\nfunction f1p1z \"Function lead lag process: k(1+sT1)/(1+sT2)\"\n  input Real alfa \"Parametro di discretizzazione\";\n  input Real T1 \"Zero\";\n  input Real T2 \"Polo\";\n  input Real u \"Current input\";\n  input Real u_pre \"Previous input\";\n  input Real y_pre \"Previous output\";\n  input Real Ts \"Sampling time [s]\";\n  input Real k \"Gain\";\n  output Real y \"Output\";\nprotected\n  Real A;\n  Real B;\n  Real C;\n  Real D;\n  Real E;\n  Real F;\nalgorithm\n  A := alfa*Ts;\n  B := Ts - alfa*Ts;\n  C := A + T1;\n  D := B - T1;\n  E := A + T2;\n  F := B - T2;\n  y := (C*k*u + D*k*u_pre - F*y_pre)/E\n  ;\nend f1p1z;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 11,
            "instruction": "Generate a Modelica model for a component that performs a 'greater than or equal to' (>=) comparison between two integer inputs. The model should be named `GreatEq` and it should extend from the `IndustrialControlSystems.Logical.Comparisons.IntegerType.Interfaces.IntComparison` model. The inputs `u1` and `u2` are integers, and the output 'y' is a Boolean. The input and output exist in `IndustrialControlSystems.Logical.Comparisons.IntegerType.Interfaces.IntComparison` and does not need to be redeclared. In The equation section, the model includes a sample time parameter 'Ts', which when greater than 0, triggers the comparison at regular intervals; otherwise, the comparison is continuous. The value of `y` is `true` if `u1 >= u2`, otherwise `false`.\n\n//modelica\n```model GreatEq",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Logical.Comparisons.IntegerType.GreatEq",
            "output": "within IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel GreatEq \"Greather or equal (>=)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n when sample(0,Ts) then\n y = if (u1 >= u2) then true else false;\n end when;\n  else\n y = if (u1 >= u2) then true else false;\n  end if\n  ;\nend GreatEq;\n",
            "type": "model", 
            "feature": "extends"
        },
        {
            "id": 12,
            "instruction": "Generate a Modelica model for a comparison function that implements 'not equal (!=)' logic. The model should be named `NotEqual` and it should extend from the `IndustrialControlSystems.Logical.Comparisons.RealType.Interfaces.RealComparison` model. The inputs `u1` and `u2` are real signals, and the output 'y' is a Boolean. The input and output exist in `IndustrialControlSystems.Logical.Comparisons.RealType.Interfaces.RealComparison` and does not need to be redeclared. In The equation section, the model includes a sample time parameter 'Ts', which when greater than 0, triggers the comparison at regular intervals; otherwise, the comparison is continuous. If the absolute difference between u1 and u2 is less than a small threshold (eps), the output y should be false; otherwise, it should be true.\n\n//modelica\n```model NotEqual",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Logical.Comparisons.RealType.NotEqual",
            "output": "within IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel NotEqual \"not equal (!=)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n when sample(0,Ts) then\n y = if abs(u1 - u2)<eps then false else true;\n end when;\n  else\n y = if abs(u1 - u2)<eps then false else true;\n  end if\n  ;\nend NotEqual;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 13,
            "instruction": "Create a Modelica model named `Xnor` for an n-bit XNOR gate. The model should extend `IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock` with `nInput=2` and `final nOutput=1`. The functionality of the model is to perform an XNOR operation on n input signals and produce a single output signal.\nIn the equation part of the model, first use an assertion statement to determine 'nInput>=2'. If the parameter `Ts` (sample time) is greater than 0, the model should sample the input signals at regular intervals. The result should be a single output signal that use the expression `y[1] = not Functions.Xor(u[:], nInput)` to perform the XNOR operation.\n**Note**: If `Ts` is greater than 0, this expression should be executed within a `when sample(0, Ts)` block. Otherwise, it should be executed directly.\n\n//modelica\n```model Xnor",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Logical.LogicalOperations.Xnor",
            "output": "within IndustrialControlSystems.Logical.LogicalOperations;\nmodel Xnor \"Model of a n-bit XNOR\"\n  extends\n IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n when sample(0,Ts) then\n y[1] = not Functions.Xor(u[:], nInput);\n  end when;\n  else\n y[1] = not Functions.Xor(u[:], nInput);\n  end if\n  ;\nend Xnor;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 14,
            "instruction": "Generate a Modelica model named `Timer_OffDelay`. This model represents an OFF delay timer, which delays the deactivation of a signal. The model extends `IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer` and includes the following components: \n1. A Boolean variable 'run' which is true while the timer is counting.\n2. A Real variable 'startTime' representing the start time of the timer counting.\n3. A discrete Boolean variable 'Sd'. \n\nThe initial equations set 'startTime' to 0 and 'run' to false. \n\nThe main equations should include: \n1. 'Sd' equals 'S'.\n2. Using the 'sample(0,Ts)' function to trigger the timer: \n- 'startTime' is set by calling `IndustrialControlSystems.Logical.Timers.Functions.positiveEdge` with arguments '(pre(Sd), Sd, R, pre(startTime), time)'.\n- '(run, Q)' are determined using `IndustrialControlSystems.Logical.Timers.Functions.odt` with arguments '(S, R, PV, time, startTime)'.\n- 'tr' is calculated as 'if (not Q) then PV - (time - startTime) else PV'.\n\nPlease include the inheritance from `IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer` and ensure all variables are correctly parameterized and integrated.\n\n//modelica\n```model Timer_OffDelay",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.Logical.Timers.Timer_OffDelay",
            "output": "within IndustrialControlSystems.Logical.Timers;\nmodel Timer_OffDelay \"OFF delay timer model\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  discrete Boolean Sd;\ninitial equation\n  startTime = 0;\n  run = false;\nequation\n  Sd = S;\n  when sample(0,Ts) then\n startTime =\n IndustrialControlSystems.Logical.Timers.Functions.positiveEdge(\n pre(Sd),\n Sd,\n R,\n pre(startTime),\n time);\n (run,Q) = IndustrialControlSystems.Logical.Timers.Functions.odt(\n S,\n R,\n PV,\n time,\n startTime);\n tr = if (not Q) then PV - (time - startTime) else PV;\n  end when\n;\nend Timer_OffDelay;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 15,
            "instruction": "Create a Modelica model named `SmoothStep` for a 'Smooth Step Set Point Generator'. The model should extend `IndustrialControlSystems.MathOperations.RealType.Interfaces.RealNinOperation` with `final useInputs=false, final FixedPoint=false, final Nbit = 1, final scaleFactor = 1, final MAX = 1, final MIN = 0`. **Parameters**:\n- `tin = 10` (Real): Initial time for the smooth step [unit: second]\n- `alfa = 0.1` (Real): Portion of time for parabolic junctions [unit: dimensionless, range: 0 to 1]\n- `yin = 0` (Real): Output initial value [unit: dimensionless]\n- `yfin = 1` (Real): Output final value [unit: dimensionless]\n- `m = 0.1` (Real): Slope of the ramp [unit: dimensionless].\n\n**Equations and Expressions**:\n- `assert(alfa>=0 and alfa<=1, \"alfa out of range [0,1]\")`: Ensures the parameter `alfa` is within the valid range [0, 1].\n- `y = IndustrialControlSystems.MathOperations.RealType.Functions.fSmoothStep(time, tin, alfa, m, yin, yfin)`: the function `fSmoothStep` calculates the smooth step transition based on the given parameters.\n-`Ufp = zeros(nInput)`, `Yfp = 0`: the inputs and outputs related to the fixed-point representation are not used here.\n\nPlease generate the Modelica model accurately following these details.\n\n//modelica\n```model SmoothStep",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.MathOperations.RealType.Signals.SmoothStep",
            "output": "within IndustrialControlSystems.MathOperations.RealType.Signals;\nmodel SmoothStep \"Smooth step Set pointgenerator\"\n  extends Interfaces.RealNinOperation(final useInputs=false, final FixedPoint=false, final Nbit = 1, final scaleFactor = 1, final MAX = 1, final MIN = 0);\n  parameter Real tin = 10 \"|Smooth step| Initial time\";\n  parameter Real alfa = 0.1\n \"|Smooth step| Portion of time for parabolic junctions\";\n  parameter Real yin = 0 \"|Smooth step| Output initial value\";\n  parameter Real yfin = 1 \"|Smooth step| Output final value\";\n  parameter Real m = 0.1 \"|Smooth step| Slope of the ramp\";\nequation\n  assert(alfa>=0 and alfa<=1,\"alfa out of range [0,1]\");\n\n  y = IndustrialControlSystems.MathOperations.RealType.Functions.fSmoothStep(\n time,\n tin,\n alfa,\n m,\n yin,\n yfin);\n\n  // No Fixed Point here\n  Ufp = zeros(nInput);\n  Yfp = 0\n\n  ;\nend SmoothStep;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 16,
            "instruction": "Generate a Modelica function named `Mean` to compute the mean of a vector. The function should extends `IndustrialControlSystems.MathOperations.RealType.Functions.GeneralFunction`. It should have one input parameter 'u' which is a Real type vector. It should output a Real type 'y' which is the mean of the vector 'u'. The input 'u' and output 'y' exist in `RealType.Functions.GeneralFunction` and does not need to be redeclared. The algorithmic part of the function should calculate the number of elements 'n' in the vector 'u' and then compute the sum of the elements divided by 'n' as output 'y'. Where 'n' is a protected parameter of type Integer.\n\n//modelica\n```function Mean",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.MathOperations.Examples.Mean",
            "output": "within IndustrialControlSystems.MathOperations.Examples;\nfunction Mean \"This function computes the mean of a vector\"\n  extends RealType.Functions.GeneralFunction;\nprotected\n  Integer n;\nalgorithm\n  n :=size(u,1);\n\n  y := sum(u[i] for i in 1:n)/n\n\n  ;\nend Mean;\n",
            "type": "function",
            "feature": "extends"
        },
        {
            "id": 17,
            "instruction": "Generate a Modelica model named `Add` that adds two integer input parameters 'u1' and 'u2' and outputs their sum 'y'. The model should extend the `IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation`. The input 'u' and output 'y' exist in IntSimpleOperation and does not need to be redeclared. It should handle the addition through a conditional operation based on the sampling time Ts. If Ts is greater than zero, the output is computed at each sample point; otherwise, the output is the direct sum of the two inputs.\n\n//modelica\n```model Add",
            "input": "Modelica version: 4.0.0\nSource: IndustrialControlSystems.MathOperations.IntegerType.Add",
            "output": "within IndustrialControlSystems.MathOperations.IntegerType;\nmodel Add \"Sum of two integer numbers\"\n  extends\n IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nequation\n  if Ts > 0 then\n when sample(0,Ts) then\n y = u1 + u2;\n end when;\n  else\n y = u1 + u2;\n  end if\n  ;\nend Add;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 18,
            "instruction": "Create a Modelica model for a first-order low-pass filter with no output limitations. The model should be named `FirstOrder` and extend Modelica.Blocks.Interfaces.SISO with parameter `y(start = y_start)`. The purpose of this model is to apply a low-pass filter with a transfer function y/u = k/(1+s*T). Depending on the parameter `T`, the filter can either have dynamics or be reduced to a static gain. If T > 0, the model applies a dynamic low-pass filter; otherwise, it acts as a static gain.\n\nParameters:\n- `Boolean noDynamics` (default: `not(T > 0)`): Determines trivial configuration with no dynamics.\n- `Real k` (default: 1): Gain of the filter.\n- `Modelica.Units.SI.Time T`: Time constant of the filter.\n- `Modelica.Blocks.Types.Init initType` (default: `Modelica.Blocks.Types.Init.NoInit`): Type of initialization.\n- `Real y_start` (default: 0): Initial value of the output.\n- The instantiation of `Modelica.Blocks.Continuous.FirstOrder` named `firstOrder1`, which has parameters T = T, initType = initType, k = k, y_start = y_start, With conditions `if not noDynamics`.\n-The instantiation of `Modelica.Blocks.Math. Gain` named `gain`, which has parameters k = k, with conditions `if noDynamics`.\n\nThe Equations section includes the following connections :\n- connect(gain.y, y);\n- connect(firstOrder1.y, y);\n- connect(u, firstOrder1.u);\n- connect(u, gain.u);\n\nImplement the described `FirstOrder` model according to these specifications.\n\n//modelica\n```model FirstOrder",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Controls.FirstOrder",
            "output": "within PowerGrids.Controls;\nmodel FirstOrder\n  extends Modelica.Blocks.Interfaces.SISO(y(start = y_start));\n  parameter Boolean noDynamics = not(T > 0) \"Trivial configuration with no dynamics G(s) = k\";\n  parameter Real k=1 \"Gain\";\n  parameter SI.Time T \"Time Constant\";\n  parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\" ;\n  parameter Real y_start=0 \"Initial or guess value of output (= state)\" ;\n\n\n  Modelica.Blocks.Continuous.FirstOrder firstOrder1(T = T, initType = initType, k = k, y_start = y_start)  if not noDynamics ;\n  Modelica.Blocks.Math.Gain gain(k = k)  if noDynamics ;\nequation\n  connect(gain.y, y) ;\n  connect(firstOrder1.y, y) ;\n  connect(u, firstOrder1.u) ;\n  connect(u, gain.u) \n  ;\n\nend FirstOrder;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 19,
            "instruction": "Create a Modelica model named `DeadBand` for a dead-band controller with the following specifications:\n\n1. **Model Functionality**: The model implements a continuous dead-band functionality. The dead-band allows for an asymmetric range. When the 'smoothed' parameter is enabled, a smooth operator is applied. During initialization, the homotopy operator simplifies the model to y = u.\n\n2. **Inheritance and Interfaces**: The model extends `Modelica.Blocks.Interfaces.SISO`.\n\n3. **Parameters**: The model has the following parameters:\n   - `uMax` (Real, start=1): Upper limit of the dead zones.\n   - `uMin` (Real, default=-uMax): Lower limit of the dead zones.\n   - `smoothed` (Boolean, default=false): Indicates whether the smooth operator is applied.\n\n4. **Equations and Expressions**: The model includes the following equations:\n   - An assertion to ensure that uMax is greater than or equal to uMin: `assert(uMax >= uMin, \"Limits must be consistent\");`\n   - If `smoothed` is true, the output `y` is calculated using the `smooth` operator and `homotopy`:\n  `y = homotopy(actual = smooth(0, if u < uMin then u - uMin elseif u > uMax then u - uMax else 0), simplified = u);`\n   - If `smoothed` is false, the output `y` is calculated directly via `homotopy`:\n  `y = homotopy(actual = if u < uMin then u - uMin elseif u > uMax then u - uMax else 0, simplified = u);`\n\n//modelica\n```model DeadBand",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Controls.DeadBand",
            "output": "within PowerGrids.Controls;\nmodel DeadBand \"Dead-Band\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real uMax(start=1) \"Upper limits of dead zones\";\n  parameter Real uMin=-uMax \"Lower limits of dead zones\";\n  parameter Boolean smoothed = false \"Smooth operator is applied\" ;\n \nequation\n  assert(uMax >= uMin, \"Limits must be consistent\");\n  if smoothed then\n // The simplified model has no saturation, to make the controller equations linear\n y = homotopy(\n actual = smooth(0, if u < uMin then u - uMin elseif u > uMax then u - uMax else 0),\n simplified = u);  \n  else\n // The simplified model has no saturation, to make the controller equations linear\n y = homotopy(\n actual = if u < uMin then u - uMin elseif u > uMax then u - uMax else 0,\n simplified = u);  \n  end if\n  \n  ;\nend DeadBand;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 20,
            "instruction": "Generate a Modelica model for a Bus named `Bus`. The Bus model is designed to connect other components to its port, facilitating the integration and interaction of different electrical systems. It serves as a hub in a power grid system to facilitate electrical connections. \n\n**Inheritance and Interfaces**: The model should extend three components:\n1. `PowerGrids.Icons.Bus` for port characteristics with parameters VPuIcon = port.VPu, UIcon = port.U and UPhaseIcon = port.UPhase.\n2. `PowerGrids.Electrical.BaseClasses.SolutionChecking` for validation of results using VPuCheck = port.VPu and IPuCheck = port.IPu.\n3. `PowerGrids.Electrical.BaseClasses.OnePortAC` for single-phase AC port models with final SNom = 1, final PStart = 0, final QStart = 0, final hasSubPF, final localInit, final isLinear = true, redeclare PowerGrids.Electrical.PowerFlow.BusPF componentPF(UNom = UNom). \n\n**Equations and Expressions**: Include the equation 'port.i = Complex(0)' to denote the initial electrical current at the port.\n\nInclude these details in a well-structured Modelica model.\n\n//modelica\n```model Bus",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Electrical.Buses.Bus",
            "output": "within PowerGrids.Electrical.Buses;\nmodel Bus \"Bus model\"\n  extends Icons.Bus(VPuIcon = port.VPu, UIcon = port.U, UPhaseIcon = port.UPhase);\n  extends Electrical.BaseClasses.SolutionChecking(VPuCheck = port.VPu, IPuCheck = port.IPu);\n  extends PowerGrids.Electrical.BaseClasses.OnePortAC(\n final SNom = 1,\n final PStart = 0,\n final QStart = 0,\n final hasSubPF,\n final localInit,\n final isLinear = true,\n redeclare PowerGrids.Electrical.PowerFlow.BusPF componentPF(\n UNom = UNom));\n\nequation\n  port.i = Complex(0)\n  \n  ;\nend Bus;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Bus completed successfully.\nClass Bus has 91 equation(s) and 92 variable(s).\n59 of these are trivial equation(s)."
        },
        {
            "id": 21,
            "instruction": "Create a Modelica model named `TransformerWithPhaseShifterTarget`. The purpose of this model is to implement a transformer with a phase shifter that maintains a specified electrical quantity within an acceptable dead-band around a target value. The model ​extends the TransformerWithPhaseShifterInterval model with parameters:\n'final IMax = targetValueI + deadBandI',\n'final IMin = targetValueI - deadBandI',\n'final PMax = targetValueP + deadBandP',\n'final PMin = targetValueP - deadBandP'.\nThe model should handle two types of electrical quantities: Current Magnitude and Active Power.\n\n**Parameters:**\n- `targetValueI` (Units: Types.  Current, Default value: NotUsed): The target current value.\n- `deadBandI` (Units: Types. Current, Default value: NotUsed): The acceptable dead-band around the current target value.\n- `targetValueP` (Units: Types.ActivePower, Default value: NotUsed): The target active power value.\n- `deadBandP` (Units: Types.ActivePower, Default value: NotUsed): The acceptable dead-band around the active power target value.\n\n**Initial Conditions and Assertions:**\nIn the initial equation section, include the following conditions and assertions:\n- If the monitored quantity is current magnitude:\n  - Ensure `targetValueI` is greater than `deadBandI`.\n  - Ensure `deadBandI` is positive.\n  - Ensure `targetValueI` is non-negative.\n- If the monitored quantity is active power:\n  - Ensure `targetValueP` is greater than `deadBandP`.\n  - Ensure `deadBandP` is positive.\n  - Ensure `targetValueP` is non-negative.\n\nInclude these details in a well-structured Modelica model.\n\n//modelica\n```model TransformerWithPhaseShifterTarget",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Electrical.Branches.TransformerWithPhaseShifterTarget",
            "output": "within PowerGrids.Electrical.Branches;\nmodel TransformerWithPhaseShifterTarget\n  extends TransformerWithPhaseShifterInterval(\n final IMax = targetValueI + deadBandI, \n final IMin = targetValueI - deadBandI,\n final PMax = targetValueP + deadBandP,\n final PMin = targetValueP - deadBandP);\n  \n  parameter Types.Current targetValueI = NotUsed \"Current target value\" ;\n  parameter Types.Current deadBandI = NotUsed \"Acceptable dead-band next to the Current target value\" ;\n  parameter Types.ActivePower targetValueP = NotUsed \"Current target value\" ;\n  parameter Types.ActivePower deadBandP = NotUsed \"Maximum Active Power threshold for phase shifter logic\" ;\n\ninitial equation\n  if quantitySel == MonitoredQuantitySelection.currentMagnitude then\n assert(targetValueI > deadBandI, \"Dead band cannot exceed the target value\");\n assert(deadBandI > 0, \"Dead band must be positive\");\n assert(targetValueI >= 0, \"Target value must be positive\");\n  elseif quantitySel == MonitoredQuantitySelection.activePower then\n assert(targetValueP > deadBandP, \"Dead band cannot exceed the target value\");\n assert(deadBandP > 0, \"Dead band must be positive\");\n assert(targetValueP >= 0, \"Target value must be positive\");\n  end if\n  \n  ;\nend TransformerWithPhaseShifterTarget;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f"
        },
        {
            "id": 22,
            "instruction": "Generate a Modelica model that outlines a PQ bus within a power grid system named `PQBus`. The 'PQBus1' model in Modelica serves to prescribe the active power (P) and reactive power (Q) entering the bus within a power grid system. It aims to accurately represent the conditions under which power flows into the bus.\n\n**Inheritance and Interfaces:** The PQBus model extends multiple components and integrates their functionalities as follows:\n- extends `PowerGrids.Icons.Load`, specifically mapping 'PIcon' to 'port.P', 'QIcon' to 'port.Q', 'PPuIcon' to 'port.PPu', and 'QPuIcon' to 'port.QPu'.\n- extends `PowerGrids.Electrical.BaseClasses.SolutionChecking` with 'VPuCheck' mapped to 'port.VPu' and 'IPuCheck' mapped to 'port.IPu' for solution validation.\n- extends `PowerGrids.Electrical.BaseClasses.OnePortACPF` with a final variable setting of 'portVariablesPhases = true' for phase-specific port variable configurations.\n\n**Parameters:** This model includes the following input parameters:\n- Active Power 'P' of type 'PowerGrids.Types.ActivePower' with a default value of 'SNom', representing the active power entering the bus.\n- Reactive Power 'Q' of type 'PowerGrids.Types.ReactivePower' with a default value of '0', representing the reactive power entering the bus.\nBoth parameters are essential for the accurate representation of electrical power flow in the bus and are measured in their respective units.\n\n**Equations and Expressions:** The critical equations for this model are:\n`port.P = P;`\n`port.Q = Q;`\nThese equations ensure the conservation and correct assignment of active and reactive power in the system.\n\nInclude these details in a well-structured Modelica model.\n\n//modelica\n```model PQBus",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Electrical.PowerFlow.PQBus",
            "output": "within PowerGrids.Electrical.PowerFlow;\nmodel PQBus \"PQ bus\"\n  extends Icons.Load(PIcon = port.P, QIcon = port.Q, PPuIcon = port.PPu, QPuIcon = port.QPu);\n  extends Electrical.BaseClasses.SolutionChecking(VPuCheck = port.VPu, IPuCheck = port.IPu);\n  extends BaseClasses.OnePortACPF(final portVariablesPhases = true);\n  parameter Types.ActivePower P = SNom \"Active power entering the bus\";\n  parameter Types.ReactivePower Q = 0 \"Reactive power entering the bus\";\nequation\n  port.P = P;\n  port.Q = Q\n;\n\nend PQBus;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of PQBus completed successfully.\nClass PQBus has 42 equation(s) and 42 variable(s).\n22 of these are trivial equation(s)."
        },
        {
            "id": 23,
            "instruction": "Please generate a Modelica model named `GovHydro4GeneralPurpose` for a general-purpose governor for hydraulic turbines, specifically designed for use within an electrical power grid system. The model should extends `PowerGrids.Electrical.Controls.TurbineGovernors.BaseClasses.GovHydro4Base`. The model should connect the `deadBandDb2.y` to `div1. u1` in the equation part.\n\n//modelica\n```model GovHydro4GeneralPurpose",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Electrical.Controls.TurbineGovernors.GovHydro4GeneralPurpose",
            "output": "within PowerGrids.Electrical.Controls.TurbineGovernors;\nmodel GovHydro4GeneralPurpose \"Simple general-purpose governor for hydraulic turbines\"\n  extends BaseClasses.GovHydro4Base;\nequation\n  connect(deadBandDb2.y, div1.u1) \n  ;\nend GovHydro4GeneralPurpose;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 24,
            "instruction": "Generate a Modelica function named `largerTimeConstant`. This function calculates the larger time constant in a polynomial representing a voltage characteristic in a power grid. The polynomial is described by (1 + sT1)(1 + sT2) = 1 + as + bs^2 with T1 > T2. The input parameters are 'a' and 'b', both of type Real, where 'a' represents the coefficient of s and 'b' represents the coefficient of s^2. The output parameter of the function is a Real type variable 'T', which is the larger time constant T1. The specific formula used in the algorithm part is T := (a + sqrt(abs(a^2-4*b)))/2.\n\n//modelica\n```function largerTimeConstant",
            "input": "Modelica version: 4.0.0\nSource: PowerGrids.Functions.largerTimeConstant",
            "output": "within PowerGrids.Functions;\nfunction largerTimeConstant\n  extends Modelica.Icons.Function;\n  input Real a;\n  input Real b;\n  output Real T;\nalgorithm\n  T := (a + sqrt(abs(a^2-4*b)))/2\n  ;\nend largerTimeConstant;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 25,
            "instruction": "Generate a Modelica block for sub-sampling a clocked Boolean input signal and providing it as a clocked output signal. The model should be a block named `SubSample`. The model has the following parameters:\n\n1. 'inferFactor' (Boolean, default=true): If true, the sub-sampling factor is inferred automatically.\n2. 'factor(min=1)' (Integer, default=1): The sub-sampling factor, ignored if 'inferFactor' is true.\n\nThe model should include:\n\n- A Boolean input signal 'u' of type `Modelica.Blocks.Interfaces.BooleanInput`.\n- A Boolean output signal 'y' of type `Modelica.Blocks.Interfaces.BooleanOutput`.\n The clock of 'y' should be slower than the clock of 'u'.\n\nIn the equation section, implement the logic as follows:\n\n- If 'inferFactor' is true, use the `subSample(u)` function to automatically infer the sub-sampling factor and assign the result to 'y'.\n- If 'inferFactor' is false, use the `subSample(u, factor)` function, with 'factor' determining the sub-sampling rate, and assign the result to 'y'.\n\nEnsure that the output signal 'y' reflects the correct sub-sampling of the input signal 'u' based on the inferred or specified factor.\n\n//modelica\n```block SubSample",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.BooleanSignals.Sampler.SubSample",
            "output": "within Modelica.Clocked.BooleanSignals.Sampler;\nblock SubSample\n  \"Sub-sample the clocked Boolean input signal and provide it as clocked output signal\"\n  parameter Boolean inferFactor=true\n \"= true, if sub-sampling factor is inferred\"  ;\n  parameter Integer factor(min=1)=1\n \"Sub-sampling factor >= 1 (ignored if inferFactor=true)\"\n;\n  Modelica.Blocks.Interfaces.BooleanInput\nu\n \"Connector of clocked, Boolean input signal\"\n ;\n  Modelica.Blocks.Interfaces.BooleanOutput\ny\n \"Connector of clocked, Boolean output signal (clock of y is slower as clock of u)\"\n ;\nequation\n  if inferFactor then\n  y = subSample(u);\n  else\n  y = subSample(u,factor);\n  end if\n  ;\nend SubSample;\n",
            "type": "block",
            "feature": "instantiation"
        },
        {
            "id": 26,
            "instruction": "Generate a Modelica block named `BooleanChange` that indicates changes in a Boolean signal within the context of clocked, non-periodic signals. The model should extend from the `Modelica.Clocked.ClockSignals.Interfaces.ClockedBlockIcon` class.\nThe model should include:\n- A Boolean input signal 'u' of type `Modelica.Blocks.Interfaces.BooleanInput`.\n- A Boolean output signal 'y' of type `Modelica.Blocks.Interfaces.BooleanOutput`.\nIn the equation part, the output 'y' should be set to 'false' if the first tick(use function firstTick()), else it should be set to changing in the Boolean input 'u' by outputting 'not (u == previous(u))' on subsequent ticks.\n\n//modelica\n```block BooleanChange",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.BooleanSignals.NonPeriodic.BooleanChange",
            "output": "within Modelica.Clocked.BooleanSignals.NonPeriodic;\nblock BooleanChange \"Indicate Boolean signal changing\"\n  extends Clocked.ClockSignals.Interfaces.ClockedBlockIcon;\n  Modelica.Blocks.Interfaces.BooleanInput u\n \"Connector of Boolean input signal.\"\n ;\n  Modelica.Blocks.Interfaces.BooleanOutput y\n \"Connector of Boolean output signal.\"\n ;\nequation\n  if firstTick() then\n y = false;\n  else\n y = not (u == previous(u));\n  end if\n  ;\nend BooleanChange;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of BooleanChange1 completed successfully.\nClass BooleanChange1 has 1 equation(s) and 1 variable(s).\n0 of these are trivial equation(s)."
        },
        {
            "id": 27,
            "instruction": "Create a Modelica block named `EventClock`. The purpose of the model is to generate a clock signal when the Boolean input changes from false to true. The model should extend `Modelica.Clocked.ClockSignals.Interfaces.PartialClock`. The input parameter is a Boolean signal 'u' of type `Modelica.Blocks.Interfaces.BooleanInput`. The output is a clock signal 'y'. In the equation part, if the 'useSolver' flag is true, the output 'y' should be generated using the 'Clock(Clock(u), solverMethod=solverMethod)'; otherwise, the output should be generated using the 'Clock(u)'.\n\n//modelica\n```block EventClock",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.ClockSignals.Clocks.EventClock",
            "output": "within Modelica.Clocked.ClockSignals.Clocks;\nblock EventClock\n  \"Generate a clock signal when the Boolean input changes from false to true\"\n  extends Clocked.ClockSignals.Interfaces.PartialClock;\n  Modelica.Blocks.Interfaces.BooleanInput u\n ;\nequation\n  if useSolver then\n  y = Clock(Clock(u), solverMethod=solverMethod);\n  else\n  y = Clock(u);\n  end if\n  ;\nend EventClock;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 28,
            "instruction": "Generate a Modelica block named `ConjunctiveClock` with the following for a logical clock (`ConjunctiveClock1`) that ticks when all input clocks have ticked at least once, then resets for the next cycle. This block extends `Modelica.Clocked.ClockSignals.Clocks.Logical.PartialLogicalClock` and redeclares the `combinator` parameter with the AND operation(`Modelica.Blocks.MathBoolean.And`) in `PartialLogicalClock`.\n\n//modelica\n```block ConjunctiveClock",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.ClockSignals.Clocks.Logical.ConjunctiveClock",
            "output": "within Modelica.Clocked.ClockSignals.Clocks.Logical;\nblock ConjunctiveClock\n  \"Logical clock ticking whenever all input clocks ticked at least once, then resets and starts the next conjunctive cycle\"\n  extends PartialLogicalClock(\n redeclare Modelica.Blocks.MathBoolean.And combinator)\n  ;\nend ConjunctiveClock;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 29,
            "instruction": "Create a Modelica model named `SpeedControl` for the discrete control of crankshaft speed by throttle actuation. The model should include the following details:\n\n1. **Parameters**:\n- `k_p`: Proportional gain, a real number with a value of 0.0614. \n- `k_I`: Integral gain, a real number with a value of 0.0723.\n- `N_des`: Desired speed, a `Modelica.Blocks.Interfaces.RealInput` with units of rad/s and an initial value of 0.\n- `N`: Measured speed, a `Modelica.Blocks.Interfaces.RealInput` with units of rad/s and an initial value of 0.\n- `Theta`: Throttle angle, a `Modelica.Blocks.Interfaces.RealOutput` of with units of degrees and an initial value of 8.9.\n- `x_d`: With type `Modelica.Units.NonSI.Angle_deg`, a protected variable representing an angle in degrees, initialized to 8.973 and fixed.\n\n2. **Equations and Expressions**:\n- Implement the following equations within a discrete clocked system:\n- `x_d = previous(x_d) + k_I * interval() * (previous(N_des) - previous(N));`\n- `Theta = k_p * (N_des - N) + x_d;`\n- These equations should be executed within a `when Clock() then...end when` block.\n\n//modelica\n```block SpeedControl",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Systems.Utilities.ComponentsThrottleControl.SpeedControl",
            "output": "within Modelica.Clocked.Examples.Systems.Utilities.ComponentsThrottleControl;\nblock SpeedControl\n  \"Discrete control of crankshaft speed by throttle actuation\"\n  parameter Real k_p = 0.0614 \"Proportional gain\";\n  parameter Real k_I = 0.0723 \"Integral gain\";\n  Modelica.Blocks.Interfaces.RealInput N_des(unit=\"rad/s\", start=0) \"Desired speed, (rad/s)\" ;\n  Modelica.Blocks.Interfaces.RealInput N(unit=\"rad/s\", start=0) \"Measured speed, (rad/s)\" ;\n  Modelica.Blocks.Interfaces.RealOutput Theta(start=8.9, unit=\"deg\")\n \"Throttle angle (deg)\" ;\nprotected\n  Modelica.Units.NonSI.Angle_deg x_d(start=8.973, fixed=true);\nequation\n  when Clock() then\n  x_d = previous(x_d) + k_I*interval()*(previous(N_des) - previous(N));\n  Theta = k_p*(N_des - N) + x_d;\n  end when\n  ;\nend SpeedControl;\n",
            "type": "block",
            "feature": "instantiation"
        },
        {
            "id": 30,
            "instruction": "Generate a Modelica model of a Mixing Unit named `MixingUnit`. The functionality of the model is to simulate the mixing of substances with cooling temperature input and provide outputs for concentration and temperature. The inputs and outputs are: \n- `RealInput T_c` (unit: K), representing the cooling temperature. \n- `RealOutput c` (unit: mol/l), representing the concentration. \n- `RealOutput T` (unit: K), representing the temperature inside the mixing unit. \n\nThe model includes several parameters: \n- `Real c0 = 0.848` (unit: mol/l), the nominal concentration. \n- `Modelica.Units.SI.Temperature T0 = 308.5`, the nominal temperature. \n- `Real a1 = 0.2674`, `a21 = 1.815`, `a22 = 0.4682`, `b = 1.5476`, `k0 = 1.05e14`, `eps = 34.2894`, all of which are process parameters.\n\nThe protected variables include: \n- `Modelica.Units.SI.Time tau0 = 60`, a protected parameter related to time constants in the system.\n- `Real wk0 = k0/c0`, `weps = eps*T0`, `wa11 = a1/tau0`, `wa12 = c0/tau0`, `wa13 = c0*a1/tau0`, `wa21 = a21/tau0`, `wa22 = a22*T0/tau0`, `wa23 = T0*(a21 - b)/tau0`, `wb = b/tau0`.\n\nThe key equations governing the model are: \n- `gamma = c*wk0*exp( -weps/T)` (reaction speed calculation). \n- `der(c) = -wa11*c - wa12*gamma + wa13` (differential equation for concentration). \n- `der(T) = -wa21*T + wa22*gamma + wa23 + wb*T_c` (differential equation for temperature).\nNote that the initial value of T is 1.\n\n//modelica\n```model MixingUnit",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Systems.Utilities.ComponentsMixingUnit.MixingUnit",
            "output": "within Modelica.Clocked.Examples.Systems.Utilities.ComponentsMixingUnit;\nmodel MixingUnit\n  \"Mixing unit demo from Foellinger, Nichtlineare Regelungen II, p. 280\"\n  Modelica.Blocks.Interfaces.RealInput T_c(unit=\"K\")\n \"Cooling temperature\"\n ;\n  Modelica.Blocks.Interfaces.RealOutput c(unit=\"mol/l\") \"Concentration\"\n ;\n  Modelica.Blocks.Interfaces.RealOutput T(unit=\"K\")\n \"Temperature in mixing unit\"\n ;\n  parameter Real c0(unit=\"mol/l\") = 0.848 \"Nominal concentration\";\n  parameter SI.Temperature T0 = 308.5 \"Nominal temperature\";\n  parameter Real a1 = 0.2674 \"Process parameter (see references in help)\";\n  parameter Real a21 = 1.815 \"Process parameter (see references in help)\";\n  parameter Real a22 = 0.4682 \"Process parameter (see references in help)\";\n  parameter Real b = 1.5476 \"Process parameter (see references in help)\";\n  parameter Real k0 = 1.05e14 \"Process parameter (see references in help)\";\n  parameter Real eps = 34.2894 \"Process parameter (see references in help)\";\n  Real gamma \"Reaction speed\";\nprotected\n  parameter SI.Time tau0 = 60;\n  parameter Real wk0 = k0/c0;\n  parameter Real weps = eps*T0;\n  parameter Real wa11 = a1/tau0;\n  parameter Real wa12 = c0/tau0;\n  parameter Real wa13 = c0*a1/tau0;\n  parameter Real wa21 = a21/tau0;\n  parameter Real wa22 = a22*T0/tau0;\n  parameter Real wa23 = T0*(a21 - b)/tau0;\n  parameter Real wb = b/tau0;\nequation\n  gamma = c*wk0*exp( -weps/T);\n  der(c) = -wa11*c - wa12*gamma + wa13;\n  der(T) = -wa21*T + wa22*gamma + wa23 + wb*T_c\n  ;\nend MixingUnit;\n",
            "type": "model",
            "feature": "instantiation"
        },
        {
            "id": 31,
            "instruction": "Create a Modelica model named `ShiftSample` demonstrating the usage of a 'ShiftSample' block for Clock signals.\n\nIt includes the following components: 1) A 'PeriodicExactClock' from `Modelica.Clocked.ClockSignals.Clocks` with a factor of 20 and resolution set to `Modelica.Clocked.Types.Resolution.ms`. 2) A 'ShiftSample' from `Modelica.Clocked.ClockSignals.Sampler` with a shiftCounter of 4 and resolution of 3. 3) A 'SampleClocked' from `Modelica.Clocked.RealSignals.Sampler`. 4) A 'Sine' block from `Modelica.Blocks.Sources` with frequency 2, offset 0.1, and startTime 0.\n\nDefine the necessary equations to connect the components as follows: Connect 'periodicClock.y' to 'shiftSample1.u', 'shiftSample1.y' to 'sample1.clock', and 'sine.y' to 'sample1.u'.\n\nEnsure the model handles accurate clock signals and shifting sample behavior.\n\n//modelica\n```model ShiftSample",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.ClockSignals.ShiftSample",
            "output": "within Modelica.Clocked.Examples.Elementary.ClockSignals;\nmodel ShiftSample \"Example of a ShiftSample block for Clock signals\"\n   extends Modelica.Icons.Example;\n  Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock(\n   factor=20, resolution=Modelica.Clocked.Types.Resolution.ms)\n ;\n  Modelica.Clocked.ClockSignals.Sampler.ShiftSample shiftSample1(shiftCounter=4,\n   resolution=3)\n ;\n  Modelica.Clocked.RealSignals.Sampler.SampleClocked sample1\n ;\n  Modelica.Blocks.Sources.Sine sine(f=2,\n offset=0.1,\n startTime=0)\n ;\nequation\n  connect(periodicClock.y, shiftSample1.u) ;\n  connect(sine.y, sample1.u)\n ;\n  connect(shiftSample1.y, sample1.clock) \n  ;\nend ShiftSample;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 32,
            "instruction": "Create a Modelica model named `Sample3` as an example of a Sample block for Real signals with direct feed-through in the continuous-time and the clocked partition. Ensure accurate parameterization for the components:\n\n1.**Parameters**:\n- 'periodicClock' from 'Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock' with a 'factor' of 20 and a resolution of 'Modelica.Clocked.Types.Resolution.ms'.\n- 'step' from 'Modelica.Blocks.Sources.Step' with a 'startTime' of 0.04.\n- 'gain' from 'Modelica.Blocks.Math.Gain' with a gain factor 'k' of 1.2.\n- 'hold' from 'Modelica.Clocked.RealSignals.Sampler.Hold'.\n- 'sample1' from 'Modelica.Clocked.RealSignals.Sampler.SampleClocked' and 'sample2' from 'Modelica.Clocked.RealSignals.Sampler.Sample'.\n\n2.**Equations**:\n- Connect 'step.y' to 'sample1.u'.\n- Connect 'gain.y' to 'hold1.u'.\n- Connect 'feedback.y' to 'gain.u'.\n- Connect 'sample2.y' to 'feedback.u2'.\n- Connect 'periodicClock.y' to 'sample1.clock'.\n- Connect 'sample1.y' to 'feedback.u1'.\n- Connect 'hold1.y' to 'sample2.u'.\n\n 3.The periodic clock is used to control the sampling, and the feedback loop controls the gain with a delay introduced by the 'hold1' component.\n\n//modelica\n```model Sample3",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.RealSignals.Sample3",
            "output": "within Modelica.Clocked.Examples.Elementary.RealSignals;\nmodel Sample3\n  \"Example of a Sample block for Real signals with direct feed-through in the continuous-time and the clocked partition\"\n extends Modelica.Icons.Example;\n  Modelica.Clocked.RealSignals.Sampler.SampleClocked sample1\n ;\n  Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock(\n factor=20, resolution=Modelica.Clocked.Types.Resolution.ms)\n ;\nModelica.Blocks.Sources.Step step(startTime=0.04)\n  ;\n  Modelica.Blocks.Math.Gain gain(k=1.2)\n ;\n  Modelica.Clocked.RealSignals.Sampler.Hold hold1\n ;\n  Modelica.Blocks.Math.Feedback feedback\n ;\n  Modelica.Clocked.RealSignals.Sampler.Sample sample2\n ;\nequation\n  connect(step.y, sample1.u)\n;\n  connect(gain.y, hold1.u)\n ;\n  connect(feedback.y, gain.u) ;\n  connect(sample2.y, feedback.u2) ;\n  connect(periodicClock.y, sample1.clock) ;\n  connect(sample1.y, feedback.u1) ;\n  connect(hold1.y, sample2.u) \n  ;\nend Sample3;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 33,
            "instruction": "Generate a Modelica model named `BackSample` that represents an example of a BackSample block for Real signals.\n\nThe parameters for each component are as follows:\n1. **Sine**: A sine wave signal from 'Modelica.Blocks.Sources.Sine' with parameters: frequency `f=2`, offset `offset=0.1`, and start time `startTime=0`.\n2. **sample1** from 'Modelica.Clocked.RealSignals.Sampler.SampleClocked' for clocked signals.\n3. **periodicClock** from 'Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock' with `factor=20` and a resolution from the `Modelica.Clocked.Types.Resolution` enumeration, set to `ms` (milliseconds).\n4. **shiftSample1** from 'Modelica.Clocked.RealSignals.Sampler.ShiftSample' with parameters `shiftCounter=4` and resolution `resolution=3`.\n5. **backSample1** from 'Modelica.Clocked.RealSignals.Sampler.BackSample' with parameters `backCounter=4`, `resolution=3`, and initial output `y_start=0.5`.\n\nThe model should define the connections between these components as follows:\n- Connect the output of the 'sine' to the input of the 'sample1' block.\n- Connect the output of the 'periodicClock' to the clock input of the 'sample1' block.\n- Connect the output of the 'sample1' block to the input of the 'shiftSample1' block.\n- Connect the output of the 'shiftSample1' block to the input of the 'backSample1' block.\n\n//modelica\n```model BackSample",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.RealSignals.BackSample",
            "output": "within Modelica.Clocked.Examples.Elementary.RealSignals;\nmodel BackSample \"Example of a BackSample block for Real signals\"\n   extends Modelica.Icons.Example;\n  Modelica.Blocks.Sources.Sine sine(f=2,\n offset=0.1,\n startTime=0)\n ;\n  Modelica.Clocked.RealSignals.Sampler.SampleClocked sample1\n ;\n  Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock(\n factor=20, resolution=Modelica.Clocked.Types.Resolution.ms)\n ;\n  Modelica.Clocked.RealSignals.Sampler.ShiftSample shiftSample1(\n shiftCounter=4, resolution=3)\n ;\nModelica.Clocked.RealSignals.Sampler.BackSample backSample1(\n  backCounter=4,\n  resolution=3,\n  y_start=0.5)\n  ;\nequation\n  connect(sine.y, sample1.u)\n ;\n  connect(periodicClock.y, sample1.clock) ;\n  connect(sample1.y, shiftSample1.u)\n ;\nconnect(shiftSample1.y, backSample1.u) \n  ;\nend BackSample;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 34,
            "instruction": "Generate a Modelica model named `TimeBasedSine` that uses a clocked time based Sine source block.\n\nThe model should include:\n1.'assignClock1' from 'Modelica.Clocked.RealSignals.Sampler.AssignClock';\n2.'periodicClock1' from 'Modelica.Clocked.ClockSignals.Clocks.PeriodicRealClock' with period=0.1;\n3.'sine' from 'Modelica.Clocked.RealSignals.TimeBasedSources.Sine' with f=2.\n\nIn the equation part, the sine wave generator's output should be connected to assignClock1.u and periodicClock1.y should be connected to assignClock1.clock.\n\n//modelica\n```model TimeBasedSine",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.RealSignals.TimeBasedSine",
            "output": "within Modelica.Clocked.Examples.Elementary.RealSignals;\nmodel TimeBasedSine\n  \"Example of using the clocked time based Sine source block\"\n   extends Modelica.Icons.Example;\nModelica.Clocked.RealSignals.Sampler.AssignClock assignClock1\n  ;\nModelica.Clocked.ClockSignals.Clocks.PeriodicRealClock\n  periodicClock1(period=0.1)\n  ;\nModelica.Clocked.RealSignals.TimeBasedSources.Sine\nsine(f=2)\n  ;\nequation\nconnect(periodicClock1.y, assignClock1.clock) ;\nconnect(sine.y, assignClock1.u) \n;\nend TimeBasedSine;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 35,
            "instruction": "Generate a Modelica model that represents an example of a SuperSample block for Integer signals named `SuperSample`. The model should extend `Modelica.Icons.Example` and use the following components: \n1. `Modelica.Clocked.IntegerSignals.Sampler.SampleClocked sample1` for sampling clocked integer signals.\n2. `Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock` with parameters `factor=20` and `resolution=Modelica.Clocked.Types.Resolution.ms` (milliseconds).\n3. `Modelica.Clocked.IntegerSignals.Sampler.SuperSample superSample1` with parameters `inferFactor=false` and `factor=3` for supersampling.\n4. `Modelica.Blocks.Sources.IntegerTable table` to provide integer values as a table, with the data `table=[0,1; 0.05,2; 0.1,0; 0.15,-1; 0.2,3]`.\n\nDefine the connections between these components as follows:\n- Connect the output of the 'periodicClock' to the clock input of the 'sample1' block.\n- Connect the output of the 'table' to the input of the 'sample1' block.\n- Connect the output of the 'sample1' block to the input of the 'superSample1' block.\n\n//modelica\n```model SuperSample",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.IntegerSignals.SuperSample",
            "output": "within Modelica.Clocked.Examples.Elementary.IntegerSignals;\nmodel SuperSample \"Example of a SuperSample block for Integer signals\"\n   extends Modelica.Icons.Example;\n  Modelica.Clocked.IntegerSignals.Sampler.SampleClocked sample1\n ;\n  Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock(\n factor=20, resolution=Modelica.Clocked.Types.Resolution.ms)\n ;\nModelica.Clocked.IntegerSignals.Sampler.SuperSample superSample1(inferFactor=\n false, factor=3)\n ;\n  Modelica.Blocks.Sources.IntegerTable table(table=[0,1; 0.05,2; 0.1,0; 0.15,-1;\n 0.2,3])\n ;\nequation\n  connect(periodicClock.y, sample1.clock) ;\n  connect(table.y, sample1.u)\n ;\n  connect(sample1.y, superSample1.u)\n\n  ;\nend SuperSample;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 36,
            "instruction": "Generate a Modelica model that represents an example of a Hold block for Boolean signals named `Hold`. The model should extend `Modelica.Icons.Example` and include the following components: \n1. `Modelica.Blocks.Sources.BooleanTable table` with data `table={0.05, 0.15}` to provide Boolean values as input.\n2. `Modelica.Clocked.BooleanSignals.Sampler.SampleClocked sample1` for sampling the clocked Boolean signals.\n3. `Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock` with parameters `factor=20` and `resolution=Modelica.Clocked.Types.Resolution.ms` (milliseconds).\n4. `Modelica.Clocked.BooleanSignals.Sampler.Hold hold1` with an initial output `y_start=false` to hold the sampled Boolean signal.\n5. `Modelica.Clocked.BooleanSignals.Sampler.ShiftSample shiftSample1` with the parameter `shiftCounter=2` to shift the sampled signal.\n\nDefine the connections between the components as follows:\n- Connect the output of the 'periodicClock' to the clock input of the 'sample1' block.\n- Connect the output of the 'table' to the input of the 'sample1' block.\n- Connect the output of the 'sample1' block to the input of the 'shiftSample1' block.\n- Connect the output of the 'shiftSample1' block to the input of the 'hold1' block.\n\n//modelica\n```model Hold",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.Examples.Elementary.BooleanSignals.Hold",
            "output": "within Modelica.Clocked.Examples.Elementary.BooleanSignals;\nmodel Hold \"Example of a Hold block for Boolean signals\"\n   extends Modelica.Icons.Example;\n  Modelica.Blocks.Sources.BooleanTable table(table={0.05,0.15})\n ;\n  Modelica.Clocked.BooleanSignals.Sampler.SampleClocked sample1\n ;\n  Modelica.Clocked.ClockSignals.Clocks.PeriodicExactClock periodicClock(\n factor=20, resolution=Modelica.Clocked.Types.Resolution.ms)\n ;\nModelica.Clocked.BooleanSignals.Sampler.Hold hold1(y_start=false)\n ;\nModelica.Clocked.BooleanSignals.Sampler.ShiftSample shiftSample1(shiftCounter=2)\n ;\nequation\n  connect(periodicClock.y, sample1.clock) ;\n  connect(table.y, sample1.u)\n ;\n  connect(shiftSample1.u, sample1.y)\n ;\n  connect(hold1.u, shiftSample1.y)\n\n  ;\nend Hold;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 37,
            "instruction": "Generate a Modelica block model that assigns a clock to a clocked Integer signal named `AssignClock`. The model should extend `Modelica.Clocked.IntegerSignals.Sampler.AssignClock` and include the following components: \n1. `Modelica.Blocks.Interfaces.IntegerInput u` to define the connector for the clocked Integer input signal.\n2. `Modelica.Blocks.Interfaces.IntegerOutput y` to define the connector for the clocked Integer output signal.\n3. `Modelica.Clocked.ClockSignals.Interfaces.ClockInput clock` to define the clock input for the model.\n\nIn the equation section, use a `when` clause triggered by the clock signal to assign the input `u` to the output `y`. Ensure that the clock signal governs the assignment of the input to the output.\n\n//modelica\n```block AssignClock",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.IntegerSignals.Sampler.AssignClock",
            "output": "within Modelica.Clocked.IntegerSignals.Sampler;\nblock AssignClock \"Assign a clock to a clocked Integer signal\"\n  Modelica.Blocks.Interfaces.IntegerInput u\n \"Connector of clocked, Integer input signal\"\n ;\n  Modelica.Blocks.Interfaces.IntegerOutput y\n \"Connector of clocked, Integer output signal\"\n ;\n   Clocked.ClockSignals.Interfaces.ClockInput clock ;\nequation\n  when clock then\n y = u;\n  end when\n  ;\nend AssignClock;\n",
            "type": "block",
            "feature": "instantiation"
        },
        {
            "id": 38,
            "instruction": "Generate a Modelica block named `FractionalDelay` for a FractionalDelay component that delays the incoming clocked input signal by a fractional multiple of the sample period. This model is typically used in systems requiring fine-grained control of signal processing, such as digital communication or signal filtering. The model extends `Modelica.Clocked.IntegerSignals.Interfaces.PartialClockedSISO`, adhering to a single input, single output methodology within clocked behavior constraints.\n\nInputs:\n- 'shift(min=0)' (Integer parameter, default value: 0): Specifies the delay as a product of the sample period (interval()) and the ratio shift/resolution.\n- 'resolution(min=1)' (Integer parameter, default value: 1): Represents the time quantization resolution of the sample period.\n\nThe model contains the following protected parameters:\n- 'n = div(shift,resolution)', Integer;\n- 'u_buffer[n+1](each start=0)', Integer, representing the previous values of the inputs, u_last[1] = u, u_last[2] = previous(u_last[1]);\n- 'first(start=true)', Boolean, Used to identify the first clock tick.\n\nEquation Handling:\n- Initialize first to true and set it to false after the first clock tick.\n- Use u_buffer to track the input signal history, updating it with each clock tick(u_buffer = if previous(first) then fill(u,n+1) else cat(1, {u}, previous(u_buffer[1:n]));).\n- Calculate the delayed signal using the buffer and the specified shift and resolution parameters(y = shiftSample(u_buffer[n+1], shift, resolution)).\n\n//modelica\n```block FractionalDelay",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.IntegerSignals.NonPeriodic.FractionalDelay",
            "output": "within Modelica.Clocked.IntegerSignals.NonPeriodic;\nblock FractionalDelay\n  \"Delay the clocked input signal for a fractional multiple of the sample period\"\nextends Clocked.IntegerSignals.Interfaces.PartialClockedSISO;\n  parameter Integer shift(min=0) = 0\n \"Delay = interval() * shift/resolution\";\n  parameter Integer resolution(min=1) = 1\n \"Time quantization resolution of sample interval\";\nprotected\n  parameter Integer n = div(shift,resolution);\n  Integer u_buffer[n+1](each start=0)\n \"The previous values of the inputs; u_last[1] = u, u_last[2] = previous(u_last[1]); u_last[3] = previous(u_last[2])\";\n  Boolean first(start=true) \"Used to identify the first clock tick\";\nequation\n first = false;\n u_buffer = if previous(first) then fill(u,n+1) else cat(1, {u}, previous(u_buffer[1:n]));\n y = shiftSample(u_buffer[n+1], shift, resolution)\n  ;\nend FractionalDelay;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 39,
            "instruction": "Generate a Modelica model for a block called `AssignClockVectorized` which assign a clock signal to a vector of Real input signals and output them as a clocked Real signal vector. The model should include the following details:\n\n1. **Inputs and Outputs**:\n- `n(min=1)=1`: Size of input signal vector u (= size of output signal vector y).\n- `u[n]`: A vector of Real input signals. The size of this vector is determined by the parameter `n` (an integer with a minimum value of 1).\n- `y[n]`: A vector of Real output signals, which will have the same size as the input vector `u`. \n- `clock`: A clock input signal that triggers the assignment of the input vector `u` to the output vector `y`.\n\n2. **Inheritance and Interfaces**: The block should include standard Modelica interfaces for Real input (`Modelica.Blocks.Interfaces.RealInput`) and Real output (`Modelica.Blocks.Interfaces.RealOutput`). The block should also include a clock input interface (`Modelica.Clocked.ClockSignals.Interfaces.ClockInput`). \n\nThe equation should update the output `y` with the input `u` whenever the clock signal triggers.\n\n//modelica\n```block AssignClockVectorized",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.RealSignals.Sampler.AssignClockVectorized",
            "output": "within Modelica.Clocked.RealSignals.Sampler;\nblock AssignClockVectorized\n  \"Assign a clock to a clocked Real signal vector\"\n  parameter Integer n(min=1)=1\n \"Size of input signal vector u (= size of output signal vector y)\";\n  Modelica.Blocks.Interfaces.RealInput u[n]\n \"Connector of clocked, Real input signal\"\n ;\n  Modelica.Blocks.Interfaces.RealOutput y[n]\n \"Connector of clocked, Real output signal\"\n ;\n   Clocked.ClockSignals.Interfaces.ClockInput clock ;\nequation\n  when clock then\n y = u;\n  end when\n  ;\nend AssignClockVectorized;\n",
            "type": "block",
            "feature": "instantiation"
        },
        {
            "id": 40,
            "instruction": "Generate a Modelica block named `TransferFunction` that implements a discrete-time transfer function within a clocked system.\nThe purpose of this block is to represent the relationship between an input signal `u` and an output signal `y` in the z-domain for discrete systems.\nThe model should extend `Modelica.Clocked.RealSignals.Interfaces.PartialClockedSISO`.\n\n# Inputs:\n- 'b' (Real parameter array, default value: `{1}`): Represents the numerator coefficients of the transfer function. The size of the array `b` determines the order of the numerator.\n- 'a' (Real parameter array): Represents the denominator coefficients of the transfer function. The size of the array `a` determines the order of the denominator.\n\n# Outputs:\n- 'x' (Real output array): A state vector representing the internal states of the system in controller canonical form. The size of `x` is `size(a, 1) - 1` and it is initialized with a starting value of `0.0`.\n\n# Protected Variables:\n- parameter 'nb=size(b, 1)', Integer, Size of Numerator of transfer function.\n- parameter 'na=size(a, 1)', Integer, Size of Denominator of transfer function.\n- 'x1' (Real): An intermediate variable used to calculate the current state.\n- 'xext' (Real array): An extended state vector that includes the current and previous states, with the size `size(a, 1)`.\n\n# Equations:\n- The state variables `x1` are updated at each clock tick based on the input signal `u` and the previous states, normalized by the first coefficient of the denominator `a[1]`(x1 = (u - a[2:size(a, 1)]*previous(x))/a[1]).\n- The output `y` is computed as a dot product of the numerator coefficients `b` with the extended state vector `xext`, adjusted for the difference in sizes between `a` and `b`(y = vector([zeros(na - nb, 1); b])*xext;).\n\nEnsure that the model accurately implements the transfer function and handles state updates correctly at each clock tick.\n\n//modelica\n```block TransferFunction",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.RealSignals.Periodic.TransferFunction",
            "output": "within Modelica.Clocked.RealSignals.Periodic;\nblock TransferFunction \"Discrete-time Transfer Function block\"\n  extends Clocked.RealSignals.Interfaces.PartialClockedSISO;\n  parameter Real b[:]={1} \"Numerator coefficients of transfer function.\";\n  parameter Real a[:] \"Denominator coefficients of transfer function.\";\n  output Real x[size(a, 1) - 1](each start=0.0)\n \"State vector of controller canonical form\";\nprotected\n  parameter Integer nb=size(b, 1) \"Size of Numerator of transfer function\";\n  parameter Integer na=size(a, 1)\n \"Size of Denominator of transfer function\";\n  Real x1;\n  Real xext[size(a, 1)];\nequation\n  when Clock() then\n\n x1 = (u - a[2:size(a, 1)]*previous(x))/a[1];\n xext = vector([x1; previous(x)]);\n x = xext[1:size(x, 1)];\n y = vector([zeros(na - nb, 1); b])*xext;\n  end when\n  ;\nend TransferFunction;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f"
        },
        {
            "id": 41,
            "instruction": "Generate a Modelica model for a 'Discrete-time PI controller'. The model should be named 'PI'. The functionality of this model is to implement a Proportional-Integral (PI) controller in a discrete-time system. The model should extend `Modelica.Clocked.RealSignals.Interfaces.PartialClockedSISO`.\n\n**Inputs:**\n- 'kd' (Real parameter): Represents the gain of the discrete PI controller.\n- 'Td' (Real parameter, minimum value is Modelica.Constants.small): The time constant of the discrete PI controller.\n\n**Outputs:**\n- 'x' (Real output, start value is 0): Represents the state of the discrete PI controller.\n\n**Equations:**\n- The state 'x' is updated as the sum of its previous value and the input signal 'u' divided by the time constant 'Td'.\n- The output 'y' is calculated as the product of 'kd' and the sum of the state 'x' and the input signal 'u'.\nUpdate of 'x' and 'y' at each clock tick (when Clock() then).\n\n//modelica\n```block PI",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.RealSignals.Periodic.PI",
            "output": "within Modelica.Clocked.RealSignals.Periodic;\nblock PI \"Discrete-time PI controller\"\n  extends Clocked.RealSignals.Interfaces.PartialClockedSISO;\n  parameter Real kd \"Gain of discrete PI controller\";\n  parameter Real Td(min=Modelica.Constants.small)\n \"Time constant of discrete PI controller\";\n  output Real x(start=0) \"Discrete PI state\";\nequation\n  when Clock() then\n x = previous(x) + u/Td;\n y = kd*(x + u);\n  end when\n  ;\nend PI;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 42,
            "instruction": "Generate a Modelica block named `Ramp` that generates a ramp signal based on counted clock ticks. The model should extend `Modelica.Clocked.RealSignals.Interfaces.PartialClockedSO`. The purpose of the model is to output a signal that increases linearly over time according to the specified parameters.\n\n**Model Functionality**: The `Ramp` block outputs a ramp signal starting at a given offset and increases linearly until it reaches a specified height. The ramp starts after a defined number of clock ticks (startTick) and continues to increase for a specified duration (durationTicks). After the ramp reaches the specified height, the output signal remains constant.\n\n**Inputs and Outputs**:\n- **Input Parameters**:\n- `Real height = 1`: The height of the ramp signal (unitless).\n- `Integer durationTicks(min=1) = 1`: The duration of the ramp in terms of the number of clock ticks.\n- `Real offset = 0`: The offset value of the output signal before the ramp starts (unitless).\n- `Integer startTick(min=1) = 1`: The clock tick at which the output starts ramping.\n\n- **Protected Variables**:\n- `Integer counter(start=0)`: A counter that tracks the number of clock ticks.\n\n- **Output**:\n- `Real y`: The output signal that starts at the offset value and ramps up to the specified height.\n\n**Equations**:\n- 'counter', which tracks the number of clock ticks. The counter increments by one each tick until it reaches the total of 'startTick + durationTicks'. Once this limit is reached, the counter stops incrementing and holds its value.\n- 'y', if the counter is below startTick, y remains at the initial offset value, indicating the ramp has not started yet. If the counter is between 'startTick' and 'startTick + durationTicks', 'y' equals to 'offset + (counter - startTick)*height/durationTicksincreases', based on how many ticks have passed since 'startTick'. Once the counter exceeds 'startTick + durationTicks', the output 'y' remains constant at 'offset + height', signifying that the ramp has reached its full height and maintains this level.\n\n//modelica\n```block Ramp",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Clocked.RealSignals.TickBasedSources.Ramp",
            "output": "within Modelica.Clocked.RealSignals.TickBasedSources;\nblock Ramp \"Generate ramp signal based on counted clock ticks\"\n  extends Interfaces.PartialClockedSO;\n  parameter Real height=1 \"Height of ramps\";\n  parameter Integer durationTicks(min=1) = 1\n\"Durations of ramp in number of clock ticks\";\n  parameter Real offset=0 \"Offset of output signal\";\n  parameter Integer startTick(min=1) = 1\n\"Output y = offset for clock tick < startTick\";\nprotected\n  Integer counter(start=0);\nequation\n  \n  counter = if previous(counter) < startTick+durationTicks then previous(counter) + 1 else previous(counter);\n  y = offset + (if counter < startTick then 0 else if counter < (startTick +\n durationTicks) then (counter - startTick)*height/durationTicks else height)\n  ;\nend Ramp;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 43,
            "instruction": "Generate a Modelica block named 'Add' that outputs the sum of two complex input signals.\n\n# Model Functionality:\n- The block computes the sum of two complex input signals, each multiplied by a respective gain factor (k1 and k2). \n- The parameters 'k1' and 'k2' are complex parameters with default values of Complex(1, 0).\n\n# Inputs and Outputs:\n- **Inputs**:\n- `u1Internal`: Complex input signal 1. \n- `u2Internal`: Complex input signal 2. \n- **Outputs**:\n- `y`: Complex output signal, representing the sum of the two weighted inputs. \n\n# Inheritance and Interfaces:\n- The block extends from `Modelica.ComplexBlocks.Interfaces.ComplexSI2SO`, which indicates that it follows a single input, single output interface with complex signal types. \n\nEnsure the model adheres to the specified input-output relationships and complex arithmetic operations.\n\n//modelica\n```block Add",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.ComplexBlocks.ComplexMath.Add",
            "output": "within Modelica.ComplexBlocks.ComplexMath;\nblock Add \"Output the sum of the two inputs\"\n  extends Interfaces.ComplexSI2SO;\n  parameter Complex k1=Complex(1, 0) \"Gain of input 1\";\n  parameter Complex k2=Complex(1, 0) \"Gain of input 2\";\nequation\n  y = k1*u1Internal + k2*u2Internal\n  ;\nend Add;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Add completed successfully.\nClass Add has 6 equation(s) and 6 variable(s).\n0 of these are trivial equation(s)."
        },
        {
            "id": 44,
            "instruction": "Generate a Modelica model that outputs the hyperbolic tangent of a complex input signal. The model should extend the `Modelica.ComplexBlocks.Interfaces.ComplexSISO` interface. The input is a complex number 'uInternal', and the output 'y' should be the hyperbolic tangent of this input. The model should be named `Tanh`. Use the `Modelica.ComplexMath.tanh` function to calculate the output.\n\n//modelica\n```block Tanh",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.ComplexBlocks.ComplexMath.Tanh",
            "output": "within Modelica.ComplexBlocks.ComplexMath;\nblock Tanh \"Output the hyperbolic tangent of the input\"\n  extends Interfaces.ComplexSISO;\nequation\n  y = Modelica.ComplexMath.tanh(uInternal)\n  ;\nend Tanh;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Tanh completed successfully.\nClass Tanh has 4 equation(s) and 4 variable(s).\n0 of these are trivial equation(s)."
        },
        {
            "id": 45,
            "instruction": "Generate a Modelica block named `ExtractSignal` that extracts specific signals from an input signal vector. The model should inherit from `Modelica.ComplexBlocks.Interfaces.ComplexMIMO`, indicating that it handles multiple input and output signals in a complex multi-input multi-output system.  The key parameter is `extract`, which is an integer array with a size of `nout`, specifying the indices of the input vector to be extracted and sent to the output. The model should iterate over the range of output signals (`nout`) and assign each input `u[extract[i]]` to the corresponding output `y[i]`. Ensure accurate handling of the parameterization and iteration to correctly map input signals to outputs.\n\n//modelica\n```block ExtractSignal",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.ComplexBlocks.Routing.ExtractSignal",
            "output": "within Modelica.ComplexBlocks.Routing;\nblock ExtractSignal \"Extract signals from an input signal vector\"\n  extends Modelica.ComplexBlocks.Interfaces.ComplexMIMO;\n  parameter Integer extract[nout]=1:nout \"Extracting vector\";\nequation\n  for i in 1:nout loop\n y[i] = u[extract[i]];\n  end for\n  ;\nend ExtractSignal;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of ExtractSignal completed successfully.\nClass ExtractSignal has 4 equation(s) and 4 variable(s).\n2 of these are trivial equation(s)."
        },
        {
            "id": 46,
            "instruction": "Generate a Modelica block named `ComplexToReal`, which converts a complex input signal into its Cartesian components (real and imaginary parts). The model should extend from `Modelica.ComplexBlocks.Icons.ComplexBlock`. The model should include the following: 1. **Functionality**: The model takes a complex input and outputs its real and imaginary components. It should also handle the option to process the conjugate of the input. 2. **Inputs and Outputs**: The model should have one complex input `u` of type `Modelica.ComplexBlocks.Interfaces.ComplexInput`, and two real outputs `re` and `im` of type `Modelica.Blocks.Interfaces.RealOutput`. 3. **Parameters**: Include a Boolean parameter `useConjugateInput` with a default value of `false`, which determines if the input should be treated as its conjugate. 4. **Equations**: The real part 're' of the input 'u' should be assigned to `re`, and the imaginary part 'im' to `im`. If `useConjugateInput` is `true`, negate the imaginary part before assigning it to `im`.\n\n//modelica\n```block ComplexToReal",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.ComplexBlocks.ComplexMath.ComplexToReal",
            "output": "within Modelica.ComplexBlocks.ComplexMath;\nblock ComplexToReal \"Converts complex to Cartesian representation\"\n  extends Modelica.ComplexBlocks.Icons.ComplexBlock;\n  Blocks.Interfaces.RealOutput re ;\n  Blocks.Interfaces.RealOutput im ;\n  Interfaces.ComplexInput u\n ;\n  parameter Boolean useConjugateInput=false\n \"If true, input is processed conjugate complex\";\nequation\n  re = u.re;\n  im = (if useConjugateInput then -u.im else u.im)\n  ;\nend ComplexToReal;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of ComplexToReal completed successfully.\nClass ComplexToReal has 2 equation(s) and 2 variable(s).\n2 of these are trivial equation(s)."
        },
        {
            "id": 47,
            "instruction": "Generate a Modelica model for a 'Linear current-controlled current source' component named 'CCC'. The model should extend the 'Modelica.Electrical.Analog.Interfaces.TwoPort' interface, which typically includes two electrical ports. There is a parameter 'gain' should be a Real type with a start value of 1.0, representing the current gain. The main functionality of the model is to control the output current 'i2' based on the input current 'i1' with a linear relationship governed by the 'gain' parameter. Specifically, the equation should be 'i2 = i1 * gain'. Additionally, the model should enforce that the voltage 'v1' at the input port is set to zero.\n\n//modelica\n```model CCC",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Basic.CCC",
            "output": "within Modelica.Electrical.Analog.Basic;\nmodel CCC \"Linear current-controlled current source\"\n  extends Interfaces.TwoPort;\n  parameter Real gain(start=1) \"Current gain\";\nequation\n  i2 = i1*gain;\n  v1 = 0\n  ;\nend CCC;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of CCC completed successfully.\nClass CCC has 12 equation(s) and 12 variable(s).\n9 of these are trivial equation(s)."
        },
        {
            "id": 48,
            "instruction": "Generate a Modelica model named `Inductor` that represents an ideal linear electrical inductor. The model should extend the 'Modelica.Electrical.Analog.Interfaces.OnePort' interface which provides a single electrical port with current and voltage. The initial value of the current 'i' in it is set to 0 in extends. The main parameter of the model is 'L', representing inductance with the SI unit 'Modelica.Units.SI.Inductance'. Ensure that the initial value of the inductance 'L' is set to 1 henry. The model should include an equation that relates the inductance to the time derivative of the current (i.e., L * di/dt = v, where 'i' is the current and 'v' is the voltage).\n\n//modelica\n```model Inductor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Basic.Inductor",
            "output": "within Modelica.Electrical.Analog.Basic;\nmodel Inductor \"Ideal linear electrical inductor\"\n  extends Interfaces.OnePort(i(start=0));\n  parameter SI.Inductance L(start=1) \"Inductance\";\nequation\n  L*der(i) = v\n  ;\nend Inductor;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Inductor completed successfully.\nClass Inductor has 6 equation(s) and 6 variable(s).\n4 of these are trivial equation(s)."
        },
        {
            "id": 49,
            "instruction": "Generate a Modelica model for an ideal linear electrical resistor with variable resistance, named `VariableResistor`. The model should extend `Modelica.Electrical.Analog.Interfaces.OnePort` and `Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort` with reset T=T_ref.\nThe model should include the following parameters: \n\n- `T_ref` (Modelica.Units.SI.Temperature): Reference temperature, default value `300.15 K`. \n- `alpha` (Modelica.Units.SI.LinearTemperatureCoefficient): Temperature coefficient of resistance, default value `0`. \n- `R` (RealInput, unit=\"Ohm\"): Variable resistance input. \n- `R_actual` (Modelica.Units.SI.Resistance).\n\nIn the equation part, ensure the model includes an assertion to check that the temperature is within a valid scope.\nThe resistor's resistance is dependent on temperature, with the actual resistance `R_actual` calculated as `R*(1 + alpha*(T_heatPort - T_ref))`, where `alpha` is the temperature coefficient of resistance and `T_ref` is the reference temperature.\nCalculates the voltage `v` and power loss `LossPower` using the relationships `v = R_actual*i` and `LossPower = v*i`.\n\n//modelica\n```model VariableResistor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Basic.VariableResistor",
            "output": "within Modelica.Electrical.Analog.Basic;\nmodel VariableResistor\n  \"Ideal linear electrical resistor with variable resistance\"\n  parameter SI.Temperature T_ref=300.15 \"Reference temperature\";\n  parameter SI.LinearTemperatureCoefficient alpha=0\n \"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref))\";\n  extends Modelica.Electrical.Analog.Interfaces.OnePort;\n  extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T=T_ref);\n  SI.Resistance R_actual\n \"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref))\";\n  Modelica.Blocks.Interfaces.RealInput R(unit=\"Ohm\") ;\nequation\n  assert((1 + alpha*(T_heatPort - T_ref)) >= Modelica.Constants.eps,\n \"Temperature outside scope of model!\");\n  R_actual = R*(1 + alpha*(T_heatPort - T_ref));\n  v = R_actual*i;\n  LossPower = v*i\n  ;\nend VariableResistor;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of VariableResistor completed successfully.\nClass VariableResistor has 9 equation(s) and 9 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 50,
            "instruction": "Generate a Modelica model for a conversion circuit named `AD_DA_conversion` that demonstrates the process of analog-to-digital (AD) and digital-to-analog (DA) signal conversion.\n\nThe model includes the following components:\n1. **aD_Converter**: 'Modelica.Electrical.Analog.Ideal.AD_Converter', converts an analog signal to a digital signal. Parameters include `N` (Integer, digital signal width, default: 7), `Rin` (Input resistance, default: 1000000 Ohm), `VRefLow` (Lower reference voltage, default: 0 V), and `VRefHigh` (Upper reference voltage, default: 10 V). \n2. **pulse**: Generates a digital pulse signal. Parameters include `pulse` equals to `Modelica.Electrical.Digital.Interfaces.Logic.'1'`, `quiet` `Modelica.Electrical.Digital.Interfaces.Logic.'0'`, `nperiod` (number of periods, -1 for infinite), `width` (pulse width, default: 1), `period` (pulse period, default: 0.001 seconds), and `startTime` (start time, default: 0 seconds).\n3. **dA_Converter**: Converts the digital signal back to an analog signal. Parameters include `N` (Integer, digital signal width, default: 7) and `Vref` (Reference voltage, default: 10 V).\n4. **sineVoltage**: Generates a sine wave voltage signal. Parameters include `V` (amplitude, default: 5 V), `f` (frequency, default: 10 Hz), and `offset` (DC offset, default: 5 V).\n5. **resistor**: Represents a resistor with resistance `R` (default: 1 Ohm).\n6. **Ground**: Provides a ground reference point for the circuit.\n\nThe model should connect these components as follows:\n- Connect the pulse output to the `trig` input of the `aD_Converter` and `dA_Converter`.\n- Connect the `p` and `n` of 'sineVoltage' to the `p` and `n` terminals of the `aD_Converter`.\n- Connect the `aD_Converter` output `y` to the `dA_Converter` input `x`.\n- Connect the `n` of `dA_Converter` and `sineVoltage` to the `p` of `ground`.\n- Connect the sineVoltage.p` to the `resistor.p`.\n- Connect the `dA_Converter.p` to the `resistor.n`.\n\n//modelica\n```model AD_DA_conversion",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.AD_DA_conversion",
            "output": "within Modelica.Electrical.Analog.Examples;\nmodel AD_DA_conversion \"Conversion circuit\"\n  extends Modelica.Icons.Example;\n  parameter Integer N=7 \"Digital signal width\";\n  Modelica.Electrical.Analog.Ideal.AD_Converter aD_Converter(N=N,\n Rin=1000000,\n VRefLow=0,\n VRefHigh=10)\n ;\n  Modelica.Electrical.Digital.Sources.Pulse pulse(\n pulse=Modelica.Electrical.Digital.Interfaces.Logic.'1',\n quiet=Modelica.Electrical.Digital.Interfaces.Logic.'0',\n nperiod=-1,\n width=1,\n period=0.001,\n startTime=0)\n ;\n  Modelica.Electrical.Analog.Ideal.DA_Converter dA_Converter(N=N, Vref=10)\n ;\n  Modelica.Electrical.Analog.Basic.Ground ground\n ;\n  Modelica.Electrical.Analog.Sources.SineVoltage sineVoltage(\n V=5,\n f=10,\n offset=5) ;\n  Modelica.Electrical.Analog.Basic.Resistor resistor(R=1)\n ;\nequation\n  connect(pulse.y, aD_Converter.trig) ;\n  connect(sineVoltage.p, aD_Converter.p) ;\n  connect(sineVoltage.n, aD_Converter.n) ;\n  connect(ground.p, sineVoltage.n) ;\n  connect(sineVoltage.p, resistor.p) ;\n  connect(dA_Converter.trig, pulse.y) ;\n  connect(aD_Converter.y, dA_Converter.x) ;\n  connect(dA_Converter.p, resistor.n) ;\n  connect(dA_Converter.n, ground.p) \n  ;\nend AD_DA_conversion;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 51,
            "instruction": "Create a Modelica model that represents an electrical resistor with a simple thermal network named `Resistor`. The model should extend from `Modelica.Icons.Example`.\nIt includes a `resistor` (`Modelica.Electrical.Analog.Basic.Resistor`) with parameters: resistance `R=100 ohms`, temperature coefficient `alpha=1e-3`, reference temperature `T_ref=293.15 K`, an initial current `i(start=0)` and `useHeatPort=true` to enable thermal effects.\nThe model also incorporates a `SineVoltage1`(Modelica.Electrical.Analog.Sources.SineVoltage) with an amplitude `V=220 V` and frequency `f=1 Hz`, a `Ground`(Modelica.Electrical.Analog.Basic.Ground), a `ThermalConductor`(Modelica.Thermal.HeatTransfer.Components.ThermalConductor) with a conductance `G=50 W/K`, and a `FixedTemperature`(Modelica.Thermal.HeatTransfer.Celsius.FixedTemperature) set to `T=20°C`.\nThe equations connect the 'SineVoltage1.n' and the 'resistor.n' to the 'G.p', link the 'SineVoltage1.p' to the 'resistor.p', link the 'resistor.heatPort' to the 'thermalConductor.port_a', and connect the 'thermalConductor.port_b' to the 'fixedTemperature.port'. Ensure accurate parameterization of the resistor's electrical and thermal properties.\n\n//modelica\n```model Resistor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.Resistor",
            "output": "within Modelica.Electrical.Analog.Examples;\nmodel Resistor \"Resistor with simple thermal network\"\n  extends Modelica.Icons.Example;\n  Basic.Resistor resistor(\n R=100,\n alpha=1e-3,\n T_ref=293.15,\n i(start=0),\n useHeatPort=true) ;\n  Modelica.Electrical.Analog.Basic.Ground G\n  ;\n  Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(V=220, f=1)\n  ;\n  Modelica.Thermal.HeatTransfer.Components.ThermalConductor thermalConductor(G=\n 50)\n  ;\n  Thermal.HeatTransfer.Celsius.FixedTemperature fixedTemperature(T=20)\n ;\nequation\n  connect(SineVoltage1.n, G.p)\n  ;\n  connect(resistor.heatPort, thermalConductor.port_a)\n ;\n  connect(SineVoltage1.p, resistor.p)\n ;\n  connect(G.p, resistor.n)\n ;\n  connect(thermalConductor.port_b, fixedTemperature.port) \n;\nend Resistor;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 52,
            "instruction": "Create a Modelica model named `ShowSaturatingInductor` that demonstrates the behavior of a SaturatingInductor component.\n\nThe model should include the following parameters:\n Inductance near zero current (Lzer) with a value of 2,'Modelica.Units.SI.Inductance';\n nominal inductance at nominal current (Lnom) with a value of 1, 'Modelica.Units.SI.Inductance';\n nominal current (Inom) with a value of 1, 'Modelica.Units.SI.Current'; and inductance at large currents (Linf) with a value of 0.5, 'Modelica.Units.SI.Inductance';\n a source voltage (U) with a peak of 1.25, 'Modelica.Units.SI.Voltage';\n a source frequency (f) calculated as '1/(2*Modelica.Constants.pi)', 'Modelica.Units.SI.Frequency';\n a phase shift (phase) equals to 'Modelica.Constants.pi/2', 'Modelica.Units.SI.Angle' for the source voltage.\n\nThe model should also include a SineVoltage source `SineVoltage1` (Modelica.Electrical.Analog.Sources.SineVoltage) with ` V=U, phase=phase, f=f)`, a Ground component `Ground1` (Modelica.Electrical.Analog.Basic.Ground), a SaturatingInductor component `SaturatingInductance1` (Modelica.Electrical.Analog.Basic.SaturatingInductor) with `Lzer=Lzer, Lnom=Lnom, Inom=Inom, Linf=Linf, i(fixed=true)`, and an Inductor component `Inductance1` (Modelica.Electrical.Analog.Basic.Inductor) with `L=Lnom, i(fixed=true)`.\n\nThe model should also include connections between the components as follows: 'SineVoltage1.n' to 'Ground1.p', 'SineVoltage1.n' to 'SaturatingInductance1.n', 'SaturatingInductance1.p' to 'SineVoltage1.p', 'Inductance1.p' to 'SineVoltage1.p', and 'Inductance1.n' to 'SineVoltage1.n'.\n\n//modelica\n```model ShowSaturatingInductor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.ShowSaturatingInductor",
            "output": "within Modelica.Electrical.Analog.Examples;\nmodel ShowSaturatingInductor\n  \"Simple demo to show behaviour of SaturatingInductor component\"\n  extends Modelica.Icons.Example;\n  parameter SI.Inductance Lzer=2 \"Inductance near current=0\";\n  parameter SI.Inductance Lnom=1\n \"Nominal inductance at Nominal current\";\n  parameter SI.Current Inom=1 \"Nominal current\";\n  parameter SI.Inductance Linf=0.5 \"Inductance at large currents\";\n  parameter SI.Voltage U=1.25 \"Source voltage (peak)\";\n  parameter SI.Frequency f=1/(2*Modelica.Constants.pi)\n \"Source frequency\";\n  parameter SI.Angle phase=Modelica.Constants.pi/2\n \"Source voltage phase shift\";\n  \n  \n  Modelica.Electrical.Analog.Sources.SineVoltage SineVoltage1(\n V=U,\n phase=phase,\n f=f)\n ;\n  Modelica.Electrical.Analog.Basic.Ground Ground1\n ;\n  Modelica.Electrical.Analog.Basic.SaturatingInductor SaturatingInductance1(\n Lzer=Lzer,\n Lnom=Lnom,\n Inom=Inom,\n Linf=Linf,\n i(fixed=true))\n ;\n  Basic.Inductor Inductance1(L=Lnom, i(fixed=true)) ;\nequation\n  \n  \n  connect(SineVoltage1.n, Ground1.p) ;\n  connect(SineVoltage1.n, SaturatingInductance1.n) ;\n  connect(SaturatingInductance1.p, SineVoltage1.p) ;\n  connect(Inductance1.p, SineVoltage1.p) ;\n  connect(Inductance1.n, SineVoltage1.n) \n  ;\nend ShowSaturatingInductor;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 53,
            "instruction": "Generate a Modelica model named `HighPass` for a High-pass filter. The model should filter out low-frequency components from an input voltage signal. The input signal is a trapezoidal waveform defined by parameters such as amplitude, frequency, and timing characteristics.\n\nThe model includes the following parameters: `Vin` (Modelica.Units.SI.Voltage, 5 V), `f` (Modelica.Units.SI.Frequency, 10 Hz), and a limiting frequency `fG` set to `f/10`.\n\nThe model includes the following components: `ground` (`Modelica.Electrical.Analog.Basic.Ground`), a voltage sensor `vOut` (`Modelica.Electrical.Analog.Sensors.VoltageSensor`), `derivative` (Modelica.Electrical.Analog.Examples.OpAmps.OpAmpCircuits.Derivative) with parameters `T=1/(2*pi*fG), v(fixed=true)`, `vIn` (Modelica.Electrical.Analog.Sources.TrapezoidVoltage) with parameters `V=Vin, rising=0.2/f, width=0.3/f, falling=0.2/f, period=1/f, nperiod=-1, offset=0, startTime=-(vIn.rising + vIn.width/2)`.\n\nThe model should also include connections between the components as follows: 'derivative.n1' to 'ground.p' and 'vIn.n', 'derivative.p2' to 'vOut.p', 'derivative.n2' to 'vOut.n', and 'vIn.p' to 'derivative.p1'.\n\n//modelica\n```model HighPass",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.OpAmps.HighPass",
            "output": "within Modelica.Electrical.Analog.Examples.OpAmps;\nmodel HighPass \"High-pass filter\"\n  extends Modelica.Icons.Example;\n  import Modelica.Constants.pi;\n  parameter SI.Voltage Vin=5 \"Amplitude of input voltage\";\n  parameter SI.Frequency f=10 \"Frequency of input voltage\";\n  parameter SI.Frequency fG=f/10 \"Limiting frequency\";\n  Modelica.Electrical.Analog.Basic.Ground ground\n ;\n  Modelica.Electrical.Analog.Sensors.VoltageSensor vOut ;\n  OpAmpCircuits.Derivative derivative(T=1/(2*pi*fG),\n v(fixed=true))\n ;\n  Sources.TrapezoidVoltage vIn(\n V=Vin,\n rising=0.2/f,\n width=0.3/f,\n falling=0.2/f,\n period=1/f,\n nperiod=-1,\n offset=0,\n startTime=-(vIn.rising + vIn.width/2))\n ;\nequation\n  connect(derivative.n1, ground.p)\n ;\n  connect(derivative.p2, vOut.p)\n ;\n  connect(derivative.n2, vOut.n)\n ;\n  connect(vIn.p, derivative.p1)\n ;\n  connect(vIn.n, derivative.n1)\n\n  ;\nend HighPass;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 54,
            "instruction": "Generate a Modelica model named `Subtracter` that represents an inverting subtracter circuit.\nThis model is part of the `Modelica.Electrical.Analog.Examples.OpAmps` package and extends the `Modelica.Icons.Example`.\nThe model should have the following parameters:\n- `Vin` (Modelica.Units.SI.Voltage, default value: 5) representing the amplitude of the input voltage\n- `f` (Modelica.Units.SI.Frequency, default value: 10) representing the frequency of the input voltage.\n\nThe model should include the following components:\n- `ground` (Modelica.Electrical.Analog.Basic.Ground) to represent the ground connection.\n- `vIn1` (Modelica.Electrical.Analog.Sources.SineVoltage) to generate a sinusoidal input voltage with parameters `V = Vin` and `f = f`.\n- `vIn2` (Modelica.Electrical.Analog.Sources.ConstantVoltage) to generate a constant input voltage with parameter `V = Vin`.\n- `vOut` (Modelica.Electrical.Analog.Sensors.VoltageSensor) to measure the output voltage.\n- `feedback` (Modelica.Electrical.Analog.Examples.OpAmps.OpAmpCircuits.Feedback) to implement the feedback loop, with the initial current `i` of `p1_2` set to 0.\n\nThe following connections should be made:\n- Connect `feedback.n1` to `ground.p`.\n- Connect `vIn1.p` to `feedback.p1`.\n- Connect `vIn2.p` to `feedback.p1_2`.\n- Connect `ground.p` to `vIn2.n` and `vIn1.n`.\n- Connect `feedback.p2` to `vOut.n`.\n- Connect `feedback.n2` to `vOut.p`.\n\nThe model should accurately represent the behavior of an inverting subtracter circuit.\n\n//modelica\n```model Subtracter",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.OpAmps.Subtracter",
            "output": "within Modelica.Electrical.Analog.Examples.OpAmps;\nmodel Subtracter \"Inverting subtracter\"\n  extends Modelica.Icons.Example;\n  parameter SI.Voltage Vin=5 \"Amplitude of input voltage\";\n  parameter SI.Frequency f=10 \"Frequency of input voltage\";\n  Modelica.Electrical.Analog.Basic.Ground ground\n ;\n  Sources.SineVoltage vIn1(V=Vin, f=f) ;\n  Sources.ConstantVoltage vIn2(V=Vin) ;\n  Modelica.Electrical.Analog.Sensors.VoltageSensor vOut ;\n  OpAmpCircuits.Feedback feedback(p1_2(i(start=0)))\n ;\nequation\n  connect(feedback.n1, ground.p)\n ;\n  connect(vIn1.p, feedback.p1)\n ;\n  connect(vIn2.p, feedback.p1_2)\n ;\n  connect(ground.p, vIn2.n)\n ;\n  connect(ground.p, vIn1.n)\n ;\n  connect(feedback.p2, vOut.n)\n ;\n  connect(feedback.n2, vOut.p)\n\n  ;\nend Subtracter;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 55,
            "instruction": "Generate a Modelica model for an inverting operational amplifier circuit named `Gain`. The model should inherit from a `Modelica.Electrical.Analog.Examples.OpAmps.OpAmpCircuits.PartialOpAmp` base class. The purpose of the model is to simulate an inverting amplifier with a user-defined gain. \n\n**Inputs and Parameters:**\n- `k` (Real, minimum value 0, default = 1): This parameter defines the desired amplification factor.\n- `R1` (Modelica.Units.SI.Resistance, default = 1000 ohms): The resistance connected to the negative input of the operational amplifier.\n- `R2` (Modelica.Units.SI.Resistance, calculated as `k * R1`): The resistance required to achieve the desired amplification `k`.\n\n**Components:**\n- Two resistors of type `Modelica.Electrical.Analog.Basic.Resistor` (`r1` and `r2`) should be included, with `r1` having a resistance `final R=R1` and `r2` having a resistance `final R=R2`.\n\n**Connections:**\n- The output of the operational amplifier (`opAmp.out`) should be connected to the `r2.p` and to an output pin (`p2`).\n- The `r1.n` should be connected to the negative input of the operational amplifier (`opAmp.in_n`) and the `r2.n`.\n- The `r1.p` should be connected to an input pin (`p1`).\n- The positive input of the operational amplifier (`opAmp.in_p`) should be connected to another input pin (`n1`), and `n1` should be connected to `n2`.\n\nThe model should include accurate connections and parameterizations to represent the inverting operational amplifier circuit correctly.\n\n//modelica\n```model Gain",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.OpAmps.OpAmpCircuits.Gain",
            "output": "within Modelica.Electrical.Analog.Examples.OpAmps.OpAmpCircuits;\nmodel Gain \"Inverting operational amplifier circuit\"\n  extends PartialOpAmp;\n  parameter Real k(final min=0)=1 \"Desired amplification\";\n  parameter SI.Resistance R1=1000 \"Resistance at negative input of OpAmp\";\n  parameter SI.Resistance R2=k*R1 \"Calculated resistance to reach desired amplification k\";\n  Basic.Resistor r1(final R=R1)\n ;\n  Basic.Resistor r2(final R=R2)\n ;\nequation\n  connect(opAmp.out, r2.p)\n ;\n  connect(opAmp.out, p2) ;\n  connect(r1.n, opAmp.in_n)\n ;\n  connect(r1.n, r2.n)\n ;\n  connect(r1.p, p1) ;\n  connect(n1, opAmp.in_p) ;\n  connect(n1, n2)\n\n  ;\nend Gain;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of Gain completed successfully.\nClass Gain has 45 equation(s) and 45 variable(s).\n26 of these are trivial equation(s)."
        },
        {
            "id": 56,
            "instruction": "Generate a Modelica model representing an ideal switch with resistance named `RealSwitch`. The model should include the following components:\n1. `Modelica.Electrical.Analog.Ideal.ControlledIdealTwoWaySwitch S` with the parameter `level=2.5` to define the ideal two-way switch with a control level.\n2. `Modelica.Electrical.Analog.Basic.Resistor R` with a resistance value `R=0.01` to represent the resistor in series with the switch.\n3. `Modelica.Electrical.Analog.Interfaces.Pin` named `p`, `n1`, `n2`, and `control` to define the electrical pins for the circuit connections, including the control pin for the switch.\n\nIn the equation section, define the connections as follows:\n- Connect pin `p` to the positive pin of the resistor (`R.p`).\n- Connect the negative pin of the resistor (`R.n`) to the positive pin of the switch (`S.p`).\n- Connect pin `n1` to the first output pin of the switch (`S.n1`).\n- Connect pin `n2` to the second output pin of the switch (`S.n2`).\n- Connect the control pin (`control`) to the control input of the switch (`S.control`).\n\n//modelica\n```model RealSwitch",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Examples.Utilities.RealSwitch",
            "output": "within Modelica.Electrical.Analog.Examples.Utilities;\nmodel RealSwitch \"Ideal switch with resistance\"\n  Ideal.ControlledIdealTwoWaySwitch S(level=2.5) ;\n  Basic.Resistor R(R=0.01) ;\n  Interfaces.Pin p ;\n  Interfaces.Pin n1 ;\n  Interfaces.Pin n2 ;\n  Interfaces.Pin control ;\nequation\n  connect(p, R.p) ;\n  connect(R.n, S.p) ;\n  connect(n1, S.n1) ;\n  connect(n2, S.n2) ;\n  connect(control, S.control) \n  ;\nend RealSwitch;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of RealSwitch completed successfully.\nClass RealSwitch has 29 equation(s) and 29 variable(s).\n19 of these are trivial equation(s)."
        },
        {
            "id": 57,
            "instruction": "Generate a Modelica model for a controlled ideal electrical opening switch named `ControlledIdealOpeningSwitch`. The model should extend `Modelica.Electrical.Analog.Interfaces.IdealSwitch` and include the following components:\n1.A parameter `Modelica.Units.SI.Voltage level=0.5` to define the voltage threshold for the switch to open.\n2.`Modelica.Electrical.Analog.Interfaces.Pin control` to define the control pin, where the switch opens if the control voltage `control.v` exceeds the threshold level. If not, the switch connects pins `p` and `n`.\n\nIn the equation section, define the following behavior:\n- The switch is open (`off=true`) when `control.v > level`.\n- Set the control current `control.i = 0` to ensure no current flows through the control pin.\n\n//modelica\n```model ControlledIdealOpeningSwitch",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Ideal.ControlledIdealOpeningSwitch",
            "output": "within Modelica.Electrical.Analog.Ideal;\nmodel ControlledIdealOpeningSwitch \"Controlled ideal electrical opener\"\n  parameter SI.Voltage level=0.5 \"Switch level\";\n  extends Modelica.Electrical.Analog.Interfaces.IdealSwitch;\n  Modelica.Electrical.Analog.Interfaces.Pin control\n \"Control pin: control.v > level switch open, otherwise p--n connected\"\n ;\nequation\n  off = control.v > level;\n  control.i = 0\n  ;\nend ControlledIdealOpeningSwitch;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of ControlledIdealOpeningSwitch completed successfully.\nClass ControlledIdealOpeningSwitch has 12 equation(s) and 12 variable(s).\n7 of these are trivial equation(s)."
        },
        {
            "id": 58,
            "instruction": "Generate a Modelica model for an ideal GTO thyristor named `IdealGTOThyristor`. The model should extend `Modelica.Electrical.Analog.Interfaces.IdealSemiconductor` and include the following components:\n1. `Modelica.Blocks.Interfaces.BooleanInput fire` to define the Boolean input for firing the thyristor.\n\nIn the equation section, define the following behavior:\n- The thyristor is off (`off=true`) when the semiconductor state variable `s` is less than 0 or when the `fire` signal is false (`not fire`).\n\nProvide the necessary equations to represent the functionality of the ideal GTO thyristor, where the thyristor's state is controlled by the semiconductor's condition and the `fire` signal.\n\n//modelica\n```model IdealGTOThyristor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Ideal.IdealGTOThyristor",
            "output": "within Modelica.Electrical.Analog.Ideal;\nmodel IdealGTOThyristor \"Ideal GTO thyristor\"\n  extends Modelica.Electrical.Analog.Interfaces.IdealSemiconductor;\n  Modelica.Blocks.Interfaces.BooleanInput fire ;\nequation\n  off = s < 0 or not fire\n  ;\nend IdealGTOThyristor;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of IdealGTOThyristor completed successfully.\nClass IdealGTOThyristor has 10 equation(s) and 10 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 59,
            "instruction": "Generate a Modelica model named `IdealOpAmp3Pin` for an ideal operational amplifier (norator-nullator pair) with 3 pins. The model should extend `Modelica.Electrical.Analog.Ideal.IdealOpAmp3Pin` and include the following components:\n1. `Modelica.Electrical.Analog.Interfaces.PositivePin in_p` as the positive input pin.\n2. `Modelica.Electrical.Analog.Interfaces.NegativePin in_n` as the negative input pin.\n3. `Modelica.Electrical.Analog.Interfaces.PositivePin out` as the output pin.\n\nIn the equation section, define the following behavior:\n- The voltage at the positive input pin `in_p.v` should be equal to the voltage at the negative input pin `in_n.v`.\n- The current at both the positive input pin `in_p.i` and the negative input pin `in_n.i` should be zero.\n\nProvide the necessary equations to represent the ideal operational amplifier's behavior, with balanced input voltages and zero input currents.\n\n//modelica\n```model IdealOpAmp3Pin",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Ideal.IdealOpAmp3Pin",
            "output": "within Modelica.Electrical.Analog.Ideal;\nmodel IdealOpAmp3Pin\n  \"Ideal operational amplifier (norator-nullator pair), but 3 pins\"\n  Interfaces.PositivePin in_p \"Positive pin of the input port\" ;\n  Interfaces.NegativePin in_n \"Negative pin of the input port\" ;\n  Interfaces.PositivePin out \"Output pin\" ;\nequation\n  in_p.v = in_n.v;\n  in_p.i = 0;\n  in_n.i = 0\n  ;\nend IdealOpAmp3Pin;\n",
            "type": "model",
            "feature": "instantiation",
            "ref": "f",
            "check_result": "Check of IdealOpAmp3Pin completed successfully.\nClass IdealOpAmp3Pin has 6 equation(s) and 6 variable(s).\n6 of these are trivial equation(s)."
        },
        {
            "id": 60,
            "instruction": "Generate a Modelica model named `ZDiode` that represents a Zener diode with three working areas. The model extends `Modelica.Electrical.Analog.Interfaces.OnePort`. It also extends `Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort` with a default temperature value of 293.15 K. The model should include the following components and details:\n1. Model Functionality: The model represents a Zener diode, which operates in three distinct regions: forward bias, reverse bias, and breakdown (Zener) region.\n2. Parameters:\n- Modelica.Units.SI.Current Ids=1e-6 `Saturation current`\n- Modelica.Units.SI.Voltage Vt=0.04 `Voltage equivalent of temperature (kT/qn)`\n- Real Maxexp(final min=Modelica.Constants.small) = 30\n- Modelica.Units.SI.Resistance R=1e8\n- Modelica.Units.SI.Voltage Bv=5.1\n- Modelica.Units.SI.Current Ibv=0.7\n- Real Nbv=0.74 \n- Real T=293.15\n3. Equations and Expressions:\n The current through the diode i is defined by a piecewise function based on the voltage v:\ni = smooth(1, if (v > Maxexp * Vt) then\nIds * (exp(Maxexp) * (1 + v / Vt - Maxexp) - 1) + v / R\nelse if ((v + Bv) < -Maxexp * (Nbv * Vt)) then\n-Ids - Ibv * exp(Maxexp) * (1 - (v + Bv) / (Nbv * Vt) - Maxexp) + v / R\nelse\nIds * (exp(v / Vt) - 1) - Ibv * exp(-(v + Bv) / (Nbv * Vt)) + v / R);\nThe power loss LossPower is defined as: `LossPower = v * i;`\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model ZDiode",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Semiconductors.ZDiode",
            "output": "within Modelica.Electrical.Analog.Semiconductors;\nmodel ZDiode \"Zener diode with 3 working areas\"\n  extends Modelica.Electrical.Analog.Interfaces.OnePort;\n  parameter SI.Current Ids=1e-6 \"Saturation current\";\n  parameter SI.Voltage Vt=0.04 \"Voltage equivalent of temperature (kT/qn)\";\n  parameter Real Maxexp(final min=Modelica.Constants.small) = 30\n \"Max. exponent for linear continuation\";\n  parameter SI.Resistance R=1e8 \"Parallel ohmic resistance\";\n  parameter SI.Voltage Bv=5.1 \"Breakthrough voltage = Zener- or Z-voltage\";\n  parameter SI.Current Ibv=0.7 \"Breakthrough knee current\";\n  parameter Real Nbv=0.74 \"Breakthrough emission coefficient\";\n  extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T=293.15);\nequation\n  i = smooth(1, if (v>Maxexp*Vt) then\n Ids*( exp(Maxexp)*(1 + v/Vt - Maxexp)-1) + v/R else\n if ( (v+Bv)<-Maxexp*(Nbv*Vt)) then\n -Ids -Ibv* exp(Maxexp)*(1 - (v+Bv)/(Nbv*Vt) - Maxexp) +v/R else\n Ids*(exp(v/Vt)-1) - Ibv*exp(-(v+Bv)/(Nbv*Vt)) + v/R);\n  LossPower = v*i\n ;\nend ZDiode;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of ZDiode completed successfully.\nClass ZDiode has 8 equation(s) and 8 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 61,
            "instruction": "Generate a Modelica model named `ConstantCurrent` that represents a source for constant current. The model should include the following components and details:\n1. Model Functionality: The model represents a constant current source, providing a fixed current regardless of the voltage across its terminals.\n2. Parameters:\n  - Value of constant current: Modelica.Units.SI.Current I(start=1)\n3. Equations and Expressions:\n   The current i through the source is defined as:\n   i = I;\n4. Inheritance and Interfaces:\n  - The model extends Modelica.Electrical.Analog.Interfaces.OnePort.\n  - It also extends Modelica.Electrical.Analog.Icons.CurrentSource.\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model ConstantCurrent",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Sources.ConstantCurrent",
            "output": "within Modelica.Electrical.Analog.Sources;\nmodel ConstantCurrent \"Source for constant current\"\n  parameter SI.Current I(start=1) \"Value of constant current\";\n  extends Interfaces.OnePort;\n  extends Modelica.Electrical.Analog.Icons.CurrentSource;\nequation\n  i = I\n  ;\nend ConstantCurrent;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of ConstantCurrent completed successfully.\nClass ConstantCurrent has 6 equation(s) and 6 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 62,
            "instruction": "Generate a Modelica model named `SawToothCurrent` that represents a saw tooth current source, which generates a current with a saw tooth waveform. \n The model should include the following components and details:\n1.Parameters:\n- Amplitude of saw tooth: Modelica.Units.SI.Current I(start=1)\n-Time for one period: Modelica.Units.SI.Time period(start=1)\n2.Inheritance and Interfaces:\n- The model extends `Modelica.Electrical.Analog.Interfaces.CurrentSource`, redeclaring 'Modelica.Blocks.Sources.SawTooth' as signalSource with the following final parameters:\n-final amplitude = I\n-final period = period.\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model SawToothCurrent",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Sources.SawToothCurrent",
            "output": "within Modelica.Electrical.Analog.Sources;\nmodel SawToothCurrent \"Saw tooth current source\"\n  parameter SI.Current I(start=1) \"Amplitude of saw tooth\";\n  parameter SI.Time period(start=1) \"Time for one period\";\n  extends Interfaces.CurrentSource(redeclare Modelica.Blocks.Sources.SawTooth\n signalSource(final amplitude=I, final period=period))\n  ;\nend SawToothCurrent;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of SawToothCurrent completed successfully.\nClass SawToothCurrent has 9 equation(s) and 9 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 63,
            "instruction": "Generate a Modelica model named `SignalVoltage` that represents a generic voltage source using an input signal as the source voltage. The model extends `Modelica.Electrical.Analog.Icons.VoltageSource`. \n\nThe model should include the following components and details:\n1. Components:\n - `Modelica.Electrical.Analog.Interfaces.PositivePin p`\n - `Modelica.Electrical.Analog.Interfaces.NegativePin n`\n - `Modelica.Blocks.Interfaces.RealInput v` is Voltage between pin p and n (= p.v - n.v) as input signal\n - `Modelica.Units.SI.Current i` is Current flowing from pin p to pin n\n2. Equations and Expressions:\n The model should include the following equations:\n v = p.v - n.v;\n 0 = p.i + n.i;\n i = p.i;\n\n - Please ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model SignalVoltage",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Analog.Sources.SignalVoltage",
            "output": "within Modelica.Electrical.Analog.Sources;\nmodel SignalVoltage\n  \"Generic voltage source using the input signal as source voltage\"\n  extends Modelica.Electrical.Analog.Icons.VoltageSource;\n  Interfaces.PositivePin p ;\n  Interfaces.NegativePin n ;\n  Modelica.Blocks.Interfaces.RealInput v(unit=\"V\")\n \"Voltage between pin p and n (= p.v - n.v) as input signal\" ;\n  SI.Current i \"Current flowing from pin p to pin n\";\nequation\n  v = p.v - n.v;\n  0 = p.i + n.i;\n  i = p.i\n  ;\nend SignalVoltage;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of SignalVoltage completed successfully.\nClass SignalVoltage has 5 equation(s) and 5 variable(s).\n4 of these are trivial equation(s)."
        },
        {
            "id": 64,
            "instruction": "Generate a Modelica model named `CellStack` that represents a battery with open-circuit voltage dependent on state of charge, self-discharge, and inner resistance. The model should include the following components and details:\n1.Components:\n- The model should extend `Modelica.Electrical.Batteries.BaseClasses.BaseCellStack` with the following modifications:\n- The parameter 'r0' should be set with a final value of 'R' equal to 'Ns*cellData.Ri/Np'.\n- The 'cellData' parameter should be redeclared as 'Modelica.Electrical.Batteries.ParameterRecords.CellData'.\n2.Connections:\n The model should include the following connection:\n- connect(r0.n, n)\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model CellStack",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Batteries.BatteryStacks.CellStack",
            "output": "within Modelica.Electrical.Batteries.BatteryStacks;\nmodel CellStack\n  \"Battery with open-circuit voltage dependent on state of charge, self-discharge and inner resistance\"\n  extends Modelica.Electrical.Batteries.BaseClasses.BaseCellStack(r0(final R=Ns*cellData.Ri/Np),\n redeclare Modelica.Electrical.Batteries.ParameterRecords.CellData cellData);\nequation\n  connect(r0.n, n)\n\n  ;\nend CellStack;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of CellStack completed successfully.\nClass CellStack has 53 equation(s) and 53 variable(s).\n36 of these are trivial equation(s)."
        },
        {
            "id": 65,
            "instruction": "Generate a Modelica model named `StackRC` that represents a stack with sensors. The model should include the following components and details:\n1. Model Functionality: The model represents a battery stack with integrated sensors.\n2. Components:\n- The model should extend `Modelica.Electrical.Batteries.BaseClasses.BaseStackWithSensors` with the following redeclarations:\n- redeclare `Modelica.Electrical.Batteries.ParameterRecords.TransientData.StackData stackData`\n- `redeclare Modelica.Electrical.Batteries.BatteryStacksWithSensors.CellRC` cell with the following parameters:\n- `cellData = stackData.cellData`\n- `SOC0 = SOC`0\n- `each SOCtolerance = SOCtolerance`\n- `each useHeatPort = useHeatPort`\n- `each T = T`\n- The model should also extend `Modelica.Electrical.Batteries.Icons.TransientModel`.\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model StackRC",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Batteries.BatteryStacksWithSensors.StackRC",
            "output": "within Modelica.Electrical.Batteries.BatteryStacksWithSensors;\nmodel StackRC \"Stack with sensors\"\n  extends Modelica.Electrical.Batteries.BaseClasses.BaseStackWithSensors(\n redeclare Modelica.Electrical.Batteries.ParameterRecords.TransientData.StackData stackData,\n redeclare Modelica.Electrical.Batteries.BatteryStacksWithSensors.CellRC cell(\n cellData=stackData.cellData,\n SOC0=SOC0,\n each SOCtolerance=SOCtolerance,\n each useHeatPort=useHeatPort,\n each T=T));\n  extends Modelica.Electrical.Batteries.Icons.TransientModel\n  ;\nend StackRC;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f"
        },
        {
            "id": 66,
            "instruction": "Generate a Modelica block named `Impedance` that calculates the complex impedance of a battery. The model should include the following components and details:\n1.Model Functionality: The model calculates the complex impedance based on the given frequency and cell data.\n2.Components:\n- The model should extend `Modelica.Blocks.Icons.Block`.\n- Import the necessary constants and functions from Modelica.Constants and Modelica.ComplexMath.\n- Include a parameter for transient cell data: `Modelica.Electrical.Batteries.ParameterRecords.TransientData.CellData cellData`.\n- Include a RealInput for frequency with unit Hz: Modelica.Blocks.Interfaces.RealInput f.\n- Include a ComplexOutput for the complex impedance with units Ohm for both real and imaginary parts: `Modelica.ComplexBlocks.Interfaces.ComplexOutput z(re, im)`.\n3.Equations and Expressions:\n The model should include the following equation to calculate the complex impedance:\n `z = Complex(cellData.R0, 0) + sum({1/Complex(1/cellData.rcData[k].R, 2pif*cellData.rcData[k].C) for k in 1:cellData.nRC})`.\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```block Impedance",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Batteries.Utilities.Impedance",
            "output": "within Modelica.Electrical.Batteries.Utilities;\nblock Impedance \"Calculate complex impedance\"\n  extends Blocks.Icons.Block;\n  import Modelica.Constants.pi;\n  import Modelica.ComplexMath.sum;\n  parameter Modelica.Electrical.Batteries.ParameterRecords.TransientData.CellData cellData \"Transient cell data\";\n  Blocks.Interfaces.RealInput f(unit=\"Hz\") \"Frequency\"\n ;\n  ComplexBlocks.Interfaces.ComplexOutput z(re(unit=\"Ohm\"), im(unit=\"Ohm\")) \"Complex impedance\"\n ;\nequation\n  z = Complex(cellData.R0, 0) + sum({1/Complex(1/cellData.rcData[k].R, 2*pi*f*cellData.rcData[k].C) for k in 1:cellData.nRC})\n  ;\nend Impedance;\n",
            "type": "block",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Impedance completed successfully.\nClass Impedance has 2 equation(s) and 2 variable(s).\n0 of these are trivial equation(s)."
        },
        {
            "id": 67,
            "instruction": "Generate a Modelica model named `IdealCore` that represents an ideal transformer with 3 windings. The model should include the following components and details:\n 1.Components:\n- The model should extend `PartialCore`.\n2. Equations and Expressions:\n The model should include the following equations to define the relationships between the voltages and currents of the windings:\n- `im = fill(Complex(0), m)`\n- `v1 = n12 * v2`\n- `v1 = n13 * v3`\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model IdealCore",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.BasicMachines.Components.IdealCore",
            "output": "within Modelica.Electrical.Machines.BasicMachines.Components;\nmodel IdealCore \"Ideal transformer with 3 windings\"\n  extends PartialCore;\nequation\n  im = zeros(m);\n  v1 = n12*v2;\n  v1 = n13*v3\n  ;\nend IdealCore;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of IdealCore completed successfully.\nClass IdealCore has 57 equation(s) and 57 variable(s).\n30 of these are trivial equation(s)."
        },
        {
            "id": 68,
            "instruction": "Generate a Modelica model named `SquirrelCage` that represents a squirrel cage for an electrical machine. The model should include the following components and details:\n1. Model Functionality: The model represents a squirrel cage with parameters for rotor stray inductance, rotor resistance, reference temperature, and temperature coefficient of resistance.\n2. Components:\n- The model should include the following parameters:\n- Modelica.Units.SI.Inductance Lrsigma: Rotor stray inductance per phase translated to stator. \n- Modelica.Units.SI.Resistance Rr: Rotor resistance per phase translated to stator at T_ref. \n- Modelica.Units.SI.Temperature T_ref: Reference temperature (default 293.15 K).\n- Modelica.Units.SI.LinearTemperatureCoefficient alpha: Temperature coefficient of resistance at T_ref (default 0).\n- The model should extend Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort with T set to T_ref. \n- Include a variable for the actual rotor resistance: Modelica.Units.SI.Resistance Rr_actual. \n- Include a space phasor for the rotor: `Modelica.Electrical.Machines.Interfaces.SpacePhasor spacePhasor_r`. \n- Include a RealOutput array for the currents out from the squirrel cage: Modelica.Blocks.Interfaces.RealOutput i[2] with quantity ElectricCurrent and unit A, set to -spacePhasor_r.i_.\n3. Equations and Expressions:\n The model should include the following equations:\n- An assertion to ensure the temperature is within the valid range: assert((1 + alpha*(T_heatPort - T_ref)) >= Modelica.Constants.eps, \"Temperature outside scope of model!\"). \n- An equation to calculate the actual rotor resistance: Rr_actual = Rr*(1 + alpha*(T_heatPort - T_ref)). \n- An equation to define the voltage-current relationship for the space phasor: spacePhasor_r.v_ = Rr_actualspacePhasor_r.i_ + Lrsigmader(spacePhasor_r.i_). \n- An equation to calculate the loss power: 2/3LossPower = Rr_actual(spacePhasor_r.i_[1]*spacePhasor_r.i_[1] + spacePhasor_r.i_[2]*spacePhasor_r.i_[2]). \n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model SquirrelCage",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.BasicMachines.Components.SquirrelCage",
            "output": "within Modelica.Electrical.Machines.BasicMachines.Components;\nmodel SquirrelCage \"Squirrel Cage\"\n  parameter SI.Inductance Lrsigma\n \"Rotor stray inductance per phase translated to stator\";\n  parameter SI.Resistance Rr\n \"Rotor resistance per phase translated to stator at T_ref\";\n  parameter SI.Temperature T_ref=293.15\n \"Reference temperature\";\n  parameter SI.LinearTemperatureCoefficient alpha=0\n \"Temperature coefficient of resistance at T_ref\";\n  extends Modelica.Electrical.Analog.Interfaces.ConditionalHeatPort(T=T_ref);\n  SI.Resistance Rr_actual\n \"Actual resistance = Rr*(1 + alpha*(T_heatPort - T_ref))\";\n  Machines.Interfaces.SpacePhasor spacePhasor_r\n ;\n  Modelica.Blocks.Interfaces.RealOutput i[2](\n each final quantity=\"ElectricCurrent\",\n each final unit=\"A\") = -spacePhasor_r.i_\n \"Currents out from squirrel cage\";\nequation\n  assert((1 + alpha*(T_heatPort - T_ref)) >= Modelica.Constants.eps,\n \"Temperature outside scope of model!\");\n  Rr_actual = Rr*(1 + alpha*(T_heatPort - T_ref));\n  spacePhasor_r.v_ = Rr_actual*spacePhasor_r.i_ + Lrsigma*der(\n spacePhasor_r.i_);\n  2/3*LossPower = Rr_actual*(spacePhasor_r.i_[1]*spacePhasor_r.i_[1] +\n spacePhasor_r.i_[2]*spacePhasor_r.i_[2])\n  ;\nend SquirrelCage;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 69,
            "instruction": "Generate a Modelica model named `Dd04` that represents a transformer with a Dd4 vector group. The model should include the following components and details:\n1. Components:\n- The model should extend `Modelica.Electrical.Machines.Interfaces.PartialBasicTransformer` with the final VectorGroup set to `Dd04`. \n- Include two delta connections: Modelica.Electrical.Polyphase.Basic.Delta Delta1 and Delta2, both with final m set to m.\n2. Connections:\n The model should include the following connections:\n- connect(r1.plug_p, Delta1.plug_p)\n- connect(Delta2.plug_n, r2.plug_p)\n- connect(l1sigma.plug_n, core.plug_p1)\n- connect(Delta1.plug_n, core.plug_n1)\n- connect(core.plug_n2, core.plug_p3)\n- connect(core.plug_p2, Delta2.plug_p)\n- connect(core.plug_n3, l2sigma.plug_n)\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model Dd04",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.BasicMachines.Transformers.Dd.Dd04",
            "output": "within Modelica.Electrical.Machines.BasicMachines.Transformers.Dd;\nmodel Dd04 \"Transformer Dd4\"\n  extends Machines.Interfaces.PartialBasicTransformer(final VectorGroup=\"Dd04\");\n  Modelica.Electrical.Polyphase.Basic.Delta Delta1(final m=m)\n ;\n  Modelica.Electrical.Polyphase.Basic.Delta Delta2(final m=m)\n ;\nequation\n  connect(r1.plug_p, Delta1.plug_p) ;\n  connect(Delta2.plug_n, r2.plug_p) ;\n  connect(l1sigma.plug_n, core.plug_p1) ;\n  connect(Delta1.plug_n, core.plug_n1) ;\n  connect(core.plug_n2, core.plug_p3) ;\n  connect(core.plug_p2, Delta2.plug_p) ;\n  connect(core.plug_n3, l2sigma.plug_n) \n  ;\nend Dd04;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of Dd04 completed successfully.\nClass Dd04 has 355 equation(s) and 355 variable(s).\n248 of these are trivial equation(s)."
        },
        {
            "id": 70,
            "instruction": "Generate a Modelica model named `Dy05` that represents a transformer with a Dy5 vector group. The model should include the following components and details:\n1. Components:\n- The model should extend `Modelica.Electrical.Machines.Interfaces.PartialBasicTransformer` with the final VectorGroup set to `Dy05`. \n- Include a star connection for the secondary winding: Modelica.Electrical.Polyphase.Basic.Star star2 with final m set to m.\n- Include a negative pin for the star point: Modelica.Electrical.Analog.Interfaces.NegativePin starpoint2. \n- Include a delta connection for the primary winding: Modelica.Electrical.Polyphase.Basic.Delta Delta1 with final m set to m.\n2. Connections:\n The model should include the following connections:\n- connect(star2.pin_n, starpoint2)\n- connect(Delta1.plug_p, r1.plug_p)\n- connect(Delta1.plug_n, core.plug_n1)\n- connect(l1sigma.plug_n, core.plug_p1)\n- connect(core.plug_n2, core.plug_p3)\n- connect(l2sigma.plug_n, core.plug_n3)\n- connect(core.plug_p2, star2.plug_p)\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model Dy05",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.BasicMachines.Transformers.Dy.Dy05",
            "output": "within Modelica.Electrical.Machines.BasicMachines.Transformers.Dy;\nmodel Dy05 \"Transformer Dy5\"\n  extends Machines.Interfaces.PartialBasicTransformer(final VectorGroup=\"Dy05\");\n  Modelica.Electrical.Polyphase.Basic.Star star2(final m=m)\n ;\n  Modelica.Electrical.Analog.Interfaces.NegativePin starpoint2\n ;\n  Modelica.Electrical.Polyphase.Basic.Delta Delta1(final m=m)\n ;\nequation\n  connect(star2.pin_n, starpoint2) ;\n  connect(Delta1.plug_p, r1.plug_p) ;\n  connect(Delta1.plug_n, core.plug_n1) ;\n  connect(l1sigma.plug_n, core.plug_p1) ;\n  connect(core.plug_n2, core.plug_p3)\n ;\n  connect(l2sigma.plug_n, core.plug_n3) ;\n  connect(core.plug_p2, star2.plug_p) \n  ;\nend Dy05;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of Dy05 completed successfully.\nClass Dy05 has 353 equation(s) and 353 variable(s).\n248 of these are trivial equation(s)."
        },
        {
            "id": 71,
            "instruction": "Generate a Modelica model named `Yd01` that represents a transformer with a Yd1 vector group. The model should include the following components and details:\n1. Components:\n- The model should extend `Modelica.Electrical.Machines.Interfaces.PartialBasicTransformer` with the final VectorGroup set to `Yd01`. \n- Include a star connection for the primary winding: Modelica.Electrical.Polyphase.Basic.Star star1 with final m set to m.\n- Include a negative pin for the star point: Modelica.Electrical.Analog.Interfaces.NegativePin starpoint1. \n- Include a delta connection for the secondary winding: Modelica.Electrical.Polyphase.Basic.Delta Delta2 with final m set to m.\n2. Connections:\n The model should include the following connections:\n- connect(star1.pin_n, starpoint1)\n- connect(Delta2.plug_p, r2.plug_p)\n- connect(l1sigma.plug_n, core.plug_p1)\n- connect(core.plug_n1, star1.plug_p)\n- connect(core.plug_n2, core.plug_p3)\n- connect(core.plug_n3, Delta2.plug_n)\n- connect(core.plug_p2, l2sigma.plug_n)\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model Yd01",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.BasicMachines.Transformers.Yd.Yd01",
            "output": "within Modelica.Electrical.Machines.BasicMachines.Transformers.Yd;\nmodel Yd01 \"Transformer Yd1\"\n  extends Machines.Interfaces.PartialBasicTransformer(final VectorGroup=\"Yd01\");\n  Modelica.Electrical.Polyphase.Basic.Star star1(final m=m)\n ;\n  Modelica.Electrical.Analog.Interfaces.NegativePin starpoint1\n ;\n  Modelica.Electrical.Polyphase.Basic.Delta Delta2(final m=m)\n ;\nequation\n  connect(star1.pin_n, starpoint1) ;\n  connect(Delta2.plug_p, r2.plug_p) ;\n  connect(l1sigma.plug_n, core.plug_p1) ;\n  connect(core.plug_n1, star1.plug_p) ;\n  connect(core.plug_n2, core.plug_p3)\n ;\n  connect(core.plug_n3, Delta2.plug_n) ;\n  connect(core.plug_p2, l2sigma.plug_n) \n  ;\nend Yd01;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of Yd01 completed successfully.\nClass Yd01 has 353 equation(s) and 353 variable(s).\n248 of these are trivial equation(s)."
        },
        {
            "id": 72,
            "instruction": "Generate a Modelica model named `IMC_Transformer` that represents a test example for starting an induction machine with a squirrel cage using a transformer. The model should include the following components and details:\n1. Components:\n- The model should extend from `Modelica.Electrical.Machines.Examples.InductionMachines.IMC_Transformer`.\n Please ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model IMC_Transformer",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Examples.Transformers.IMC_Transformer",
            "output": "within Modelica.Electrical.Machines.Examples.Transformers;\nmodel IMC_Transformer\n  \"Test example: InductionMachineSquirrelCage transformer starting\"\n  extends Machines.Examples.InductionMachines.IMC_Transformer\n  ;\nend IMC_Transformer;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 73,
            "instruction": "Generate a Modelica model named `CurrentControlledDCPM` that represents a current-controlled DC permanent magnet (PM) drive with an H-bridge, powered from a battery. The model should include the following components and details:\n1. Components: \n- The model should extend from `Modelica.Electrical.Machines.Examples.ControlledDCDrives.Utilities.PartialControlledDCPM`. \n- Include a quadratic speed-dependent torque source for the load: Modelica.Mechanics.Rotational.Sources.QuadraticSpeedDependentTorque loadTorque with parameters tau_nominal set to -driveData.tauNominal, TorqueDirection set to false, and w_nominal set to driveData.motorData.wNominal. \n- Include a step source for the torque input: Modelica.Blocks.Sources.Step step with parameters offset set to 0, startTime set to 0.2, and height set to driveData.tauNominal.\n2. Connections:\n The model should include the following connections: \n- connect(loadInertia.flange_b, loadTorque.flange) \n- connect(step.y, tau2i.u)\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model CurrentControlledDCPM",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Examples.ControlledDCDrives.CurrentControlledDCPM",
            "output": "within Modelica.Electrical.Machines.Examples.ControlledDCDrives;\nmodel CurrentControlledDCPM\n  \"Current controlled DC PM drive with H-bridge from battery\"\n  extends Utilities.PartialControlledDCPM;\n  Modelica.Mechanics.Rotational.Sources.QuadraticSpeedDependentTorque\n loadTorque(\n tau_nominal=-driveData.tauNominal,\n TorqueDirection=false,\n w_nominal=driveData.motorData.wNominal)\n ;\n  Modelica.Blocks.Sources.Step step(\n offset=0,\n startTime=0.2,\n height=driveData.tauNominal) ;\nequation\n  connect(loadInertia.flange_b, loadTorque.flange)\n ;\n  connect(step.y, tau2i.u)\n\n  ;\nend CurrentControlledDCPM;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 74,
            "instruction": "Generate a Modelica model named `Brush` that represents the voltage drop of carbon brushes in an induction machine. The model should include the following components and details:\n1. Model Functionality: The model considers the voltage drop of carbon brushes and includes thermal effects.\n2. Components:\n- The model should extend from Modelica.Electrical.Polyphase.Interfaces.TwoPlug.\n- Parameter for brush loss parameters: parameter Modelica.Electrical.Machines.Losses.BrushParameters brushParameters.\n- The model should extend from Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort with useHeatPort set to false and final T set to 293.15.\n- Array of brushes: Modelica.Electrical.Machines.Losses.DCMachines.Brush brush[3] with each final brushParameters set to brushParameters and each final useHeatPort set to true.\n3. Connections:\n The model should include the following connections:\n- connect(plug_p.pin, brush.p)\n- connect(brush.n, plug_n.pin)\n- Loop to connect each brush heat port to the internal heat port: for j in 1:m loop\n  connect(brush[j].heatPort, internalHeatPort)\n end for\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model Brush",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Losses.InductionMachines.Brush",
            "output": "within Modelica.Electrical.Machines.Losses.InductionMachines;\nmodel Brush \"Model considering voltage drop of carbon brushes\"\n  extends Modelica.Electrical.Polyphase.Interfaces.TwoPlug;\n  parameter Machines.Losses.BrushParameters brushParameters\n \"Brush loss parameters\";\n  extends Modelica.Thermal.HeatTransfer.Interfaces.PartialConditionalHeatPort(\n useHeatPort=false,final T=293.15);\n  DCMachines.Brush brush[3](each final brushParameters=brushParameters,\n each final useHeatPort=true)\n ;\nequation\n  connect(plug_p.pin, brush.p) ;\n  connect(brush.n, plug_n.pin) ;\n  for j in 1:m loop\n connect(brush[j].heatPort, internalHeatPort) ;\n  end for\n  ;\nend Brush;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result" :"Check of Brush completed successfully.\nClass Brush has 49 equation(s) and 49 variable(s).\n39 of these are trivial equation(s)."
        },
        {
            "id": 75,
            "instruction": "Generate a Modelica block named `FromPolar` that converts a space phasor from polar coordinates to Cartesian coordinates. The block should include the following components and details:\n1. Components:\n-  The block should extend from Modelica.Blocks.Interfaces.MIMOs with final n set to 2.\n2. Equations:\n The block should include the following equation to perform the conversion:\n-  y = u[1]*{cos(u[2]), sin(u[2])}\n\n\nPlease ensure that the block is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```block FromPolar",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.SpacePhasors.Blocks.FromPolar",
            "output": "within Modelica.Electrical.Machines.SpacePhasors.Blocks;\nblock FromPolar \"Converts a space phasor from polar coordinates\"\n  extends Modelica.Blocks.Interfaces.MIMOs(final n=2);\nequation\n  y = u[1]*{cos(u[2]),sin(u[2])}\n  ;\nend FromPolar;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 76,
            "instruction": "Generate a Modelica function named `Rotator` that rotates a space phasor by a given angle. The function should include the following components and details:\n1. Components:\n-  The function should extend from Modelica.Icons.Function. \n-  Input for the space phasor: input Real x[2]. \n-  Input for the angle of rotation: input Modelica.Units.SI.Angle angle.\n-  Output for the rotated space phasor: output Real y[2] .\n2. Protected Variables:\n-  Rotation matrix: Real RotationMatrix[2, 2] initialized as {{+cos(-angle), -sin(-angle)}, {+sin(-angle), +cos(-angle)}}.\n3. Algorithm:\n The function should include the following algorithm to perform the rotation:\n-  y := RotationMatrix*x\n\nPlease ensure that the function is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```function Rotator",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.SpacePhasors.Functions.Rotator",
            "output": "within Modelica.Electrical.Machines.SpacePhasors.Functions;\nfunction Rotator \"Rotates space phasor\"\n  extends Modelica.Icons.Function;\n  input Real x[2] \"Input space phasor\";\n  input SI.Angle angle \"Input angle of rotation\";\n  output Real y[2] \"Output space phasor\";\nprotected\n  Real RotationMatrix[2, 2]={{+cos(-angle),-sin(-angle)},{+sin(-angle),+\n cos(-angle)}};\nalgorithm\n  y := RotationMatrix*x\n  ;\nend Rotator;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 77,
            "instruction": "Generate a Modelica function named `convertAlpha` that converts a linear temperature coefficient (alpha) from one temperature to another. The function should include the following components and details:\n1. Components:\n-  The function should extend from Modelica.Icons.Function. \n-  Input for the linear temperature coefficient at temperature 1: input Modelica.Units.SI.LinearTemperatureCoefficient alpha1. \n-  Input for temperature 2: input Modelica.Units.SI.Temperature T2. \n-  Input for temperature 1 with a default value: input Modelica.Units.SI.Temperature T1=293.15. \n-  Output for the linear temperature coefficient at temperature 2: output Modelica.Units.SI.LinearTemperatureCoefficient alpha2.\n2. Algorithm:\n The function should include the following algorithm to perform the conversion:\n-  alpha2 := alpha1/(1 + alpha1*(T2 - T1))\n\nPlease ensure that the function is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```function convertAlpha",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Thermal.convertAlpha",
            "output": "within Modelica.Electrical.Machines.Thermal;\nfunction convertAlpha\n  \"Converts alpha from temperature 1 (default 20 degC) to temperature 2\"\n  extends Modelica.Icons.Function;\n  input SI.LinearTemperatureCoefficient alpha1\n \"Temperature coefficient at temperature 1 (default: 20 degC)\";\n  input SI.Temperature T2 \"Temperature 2\";\n  input SI.Temperature T1=293.15\n \"Temperature 1 (default: 20 degC)\";\n  output SI.LinearTemperatureCoefficient alpha2\n \"Temperature coefficient at TRef\";\nalgorithm\n  alpha2 := alpha1/(1 + alpha1*(T2 - T1))\n  ;\nend convertAlpha;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 78,
            "instruction": "Generate a Modelica block named 'ToDQ' that transforms instantaneous stator inputs to a rotor fixed space phasor. The block should include the following components and details:\n1. Components:\n- The block should extend from Modelica.Blocks.Interfaces.MIMO with final nin set to m and final nout set to 2. \n- Parameter for the number of phases: parameter Integer m(min=1) = 3. \n- Parameter for the number of pole pairs: parameter Integer p.\n- Gain block: Modelica.Blocks.Math.Gain toGamma with final k=p.\n- Rotator block: Modelica.Electrical.Machines.SpacePhasors.Blocks.Rotator rotator.\n- Real input for the angle: Modelica.Blocks.Interfaces.RealInput phi with unit set to \"rad\".\n- ToSpacePhasor block: Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor toSpacePhasor with final m set to m.\n2. Connections:\n The block should include the following connections:\n- connect(phi, toGamma.u)\n- connect(rotator.angle, toGamma.y)\n- connect(toSpacePhasor.y, rotator.u)\n- connect(u, toSpacePhasor.u)\n- connect(rotator.y, y)\n\nPlease ensure that the block is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```block ToDQ",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Utilities.ToDQ",
            "output": "within Modelica.Electrical.Machines.Utilities;\nblock ToDQ\n  \"Transform instantaneous stator inputs to rotor fixed space phasor\"\n  extends Modelica.Blocks.Interfaces.MIMO(final nin=m, final nout=2);\n  parameter Integer m(min=1) = 3 \"Number of phases\" ;\n  parameter Integer p \"Number of pole pairs\";\n  Modelica.Blocks.Math.Gain toGamma(final k=p) ;\n  Modelica.Electrical.Machines.SpacePhasors.Blocks.Rotator rotator\n ;\n  Modelica.Blocks.Interfaces.RealInput phi(unit=\"rad\") ;\n  Modelica.Electrical.Machines.SpacePhasors.Blocks.ToSpacePhasor toSpacePhasor(final m=m)\n ;\nequation\n  connect(phi, toGamma.u)\n ;\n  connect(rotator.angle, toGamma.y)\n ;\n  connect(toSpacePhasor.y, rotator.u) ;\n  connect(u, toSpacePhasor.u) ;\n  connect(rotator.y, y) \n  ;\nend ToDQ;\n",
            "type": "block",
            "feature": "connect"
        },
        {
            "id": 79,
            "instruction": "Generate a Modelica block named `VfController` that implements a Voltage-Frequency-Controller. The block should include the following components and details:\n1. Block Functionality: The block controls the voltage and frequency for a multi-phase system.\n2. Components:\n- The block should extend from Modelica.Blocks.Interfaces.SIMO with u having the unit \"Hz\" and final nout set to m.\n- Parameter for the number of phases: parameter Integer m=3. \n- Parameter for the orientation of phases: parameter Modelica.Units.SI.Angle orientation[m] initialized with Modelica.Electrical.Polyphase.Functions.symmetricOrientation(m).\n- Parameter for the nominal RMS voltage per phase: parameter Modelica.Units.SI.Voltage VNominal.\n- Parameter for the nominal frequency: parameter Modelica.Units.SI.Frequency fNominal.\n- Parameter for the common phase shift: parameter Modelica.Units.SI.Angle BasePhase=0.\n- Parameter for economy mode: parameter Boolean EconomyMode=false.\n- Output for the integrator state: output Modelica.Units.SI.Angle x(start=0, fixed=true).\n- Output for the voltage amplitude: output Modelica.Units.SI.Voltage amplitude.\n3. Protected Variables:\n- Integer pow initialized as if EconomyMode then 2 else 1.\n4. Equations:\n The block should include the following equations:\n- amplitude = sqrt(2)*VNominal*(if abs(u) < fNominal then (abs(u)/fNominal)^pow else 1)\n- der(x) = 2*pi*u\n- y = amplitude*sin(fill(x + BasePhase, m) + orientation)\n\nPlease ensure that the block is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```block VfController",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Machines.Utilities.VfController",
            "output": "within Modelica.Electrical.Machines.Utilities;\nblock VfController \"Voltage-Frequency-Controller\"\n  import Modelica.Constants.pi;\n  extends Modelica.Blocks.Interfaces.SIMO(u(unit=\"Hz\"), final nout=m);\n  parameter Integer m=3 \"Number of phases\" ;\n  parameter SI.Angle orientation[m]=-\n Modelica.Electrical.Polyphase.Functions.symmetricOrientation(m)\n \"Orientation of phases\";\n  parameter SI.Voltage VNominal \"Nominal RMS voltage per phase\";\n  parameter SI.Frequency fNominal \"Nominal frequency\";\n  parameter SI.Angle BasePhase=0 \"Common phase shift\";\n  parameter Boolean EconomyMode=false \"Economy mode: voltage quadratic dependent on frequency\"\n ;\n  output SI.Angle x(start=0, fixed=true) \"Integrator state\";\n  output SI.Voltage amplitude;\nprotected\n  parameter Integer pow=if EconomyMode then 2 else 1\n ;\nequation\n  \n  amplitude = sqrt(2)*VNominal*(if abs(u) < fNominal then (abs(u)/fNominal)^pow else 1);\n  der(x) = 2*pi*u;\n  y = amplitude*sin(fill(x + BasePhase, m) + orientation)\n  ;\nend VfController;\n",
            "type": "block",
            "feature": "extends"
        },
        {
            "id": 80,
            "instruction": "Generate a Modelica model named `MutualInductor` that represents a linear mutual inductor. The model should include the following components and details:\n1. Components:\n- The model should extend from Modelica.Electrical.Polyphase.Interfaces.OnePort. \n- Parameter for the relative accuracy tolerance of matrix symmetry: parameter Real epsilon=1e-9. \n- Parameter for the mutual inductance matrix: parameter Modelica.Units.SI.Inductance L[m, m].\n2. Initial Equations:\n The model should include an initial equation to check for the singularity of the mutual inductance matrix:\n- if abs(Modelica.Math.Matrices.det(L)) < epsilon then\n Modelica.Utilities.Streams.print(\"Warning: mutual inductance matrix singular!\");\n end if;\n3. Equations:\n The model should include the following equations to ensure the mutual inductance matrix is symmetric and to define the voltage-current relationship:\n- assert(sum(abs(L - transpose(L))) < epsilon*sum(abs(L)),\"Mutual inductance matrix is not symmetric\");\n- for j in 1:m loop\n v[j] = sum(L[j, k]*der(i[k]) for k in 1:m);\n end for;\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model MutualInductor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Basic.MutualInductor",
            "output": "within Modelica.Electrical.Polyphase.Basic;\nmodel MutualInductor \"Linear mutual inductor\"\n  extends Polyphase.Interfaces.OnePort;\n  parameter Real epsilon=1e-9 \"Relative accuracy tolerance of matrix symmetry\";\n  parameter SI.Inductance L[m, m] \"Mutual inductance matrix\";\ninitial equation\n  if abs(Modelica.Math.Matrices.det(L)) < epsilon then\n Modelica.Utilities.Streams.print(\"Warning: mutual inductance matrix singular!\");\n  end if;\nequation\n  assert(sum(abs(L - transpose(L))) < epsilon*sum(abs(L)),\"Mutual inductance matrix is not symmetric\");\n  for j in 1:m loop\n v[j] = sum(L[j, k]*der(i[k]) for k in 1:m);\n  end for\n  ;\nend MutualInductor;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of MutualInductor completed successfully.\nClass MutualInductor has 18 equation(s) and 18 variable(s).\n12 of these are trivial equation(s)."
        },
        {
            "id": 81,
            "instruction": "Generate a Modelica model named `PlugToPins_p` to connect all positive pins in a polyphase electrical system. The model should include the following components and details:\n1. Components:\n- The model should have a parameter for the number of phases: parameter Integer m(final min=1) = 3. \n- Positive plug interface: `Modelica.Electrical.Polyphase.Interfaces.PositivePlug` plug_p with final m=m\n- Array of positive pins: Modelica.Electrical.Analog.Interfaces.PositivePin pin_p[m].\n3. Equations:\n The model should include the following equations to connect the voltages and currents:\n- pin_pv = plug_p.pin.v;\n- plug_p.pini = -pin_p.i;\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model PlugToPins_p",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Basic.PlugToPins_p",
            "output": "within Modelica.Electrical.Polyphase.Basic;\nmodel PlugToPins_p \"Connect all (positive) Pins\"\n  parameter Integer m(final min=1) = 3 \"Number of phases\" ;\n  Interfaces.PositivePlug plug_p(final m=m) ;\n  Modelica.Electrical.Analog.Interfaces.PositivePin pin_p[m] ;\nequation\n  pin_p.v = plug_p.pin.v;\n  plug_p.pin.i = -pin_p.i\n  ;\nend PlugToPins_p;\n",
            "type": "model",
            "feature": "instantiation",
            "ref": "f",
            "check_result": "Check of PlugToPins_p completed successfully.\nClass PlugToPins_p has 12 equation(s) and 12 variable(s).\n12 of these are trivial equation(s)."
        },
        {
            "id": 82,
            "instruction": "Create a Modelica function named `factorY2DC` that calculates the factor of DC-voltage from RMS Y-voltage for a specified number of phases. The function should include the following components and details:\n1. Components:\n- The function should extend from Modelica.Icons.Function. \n- Import the necessary constants and functions: import Modelica.Constants.pi and import Modelica.Electrical.Polyphase.Functions.numberOfSymmetricBaseSystems. \n- Input for the number of phases: input Integer m=3. \n- Output for the factor: output Real y.\n2. Protected Variables:\n- Integer mBasic initialized as integer(m/numberOfSymmetricBaseSystems(m)).\n3. Algorithm:\n The function should include the following algorithm to calculate the factor:\n- if mBasic==2 then\n y := 4/pi;\n else\n y := 2*sin((mBasic - 1)/2*pi/mBasic)*sqrt(2)*sin(pi/(2*m))/(pi/(2*m));\n end if;\n\nPlease ensure that the function is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```function factorY2DC",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Functions.factorY2DC",
            "output": "within Modelica.Electrical.Polyphase.Functions;\nfunction factorY2DC \"Calculates factor of DC-voltage from RMS Y-voltage\"\n  extends Modelica.Icons.Function;\n  import Modelica.Constants.pi;\n  import Modelica.Electrical.Polyphase.Functions.numberOfSymmetricBaseSystems;\n  input Integer m=3 \"Number of phases\";\n  output Real y \"Factor Yrms to DC\";\nprotected\n  parameter Integer mBasic=integer(m/numberOfSymmetricBaseSystems(m));\nalgorithm\n  if mBasic==2 then\n y := 4/pi;\n  else\n y := 2*sin((mBasic - 1)/2*pi/mBasic)*sqrt(2)*sin(pi/(2*m))/(pi/(2*m));\n  end if;\nend factorY2DC;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 83,
            "instruction": "Generate a Modelica model named `Short` that represents a polyphase short cut branch. The model should include the following components and details:\n1. Components:\n- The model should extend from `Modelica.Electrical.Polyphase.Interfaces.TwoPlug`. \n- An array of ideal short circuits: Modelica.Electrical.Analog.Ideal.Short short[m].\n3. Equations:\n The model should include the following connections:\n- connect(plug_ppin, short.p);\n- connect(shortn, plug_n.pin);\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model Short",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Ideal.Short",
            "output": "within Modelica.Electrical.Polyphase.Ideal;\nmodel Short \"Polyphase short cut branch\"\n  extends Interfaces.TwoPlug;\n  Modelica.Electrical.Analog.Ideal.Short short[m] ;\nequation\n  connect(plug_p.pin, short.p)\n ;\n  connect(short.n, plug_n.pin)\n\n  ;\nend Short;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of Short completed successfully.\nClass Short has 36 equation(s) and 36 variable(s).\n30 of these are trivial equation(s)."
        },
        {
            "id": 84,
            "instruction": "Generate a Modelica model named `VoltageSensor` for a Polyphase voltage sensor designed to measure the voltage differences between pins in a multi-phase electrical system. The model should include the following components and details:\n1. Components:\n- The model should extend from Modelica.Icons.RoundSensor. \n- Parameter for the number of phases: parameter Integer m(final min=1) = 3. \n- Positive polyphase plug: Modelica.Electrical.Polyphase.Interfaces.PositivePlug plug_p(final m=m). \n- Negative polyphase plug: Modelica.Electrical.Polyphase.Interfaces.NegativePlug plug_n(final m=m). \n- Real output for the voltage: Modelica.Blocks.Interfaces.RealOutput v[m] with each unit=\"V\". \n- Array of voltage sensors: Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor[m].\n2. Equations:\n The model should include the following connections:\n- connect(voltageSensor.n, plug_n.pin);\n- connect(voltageSensor.p, plug_p.pin);\n- connect(voltageSensor.v, v);\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model VoltageSensor",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Sensors.VoltageSensor",
            "output": "within Modelica.Electrical.Polyphase.Sensors;\nmodel VoltageSensor \"Polyphase voltage sensor\"\n  extends Modelica.Icons.RoundSensor;\n  parameter Integer m(final min=1) = 3 \"Number of phases\" ;\n  Interfaces.PositivePlug plug_p(final m=m) ;\n  Interfaces.NegativePlug plug_n(final m=m) ;\n  Modelica.Blocks.Interfaces.RealOutput v[m](each unit=\"V\")\n \"Voltage between pin p and n (= p.v - n.v) as output signal\"\n ;\n  Modelica.Electrical.Analog.Sensors.VoltageSensor voltageSensor[m]\n ;\nequation\n  connect(voltageSensor.n, plug_n.pin)\n ;\n  connect(voltageSensor.p, plug_p.pin)\n ;\n  connect(voltageSensor.v, v) \n  ;\nend VoltageSensor;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of VoltageSensor completed successfully.\nClass VoltageSensor has 30 equation(s) and 30 variable(s).\n27 of these are trivial equation(s)."
        },
        {
            "id": 85,
            "instruction": "Create a Modelica model named `SignalCurrent` to serve as a polyphase signal current source. The model should include the following components and details:\n1. Components:\n- Parameter for the number of phases: parameter Integer m(min=1) = 3.\n- Voltage drops between the two plugs: Modelica.Units.SI.Voltage v[m] = plug_p.pin.v - plug_n.pin.v .\n- Positive polyphase plug: Modelica.Electrical.Polyphase.Interfaces.PositivePlug plug_p(final m=m).\n- Negative polyphase plug: Modelica.Electrical.Polyphase.Interfaces.NegativePlug plug_n(final m=m).\n- Real input for the current: Modelica.Blocks.Interfaces.RealInput i[m] with each unit=\"A\".\n- Array of signal current sources: Modelica.Electrical.Analog.Sources.SignalCurrent signalCurrent[m].\n2. Equations:\n The model should include the following connections:\n- connect(signalCurrent.p, plug_p.pin);\n- connect(signalCurrent.n, plug_n.pin);\n- connect(i, signalCurrent.i);\n\nPlease ensure that the model is syntactically correct and adheres to the Modelica language standard.\n\n//modelica\n```model SignalCurrent",
            "input": "Modelica version: 4.0.0\nSource: Modelica 4.0.0.Electrical.Polyphase.Sources.SignalCurrent",
            "output": "within Modelica.Electrical.Polyphase.Sources;\nmodel SignalCurrent \"Polyphase signal current source\"\n  parameter Integer m(min=1) = 3 \"Number of phases\" ;\n  SI.Voltage v[m]=plug_p.pin.v - plug_n.pin.v\n \"Voltage drops between the two plugs\";\n  Interfaces.PositivePlug plug_p(final m=m) ;\n  Interfaces.NegativePlug plug_n(final m=m) ;\n  Modelica.Blocks.Interfaces.RealInput i[m](each unit=\"A\")\n \"Current flowing from pin p to pin n as input signal\" ;\n  Modelica.Electrical.Analog.Sources.SignalCurrent signalCurrent[m]\n ;\nequation\n  connect(signalCurrent.p, plug_p.pin)\n ;\n  connect(signalCurrent.n, plug_n.pin)\n ;\n  connect(i, signalCurrent.i)\n\n  ;\nend SignalCurrent;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of SignalCurrent completed successfully.\nClass SignalCurrent has 33 equation(s) and 33 variable(s).\n27 of these are trivial equation(s)."
        },
        {
            "id": 86,
            "instruction": "Please use modelica to help me implement a model named `FirstOrderExperiment`: This is a simple differential equation: der(x)=1-x, where the initial value of x is 2, and the simulation time is 0-10 seconds.\n\n//modelica\n```model FirstOrderExperiment",
            "input": "",
            "output": "model FirstOrderExperiment \"Defining experimental conditions\"\n  Real x \"State variable\";\ninitial equation\n  x = 2 \"Used before simulation to compute initial values\";\nequation\n  der(x) = 1-x \"Drives value of x toward 1.0\";\n  annotation(experiment(StartTime=0,StopTime=8));\nend FirstOrderExperiment;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 87,
            "instruction": "Please use modelica to help me implement a model named `BouncingBall`: This is a bouncing ball model with a radius of 0.1m, an initial height of 1m and an initial velocity of 0 m/s. Affected by gravity, the ball moves in free fall and bounces upward at the moment it hits the ground. The recovery coefficient during the collision is 0.1.\n\n//modelica\n```model BouncingBall",
            "input": "",
            "output": "model BouncingBall \"Simple model of a bouncing ball\"\n  constant Real g = 9.81 \"Gravity constant\";\n  parameter Real c = 0.9 \"Coefficient of restitution\";\n  parameter Real redius = 0.1 \"Radius of the ball\";\n  Real height(start=1) \"Height of the ball center\";\n  Real velocity(start=0) \"Velocity of the ball\";\nequation\n  der(height) = velocity;\n  der(velocity) = -g;\n  when height<=redius then\n    reinit(velocity,-c*pre(velocity));\n  end when;\nend BouncingBall;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 88,
            "instruction": "Please use modelica to help me implement a model named `SimplePendulum`: Simulate a single pendulum model in which the pendulum is positioned on a circle with radius L=1 and the mass of the pendulum is m=1. The Angle and angular velocity of the rope to the vertical direction are theta and omega, respectively.\n\n//modelica\n```model SimplePendulum",
            "input": "",
            "output": "model SimplePendulum\n  parameter Real L = 1;\n  parameter Real m = 1;\n  parameter Real g = 9.81;\n  Real theta(start=1.5, fixed=false);\n  Real omega(start=0);\nequation\n  der(theta) = omega;\n  der(omega) = -g/L * sin(theta);\nend SimplePendulum;",
            "type": "model",
            "feature": ""
        },
        {
            "id": 89,
            "instruction": "Please use modelica to help me implement a model named `NewtonCoolingWithTypes`: Simulate the temperature change of a water `T` under Newton's law of cooling. Among them, the initial temperature of water is 100 °C, the ambient temperature is 25 °C, the water meter area is 1 square meter, the mass is 1kg, the specific heat is 4200J/(kg.°C), and the convection cooling coefficient is 767W/(m2.°C).\n\n//modelica\n```model NewtonCoolingWithTypes",
            "input": "",
            "output": "model NewtonCoolingWithTypes \"Cooling example with physical types\"\n  // Types\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  // Parameters\n  parameter Temperature T_inf=25 \"Ambient temperature\";\n  parameter Temperature T0=100 \"Initial temperature\";\n  parameter ConvectionCoefficient h=767 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=4200 \"Specific heat\";\n\n  // Variables\n  Temperature T \"Temperature\";\ninitial equation\n  T = T0 \"Specify initial value for T\";\nequation\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingWithTypes;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 90,
            "instruction": "Please help me implement a modelica model named `RLC1`: Simulate an RLC circuit consisting of a capacitor, an inductor and a resistor. Where the capacitor and the resistor are in parallel, and then in series with the inductor, the voltage at both ends of the circuit V=24V, R=100 ohms, C=1e-3 farads, L=1 henry.\n\n//modelica\n```model RLC1",
            "input": "",
            "output": "model RLC1 \"A resistor-inductor-capacitor circuit model\"\n  type Voltage=Real(unit=\"V\");\n  type Current=Real(unit=\"A\");\n  type Resistance=Real(unit=\"Ohm\");\n  type Capacitance=Real(unit=\"F\");\n  type Inductance=Real(unit=\"H\");\n  parameter Voltage Vb=24 \"Battery voltage\";\n  parameter Inductance L = 1;\n  parameter Resistance R = 100;\n  parameter Capacitance C = 1e-3;\n  Voltage V;\n  Current i_L;\n  Current i_R;\n  Current i_C;\nequation\n  V = i_R*R;\n  C*der(V) = i_C;\n  L*der(i_L) = (Vb-V);\n  i_L=i_R+i_C;\nend RLC1;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 91,
            "instruction": "Please help me implement a modelica model named `PredatorPreySystem`: A predator-prey system consisting of two species populations, prey x and predator y. The reproductive rate of the prey is alpha=0.1, the mortality rate of the predator is gamma=0.4, the mortality rate of predator per prey is beta=0.02, and the reproduction rate of predator per prey is delta=0.02. The initial population size of both prey and predator was 10.\n\n//modelica\n```model PredatorPreySystem",
            "input": "",
            "output": "model PredatorPreySystem \"This is the typical equation-oriented model\"\n  parameter Real alpha=0.1 \"Reproduction rate of prey\";\n  parameter Real beta=0.02 \"Mortality rate of predator per prey\";\n  parameter Real gamma=0.4 \"Mortality rate of predator\";\n  parameter Real delta=0.02 \"Reproduction rate of predator per prey\";\n  parameter Real x0=10 \"Start value of prey population\";\n  parameter Real y0=10 \"Start value of predator population\";\n  Real x(start=x0) \"Prey population\";\n  Real y(start=y0) \"Predator population\";\nequation\n  der(x) = x*(alpha-beta*y);\n  der(y) = y*(delta*x-gamma);\nend PredatorPreySystem;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 92,
            "instruction": "Please use modelica to help me implement a model named `NewtonCoolingDynamic`: Simulate the temperature change of a water under Newton's law of cooling. Among them, the initial temperature of water is 100 °C, the ambient temperature is 25 °C, the water meter area is 1 square meter, the mass is 1kg, the specific heat is 4200J/(kg.°C), and the convection cooling coefficient is 767W/(m2.°C). 20 seconds after the start of the simulation, the ambient temperature suddenly dropped to 0°C.\n\n//modelica\n```model NewtonCoolingDynamic",
            "input": "",
            "output": "model NewtonCoolingDynamic\n  \"Cooling example with fluctuating ambient conditions\"\n  // Types\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  // Parameters\n  parameter Temperature T0=100 \"Initial temperature\";\n  parameter ConvectionCoefficient h=767 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=4200 \"Specific heat\";\n\n  // Variables\n  Temperature T_inf \"Ambient temperature\";\n  Temperature T \"Temperature\";\ninitial equation\n  T = T0 \"Specify initial value for T\";\nequation\n  if time<=0.5 then\n    T_inf = 25 \"Constant temperature when time<=0.5\";\n  else\n    T_inf = 0 \"Otherwise, increasing\";\n  end if;\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingDynamic;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 93,
            "instruction": "We have a reservoir, and we want to keep the height of the water in the reservoir at 1m. The water height in the pool is 0.2m at the beginning. Please use proportional control to implement the above control system and simulate the change of the water level in the pool over time with a proportional factor of 1. Please help me implement a modelica model named `PController`.\n\n//modelica\n```model PController",
            "input": "",
            "output": "model PController\n  parameter Real Kp = 1 \"Proportional coefficient\";\n  parameter Real target_height \"Target altitude\";\n  \n  Real waterLevel(start=0.2) \"Actual altitude\";\n  Real error \"Altitude error\";\n  Real control \"Control signal\";\n  \nequation\n  error = target_height - waterLevel;\n  control = Kp * error;\n  der(waterLevel) = control;\n  \nend PController;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 94,
            "instruction": "We have a container, and we want to keep the height of the water in the container at 1 meter. The water height in the pool starts at 0.2m, and the pool will leak 0.1m per unit time. Use proportional integral control to implement the above control system and simulate the change of the water level in the pool over time, where the proportional coefficient is 1 and the integral coefficient is 0.5. Please help me implement a modelica model named `PIController`.\n\n//modelica\n```model PIController",
            "input": "",
            "output": "model PIController\n  parameter Real Kp=1 \"Proportional coefficient\";\n  parameter Real Ki=0.5 \"Integral coefficient\";\n  parameter Real target_height=1 \"Target altitude\";\n  \n  Real waterLevel(start=0.2) \"Actual altitude\";\n  Real error \"Altitude error\";\n  Real Pcontrol \"Proportional Control signal\", Icontrol \"Integral Control signal\";\n  \nequation\n  error = target_height - waterLevel;\n  Pcontrol = Kp * error - 0.1;\n  error = der(Icontrol/Ki);\n  der(waterLevel) = Pcontrol + Icontrol;\n  \nend PIController;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 95,
            "instruction": "We have a container, and we want to keep the height of the water in the container at 1 meter. The water height in the pool starts at 0.2m. Use proportional differential control to implement the above control system and simulate the change of the water level in the pool over time, where the proportional coefficient is 1 and the differential coefficient is 0.1. Please help me implement a modelica model named `PDController`.\n\n//modelica\n```model PDController",
            "input": "",
            "output": "model PDController\n  parameter Real Kp=1 \"Proportional coefficient\";\n  parameter Real Kd=0.1 \"Differential coefficient\";\n  parameter Real target_height=1 \"Target altitude\";\n  \n  Real waterLevel(start=0.2) \"Actual altitude\";\n  Real error \"Altitude error\";\n  Real Pcontrol \"Proportional Control signal\", Dcontrol \"Differential Control signal\";\n  \nequation\n  error = target_height - waterLevel;\n  Pcontrol = Kp * error;\n  Dcontrol = Kd * der(error);\n  der(waterLevel) = Pcontrol + Dcontrol;\n  \nend PDController;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 96,
            "instruction": "We have a container, and we want to keep the height of the water in the container at 1 meter. The water height in the pool starts at 0.2m. Use PID control to implement the above control system and simulate the change of the water level in the pool over time with a proportional coefficient of 1, an integral coefficient of 0.5, and a differential coefficient of 0.1. Please help me implement a modelica model named `PIDController`.\n\n//modelica\n```model PIDController",
            "input": "",
            "output": "model PIDController\n  parameter Real Kp=1 \"Proportional coefficient\";\n  parameter Real Ki=0.2 \"Integral coefficient\";\n  parameter Real Kd=0.1 \"Differential coefficient\";\n  parameter Real target_height=1 \"Target altitude\";\n  \n  Real waterLevel(start=0.2) \"Actual altitude\";\n  Real error \"Altitude error\";\n  Real Pcontrol \"Proportional Control signal\", Icontrol \"Integral Control signal\", Dcontrol \"Differential Control signal\";\n  \nequation\n  error = target_height - waterLevel;\n  Pcontrol = Kp * error-0.1;\n  error = der(Icontrol/Ki);\n  Dcontrol = Kd * der(error);\n  der(waterLevel) = Pcontrol + Icontrol + Dcontrol;\n  \nend PIDController;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 97,
            "instruction": "Suppose we have a hydraulic system consisting of two oil storage tanks and a cylindrical connecting pipe. It is known that the density of oil in the tank is rho=0.2; The initial height of the liquid in the left tank is 0.4 and the cross-sectional area is 1; The initial height of the liquid in the right tank is 0.6 and the cross-sectional area is 2. The connection pipe has a length of 0.1 and a radius of 0.2, and the Dynamic Viscosity of the oil is 2e-3. Please help me implement the modelica model named `TwoTanks` of this system.\n\n//modelica\n```model TwoTanks",
            "input": "",
            "output": "model TwoTanks \"Hydraulic system involving two tanks\"\n  import Modelica.Units.SI;\n  \n  //constants\n  constant Real pi = Modelica.Constants.pi;\n  constant Real g = Modelica.Constants.g_n;\n  \n  //parameters\n  parameter Modelica.Units.SI.Length L = 0.1 \"Pipe length\";\n  parameter Modelica.Units.SI.Length D = 0.2 \"Pipe diameter\";\n  parameter Modelica.Units.SI.Density rho = 0.2 \"Fluid density\";\n  parameter Modelica.Units.SI.DynamicViscosity mu = 2e-3;\n  parameter Modelica.Units.SI.Area A1 = 1.0 \"Area of left tank\";\n  parameter Modelica.Units.SI.Area A2 = 2.0 \"Area of right tank\";\n  parameter Modelica.Units.SI.KinematicViscosity c = (pi*D^4)/(128*mu*L);\n  \n  //variables\n  Modelica.Units.SI.Pressure P1,P2;\n  Modelica.Units.SI.Length H1(start=0.4),H2(start=0.6);\n  Modelica.Units.SI.VolumeFlowRate Q;\n\nequation\n  //Pressure equations\n  P1 = rho*H1*g;\n  P2 = rho*H2*g;\n  \n  //Flow rate\n  Q = c*(H1-H2);\n  \n  //conservation of mass\n  A1*der(H1) = -Q;\n  A2*der(H2) = Q;\n  \nend TwoTanks;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 98,
            "instruction": "Suppose we have a simple vibration system consisting of a spring, a damper, and a mass that moves in a vertical direction without external forces. The spring spring coefficient is k=1, the damping coefficient is c=0.1, and the particle mass is m=1. Please help me implement the modelica model named `SpringMassDamper` corresponding to the above system.\n\n//modelica\n```model SpringMassDamper",
            "input": "",
            "output": "model SpringMassDamper \"Spring mass damping system\"\n  parameter Real k = 1 \"Spring stiffness\";\n  parameter Real m = 1 \"Mass\";\n  parameter Real c = 0.1 \"Damping coefficient\";\n  parameter Real F0 = 0 \"External force\";\n  \n  Real x(start=0) \"Displacement\";\n  Real v \"Velocity\";\n  Real F \"Force applied to the mass\";\n\nequation\n  // Equation of motion of spring-mass-damping system\n  F = -k * x - c * v + F0; // The resultant force of the spring and the damping force\n  m * der(v) = F; // newton's second law\n  der(x) = v;\n\nend SpringMassDamper;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 99,
            "instruction": "Simulate the flow of fluid through a pipe. The known pressure at both ends of the pipeline is P1=1080, P2=900; The pipe length and inner diameter were L=1, D=0.05, respectively. The kinematic viscosity of the fluid in the pipe is mu = 2e-3. Please help me realize the modelica model named `Pipe` corresponding to the above system and calculate the flow and velocity in the pipeline.\n\n//modelica\n```model Pipe",
            "input": "",
            "output": "model Pipe\n  // This model represents a simple pipe with fluid flowing through it.\n  // Parameters\n  parameter Modelica.Units.SI.Length L = 1 \"Length of the pipe\";\n  parameter Modelica.Units.SI.Length D = 0.05 \"Diameter of the pipe\";\n  parameter Modelica.Units.SI.Pressure P1 = 1080 \"Pressure at the start of the pipe\";\n  parameter Modelica.Units.SI.Pressure P2 = 900\"Pressure at the end of the pipe\";\n  parameter Modelica.Units.SI.DynamicViscosity mu = 2e-3;\n  \n  // Variables\n  Modelica.Units.SI.KinematicViscosity c;\n  Modelica.Units.SI.Volume Q \"Volume through the pipe\";\n  Modelica.Units.SI.VolumeFlowRate v \"Volumetric flow rate through the pipe\";\n  // Equations\n  equation\n  // Continuity equation\n    c = (Modelica.Constants.pi*D^4)/(128*mu*L);\n    Q = (P1 - P2)*c;\n    v = 4*Q / (Modelica.Constants.pi*D^2);\nend Pipe;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 100,
            "instruction": "Please simulate the temperature change of platinum resistance in the medium. It is known that the temperature of the measured medium is stable at 100°C, the volume of the platinum resistance sensor is V=1.15*10^(-9), the comprehensive specific heat is c=456, the sensor surface area is Ar=5.31*10^(-6), the convective heat transfer coefficient between the sensor and the medium is alpha=800, and the comprehensive density of the sensor is pho=7980. The initial temperature of the sensor is known to be 25 °C. Please simulate the change of the temperature of the sensor with time. Please help me realize the modelica model named `RTD_Pt100` corresponding to the above system.\n\n//modelica\n```model RTD_Pt100",
            "input": "",
            "output": "model RTD_Pt100 \"A Thermal resistance temperature measurement model\"\n\n  //type\n  type Time = Real (unit=\"s\");\n  type Voltage = Real(unit = \"V\");\n  type Volume = Real(unit = \"m3\");\n  type Density = Real(unit = \"kg/m3\", min = 0.0);\n  type Current = Real(unit = \"A\");\n  type Resistance = Real(unit = \"Ohm\");\n  type Area = Real(unit = \"m2\");\n  type ThermodynamicTemperature = Real(unit = \"℃\");\n  type CoefficientOfHeatTransfer = Real(unit = \"W/(m2.K)\");\n  type SpecificHeatCapacity = Real(unit = \"J/(kg.K)\");\n\n  //parameters\n  input ThermodynamicTemperature Tg(start=100) \"Temperature of the medium to be measured\";\n  parameter Volume V=1.15*10^(-9) \"Sensor volume\";\n  parameter SpecificHeatCapacity c=456 \"The combined specific heat capacity of the sensor\";\n  parameter Area Ar=5.31*10^(-6) \"Surface area of sensor\";\n  parameter CoefficientOfHeatTransfer alpha=800 \"Surface heat exchange coefficient between sensor and medium\";\n  parameter Density pho=7980 \"Sensor synthesis and density\";\n  output ThermodynamicTemperature Tj(start=25) \"Sensor temperature\";\n\nequation\n  pho * V * c * der(Tj) = alpha * Ar * (Tg - Tj) \"Thermal conductivity equation\";\n  \nannotation(\n    uses(Modelica(version = \"4.0.0\")));\nend RTD_Pt100;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 101,
            "instruction": "Implement the modelica function named `Rt_T` for solving the temperature characteristics of platinum resistance. The input is the current temperature T and the output is the resistance value Rt of the platinum resistor. It is known that the resistance value of platinum resistance at 0 is R0=100 ohms. When (T>=0) and (T<850), Rt=R0*(1+A*T+B*T^2); When (T>-200) and (T<0), Rt=R0*(1+T+A*B*T^2+C*T^3*(T-100). A, B and C are constants, A=3.9083*10^(-3), B=-5.775*10^(-7), C=-4.183*10^(-12).\n\n//modelica\n```function Rt_T",
            "input": "",
            "output": "function Rt_T \"Pt100 resistance Temperature characteristic function\"\n  input Real T;\n  output Real Rt;\n  protected Modelica.Units.SI.Resistance R0=100;\n  protected Real A=3.9083*10^(-3),B=-5.775*10^(-7),C=-4.183*10^(-12);\nalgorithm\n  if (T>=0) and (T<850) then\n    Rt:=R0*(1+A*T+B*T^2);\n  elseif (T>-200) and (T<0) then\n    Rt:=R0*(1+A*T+B*T^2+C*T^3*(T-100));\n  end if;\nend Rt_T;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 102,
            "instruction": "Implement a modelica function named `PotentialEnergy` for solving gravitational potential energy, where the input is mass m, height h and gravitational acceleration g, and the output is the gravitational potential energy of the object.\n\n//modelica\n```function PotentialEnergy",
            "input": "",
            "output": "function PotentialEnergy\n  input Real m \"mass\";\n  input Real h \"height\";\n  input Real g=9.81 \"gravity\";\n  output Real pe \"potential energy\";\nalgorithm\n  pe := m*g*h;\nend PotentialEnergy;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 103,
            "instruction": "Implement the modelica function named `CircleProperties` for solving the circumference and area of a circle, where the input is the radius r of the circle and the output is the circumference and area of the circle.\n\n//modelica\n```function CircleProperties",
            "input": "",
            "output": "function CircleProperties\n  input Real radius;\n  output Real circumference;\n  output Real area;\nprotected\n  Real diameter := radius*2;\nalgorithm\n  circumference := 3.14159*diameter;\n  area := 3.14159*radius^2;\nend CircleProperties;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 104,
            "instruction": "Implement the modelica function named `SphereProperties` for solving the surface area and volume of the sphere, where the input is the radius r of the sphere and the output is the surface area and volume of the sphere.\n\n//modelica\n```function SphereProperties",
            "input": "",
            "output": "function SphereProperties\n  input Real radius;\n  output Real surface;\n  output Real volume;\nalgorithm\n  surface := 4*Modelica.Constants.pi*radius^2;\n  volume := 4/3*Modelica.Constants.pi*radius^3;\nend SphereProperties;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 105,
            "instruction": "Define an array of length 5, and solve for the absolute value, minimum value, maximum value, and sum value of all elements of the array. Please help me generate a modelica model named `ArrayExample` to do this.\n\n//modelica\n```model ArrayExample",
            "input": "",
            "output": "model ArrayExample\n  parameter Integer n = 5;\n  Real data[n] = {1, 2, 3, 4, 5}; // Define an array of real numbers of size n and initialize it.\n  Real abs1[n],sum1,min1,max1;\nequation\n  abs1 = abs(data); // Computes the absolute value of array elements.\n  min1 = min(data); // Computes the minimum value of array elements.\n  max1 = max(data); // Computes the maximum value of array elements.\n  sum1 = sum(data); // Computes the sum of array elements.\nend ArrayExample;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 106,
            "instruction": "Solve algebraic differential equations der(y) + (1+0.5*sin(y))*der(x) = sin(time);   x-y = exp(-0.9*x)*cos(y);  the initial value of 'x' is 0.9. Please help me generate a modelica class named `DAEexample` to do this.\n\n//modelica\n```class DAEexample",
            "input": "",
            "output": "class DAEexample\n  Real x(start=0.9);\n  Real y;\nequation\n  der(y) + (1+0.5*sin(y))*der(x) = sin(time);\n  x-y = exp(-0.9*x)*cos(y);\nend DAEexample;\n",
            "type": "class",
            "feature": ""
        },
        {
            "id": 107,
            "instruction": "To solve the sum of all integers from 1 to n, please help me implement a modelica algorithm model named `Summation` to accomplish this function.\n\n//modelica\n```model Summation",
            "input": "",
            "output": "model Summation\n  Integer n = 10;\n  Real sum;\nalgorithm\n  sum := 0;\n  for i in 1:n loop\n    sum := sum + i;\n  end for;\nend Summation;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 108,
            "instruction": "Use the modelica model named `VanDerPol` to implement a van der Pol oscillator with the parameter lambda = 0.3.\n\n//modelica\n```model VanDerPol",
            "input": "",
            "output": "// Van der Pol oscillator\nmodel VanDerPol \"Van der Pol oscillator model\"\n  Real x(start=1) \"Descriptive string for x\";\n  Real y(start=1) \"Descriptive string for y\";\n  parameter Real lambda = 0.3;\nequation\n  // Differential equations\n  der(x) = y;\n  der(y) = -x+lambda*(1-x*x)*y;\nend VanDerPol;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 109,
            "instruction": "Use the modelica model named `Lorenz`to implement a Lorentz system.\n\n//modelica\n```model Lorenz",
            "input": "",
            "output": "model Lorenz \"Lorenz system\"\n  parameter Real sigma=10;\n  parameter Real rho=28;\n  parameter Real beta=8/3;\n\n  parameter Real x0=1 \"initial value of x\";\n  parameter Real y0=1 \"initial value of y\";\n  parameter Real z0=1 \"initial value of z\";\n\n  Real x \"x-coordinate\";\n  Real y \"y-coordinate\";\n  Real z \"z-coordinate\";\ninitial equation\n  x = x0;\n  y = y0;\n  z = z0;\nequation\n  der(x) = sigma*(y - x);\n  der(y) = x*(rho - z) - y;\n  der(z) = x*y - beta*z;\n  annotation (experiment(\n      StopTime=20,\n      Interval=0.01,\n      __Dymola_Algorithm=\"Dassl\"));\nend Lorenz;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 110,
            "instruction": "Develop a Modelica function named `PolynomialWithDerivative` that creates a generic polynomial from coefficients (with derivative information). The functionality of this function is to compute a polynomial value based on the input x and an array of coefficients. Inputs include a real number 'x' which is the independent variable, and a real array 'c' which consists of polynomial coefficients. The output is a real number 'y', representing the computed polynomial value. This function includes a protected variable 'n = size(c,1)', Integer, which is used to calculate the size of the array. In the algorithm section, this function calculates the polynomial using a loop that iterates over the coefficients, updating the polynomial calculation with each coefficient. The previous term corresponds to a higher power of x.\n\n//modelica\n```function PolynomialWithDerivative",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Functions.Polynomials.PolynomialWithDerivative",
            "output": "within ModelicaByExample.Functions.Polynomials;\nfunction PolynomialWithDerivative\n  \"Create a generic polynomial from coefficients (with derivative information)\"\n  input Real x     \"Independent variable\";\n  input Real c[:]  \"Polynomial coefficients\";\n  output Real y    \"Computed polynomial value\";\nprotected\n  Integer n = size(c,1);\nalgorithm\n  y := c[1];\n  for i in 2:n loop\n y := y*x + c[i];\n  end for\n  ;\nend PolynomialWithDerivative;\n",
            "type": "function",
            "feature": ""
        },
        {
            "id": 111,
            "instruction": "Generate a Modelica model named `Capacitor` for a DRY capacitor within an electrical system. The model should have a capacitance parameter 'C' with units in Farads. This capacitor extends the 'ModelicaByExample.Components.Electrical.DryApproach.TwoPin' model, functioning to relate the current 'i' and the voltage rate of change 'der(v)' through the equation 'C*der(v) = i'. Ensure accurate representation of this component's functionality and parameters in the system.\n\n//modelica\n```model Capacitor",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Components.Electrical.DryApproach.Capacitor",
            "output": "within ModelicaByExample.Components.Electrical.DryApproach;\nmodel Capacitor \"A DRY capacitor model\"\n  parameter Modelica.SIunits.Capacitance C;\n  extends TwoPin;\nequation\n  C*der(v) = i\n  ;\nend Capacitor;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Capacitor completed successfully.\nClass Capacitor has 6 equation(s) and 6 variable(s).\n4 of these are trivial equation(s)."
        },
        {
            "id": 112,
            "instruction": "Create a Modelica model named `IndependentSampling`. The model includes real type parameters 'x', 'y', 'e' and 'next_time'. This model specifically demonstrates the technique of independent sampling where two variables, 'x' and 'y', are sampled at 10Hz using different methods. The model should compute the error 'e' as the difference between 'x' and 'y'. Additionally, 'x' is a direct sample, manage the sampling rate for 'y' using a variable 'next_time' which updates every 0.1 seconds based on the previous 'next_time', when {initial(), time>pre(next_time)} then 'y' sample. This model is crucial for systems that require synchronization of separate processes that are sampled at the same rate but initiated differently.\n\n//modelica\n```model IndependentSampling",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.DiscreteBehavior.SynchronousSystems.IndependentSampling",
            "output": "within ModelicaByExample.DiscreteBehavior.SynchronousSystems;\nmodel IndependentSampling \"Sampling independently\"\n  Real x \"Sampled at 10Hz via one method\";\n  Real y \"Sampled at 10Hz via another method\";\n  Real e \"Error between x and y\";\n  Real next_time \"Next sample for y\";\nequation\n  when sample(0,0.1) then\n x = time;\n  end when;\n\n  when {initial(), time>pre(next_time)} then\n y = time;\n next_time = pre(next_time)+0.1;\n  end when;\n  e = x-y;\nend IndependentSampling;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 113,
            "instruction": "Generate a Modelica model named `SubsamplingWithIntegers` to implement subsampling using integers. The model should count clock ticks and update three output variables x, y, and z based on the clock ticks.\n\n# Parameters:\n - `tick`: Integer, counts the number of clock ticks.\n - `x`: Real, captures the current simulation time when the clock tick changes.\n - `y`: Real, captures the current simulation time when the clock tick changes.\n - `z`: Real, captures the current simulation time when the clock tick satisfies a modulo condition.\n\n# Equations:\n - The model uses `when` statements to trigger updates based on clock ticks:\n - `tick` is incremented every 0.1 seconds.\n - `x` and `y` are updated with the current time whenever `tick` changes.\n - `z` is updated with the current time when `(tick-1) mod 2 == 0`.\n\n//modelica\n```model SubsamplingWithIntegers",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.DiscreteBehavior.SynchronousSystems.SubsamplingWithIntegers",
            "output": "within ModelicaByExample.DiscreteBehavior.SynchronousSystems;\nmodel SubsamplingWithIntegers \"Use integers to implement subsampling\"\n  Integer tick \"Clock counter\";\n  Real x, y, z;\nequation\n  when sample(0,0.1) then\n tick = pre(tick)+1;\n  end when;\n\n  when change(tick) then\n x = time;\n  end when;\n\n  when change(tick) then\n y = time;\n  end when;\n\n  when mod(tick-1,2)==0 then\n z = time;\n  end when;\nend SubsamplingWithIntegers;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 114,
            "instruction": "Create a Modelica model named `NewtonCooling` for Newton's law of cooling. Key parameters include ambient temperature (Temperature T_inf=300.0), initial temperature (Temperature T0=280.0), convective cooling coefficient (ConvectionCoefficient h=0.7), surface area (Area A=1.0), mass of thermal capacitance (Mass m=0.1), and specific heat capacity (SpecificHeat c_p=1.2). The output should be the temperature change over time, governed by the formula m*c_p*der(T) = h*A*(T_inf-T), depicting the cooling process. This model is commonly used in thermal analysis to understand the cooling dynamics of objects exposed to an environment with a different temperature.\n\n//modelica\n```model NewtonCooling",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.PackageExamples.NewtonCooling",
            "output": "within ModelicaByExample.PackageExamples;\nmodel NewtonCooling\n  \"Cooling example importing physical types from the Modelica Standard Library\"\n  import Modelica.SIunits.Temperature;\n  import Modelica.SIunits.Mass;\n  import Modelica.SIunits.Area;\n  import ConvectionCoefficient = Modelica.SIunits.CoefficientOfHeatTransfer;\n  import SpecificHeat = Modelica.SIunits.SpecificHeatCapacity;\n\n  // Parameters\n  parameter Temperature T_inf=300.0 \"Ambient temperature\";\n  parameter Temperature T0=280.0 \"Initial temperature\";\n  parameter ConvectionCoefficient h=0.7 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=0.1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=1.2 \"Specific heat\";\n\n  // Variables\n  Temperature T \"Temperature\";\ninitial equation\n  T = T0 \"Specify initial value for T\";\nequation\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCooling;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 115,
            "instruction": "Generate a Modelica model that represents a step voltage source. The model should extend the `ModelicaByExample.Components.Electrical.DryApproach.TwoPin` class and be compatible with Modelica version 3.2.3. The model should have three parameters: `V0` (initial voltage) and `Vf` (final voltage), both of type `Modelica.SIunits.Voltage`, and `stepTime` of type `Modelica.SIunits.Time`. The voltage output `v` should switch from `V0` to `Vf` at `stepTime`. The model's name should be `StepVoltage`.\n\n//modelica\n```model StepVoltage",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Components.Electrical.DryApproach.StepVoltage",
            "output": "within ModelicaByExample.Components.Electrical.DryApproach;\nmodel StepVoltage \"A DRY step voltage source\"\n  parameter Modelica.SIunits.Voltage V0;\n  parameter Modelica.SIunits.Voltage Vf;\n  parameter Modelica.SIunits.Time stepTime;\n  extends TwoPin;\nequation\n  v = if time>=stepTime then Vf else V0\n  ;\nend StepVoltage;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of StepVoltage completed successfully.\nClass StepVoltage has 6 equation(s) and 6 variable(s).\n5 of these are trivial equation(s)."
        },
        {
            "id": 116,
            "instruction": "Develop a State space version of an RLC circuit Modelica model named `RLC` where the circuit parameters are: voltage source 'Vb' is 24 volts, inductor 'L' is 1 Henry, resistor 'R' is 100 ohms, and capacitor 'C' is 0.001 Farads. The State space model should use the `ModelicaByExample.ArrayEquations.StateSpace.LTI` component 'rlc_comp' with 'nx=2' state variables, 'nu=1' input, 'ny=2' outputs, initial state' x0={0, 0}', matrices 'A=[-1/(R*C), 1/C; -1/L, 0], B=[0; 1/L], C=[1/R, 0; -1/R, 1], and D=[0; 0]'. Connect the input 'u' of LTI component to the voltage source.\n\n//modelica\n```model RLC",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.ArrayEquations.StateSpace.Examples.RLC",
            "output": "within ModelicaByExample.ArrayEquations.StateSpace.Examples;\nmodel RLC \"State space version of an RLC circuit\"\n  parameter Real Vb=24;\n  parameter Real L=1;\n  parameter Real R=100;\n  parameter Real C=1e-3;\n  LTI rlc_comp(nx=2, nu=1, ny=2, x0={0,0},\n A=[-1/(R*C), 1/C; -1/L, 0],\n B=[0; 1/L],\n C=[1/R, 0; -1/R, 1],\n D=[0; 0]);\nequation\n  rlc_comp.u = {Vb};\nend RLC;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 117,
            "instruction": "Create a Modelica model named `SecondOrderSystem` representing a second order rotational system. The model should import `Modelica.SIunits.*`.\nThe model includes parameters for initial angles (`phi1_init=0`, `phi2_init=1`) of type 'Angle', initial angular velocities (`omega1_init=0`, `omega2_init=0`) of type 'AngularVelocity', inertias (`J1=0.4`, `J2=1.0`) of type 'Inertia', 'RotationalSpringConstant' (`c1=11`, `c2=5`), and 'RotationalDampingConstant' (`d1=0.2`, `d2=1.0`). The model includes parameters Angle phi1, Angle phi2, AngularVelocity omega1, AngularVelocity omega2.\nInclude initial equations to set `phi1`, `phi2`, `omega1`, and `omega2` to their respective initial values.\nThe model should define the equations for `omega1`, `omega2` equals to derivatives `der(phi1)`, `der(phi2)`, 'J1*der(omega1) = c1*(phi2-phi1)+d1*der(phi2-phi1)', 'J2*der(omega2) = c1*(phi1-phi2)+d1*der(phi1-phi2)-c2*phi2-d2*der(phi2)', ensuring proper dynamics between the connected rotational components.\n\n//modelica\n```model SecondOrderSystem",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.PackageExamples.SecondOrderSystem",
            "output": "within ModelicaByExample.PackageExamples;\nmodel SecondOrderSystem\n  \"A second order rotational system importing types from Modelica Standard Library\"\n  import Modelica.SIunits.*;\n  parameter Angle phi1_init = 0;\n  parameter Angle phi2_init = 1;\n  parameter AngularVelocity omega1_init = 0;\n  parameter AngularVelocity omega2_init = 0;\n  parameter Inertia J1=0.4;\n  parameter Inertia J2=1.0;\n  parameter RotationalSpringConstant c1=11;\n  parameter RotationalSpringConstant c2=5;\n  parameter RotationalDampingConstant d1=0.2;\n  parameter RotationalDampingConstant d2=1.0;\n  Angle phi1;\n  Angle phi2;\n  AngularVelocity omega1;\n  AngularVelocity omega2;\ninitial equation\n  phi1 = phi1_init;\n  phi2 = phi2_init;\n  omega1 = omega1_init;\n  omega2 = omega2_init;\nequation\n  omega1 = der(phi1);\n  omega2 = der(phi2);\n  J1*der(omega1) = c1*(phi2-phi1)+d1*der(phi2-phi1);\n  J2*der(omega2) = c1*(phi1-phi2)+d1*der(phi1-phi2)-c2*phi2-d2*der(phi2);\nend SecondOrderSystem;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 118,
            "instruction": "Generate a Modelica model that implements an on-off actuator for a thermal control system. The model should be named `ConventionOnOffActuator` and extend from the `ModelicaByExample.Architectures.ThermalControl.Interfaces.Actuator` model. The actuator should have a parameter `heating_capacity` of type `Real`, representing the heating capacity of the actuator. Internally, the model should include a `Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow` component named `heater` to model the heat flow, and a `Modelica.Blocks.Math.BooleanToReal` component named `command` with redeclared parameters 'realTrue=heating_capacity' and 'realFalse=0'. The model should include connections between `heater.port` and an external `furnace` interface, as well as between `command.y` and `heater.Q_flow` to regulate the heat flow.\n\n//modelica\n```model ConventionOnOffActuator",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.ThermalControl.Implementations.ConventionOnOffActuator",
            "output": "within ModelicaByExample.Architectures.ThermalControl.Implementations;\nmodel ConventionOnOffActuator \"Attempt to implement on-off actuator\"\n  extends Interfaces.Actuator;\n  parameter Real heating_capacity \"Heating capacity of actuator\";\nprotected\n  Modelica.Thermal.HeatTransfer.Sources.PrescribedHeatFlow heater\n ;\n  Modelica.Blocks.Math.BooleanToReal command(realTrue=heating_capacity,\n   realFalse=0)\n ;\nequation\n  connect(heater.port, furnace) ;\n  connect(command.y, heater.Q_flow) \n  ;\nend ConventionOnOffActuator;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of ConventionOnOffActuator completed successfully.\nClass ConventionOnOffActuator has 6 equation(s) and 7 variable(s).\n4 of these are trivial equation(s)."
        },
        {
            "id": 119,
            "instruction": "Generate a Modelica model named `Reactions_Array`for simulating chemical reactions using arrays. This model should accurately represent a chemical reaction dynamics by using arrays to handle multiple reaction components simultaneously. The model inputs include concentrations of chemicals as a real array 'C[3]', and reaction rate constants as a parameter array 'k[3]' with default values {0.1, 0.1, 10}. The model should initiate with an initial concentration array 'C = {1, 1, 0}'. The output should be the rate of change of concentrations, governed by the differential equations set in the 'equation' section. The value of 'der(C)' is determined by '{-k[1]*C[1]*C[2] + k[2]*C[3], -k[1]*C[1]*C[2] + k[2]*C[3] - k[3]*C[2]*C[3], k[1]*C[1]*C[2] -k [2]*C[3] -k [3]*C[2]*C[3]}'.\n\n//modelica\n```model Reactions_Array",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.ArrayEquations.ChemicalReactions.Reactions_Array",
            "output": "within ModelicaByExample.ArrayEquations.ChemicalReactions;\nmodel Reactions_Array \"Modeling a chemical reaction with arrays\"\n  Real C[3];\n  parameter Real k[3] = {0.1, 0.1, 10};\ninitial equation\n  C = {1, 1, 0};\nequation\n  der(C) = {-k[1]*C[1]*C[2] + k[2]*C[3],\n -k[1]*C[1]*C[2] + k[2]*C[3] - k[3]*C[2]*C[3],\n k[1]*C[1]*C[2] - k[2]*C[3] - k[3]*C[2]*C[3]};\nend Reactions_Array;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 120,
            "instruction": "Generate a Modelica model named `Variant1_unstable` that simulates an unstable scenario based on the choice of a sample interval. Specifically, it should extend `ModelicaByExample.Architectures.SensorComparison.Examples.Variant1` with a modified `sensor` component that uses a parameter `sample_time=0.036`.\n\n//modelica\n```model Variant1_unstable",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.SensorComparison.Examples.Variant1_unstable",
            "output": "within ModelicaByExample.Architectures.SensorComparison.Examples;\nmodel Variant1_unstable \"Choice of sample interval that creates an instability\"\n  extends Variant1(sensor(sample_time=0.036));\nend Variant1_unstable;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 121,
            "instruction": "Generate a Modelica model named `Variant2_tuned` for a tuned version of Variant 2. The model should be compatible with Modelica version 3.2.3. Specifically, extend the 'ModelicaByExample.Architectures.SensorComparison.Examples.Variant2' model with the following adjusted components redeclared for enhanced performance. Set the 'controller' component with yMax=50, Ti=0.07, Td=0.01, k=4, and the 'actuator' component with uMax=50, along with a 'sensor' components with sample_time=0.01. This model serves to demonstrate improved sensor and control dynamics in testing different architecture scenarios.\n\n//modelica\n```model Variant2_tuned",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.SensorComparison.Examples.Variant2_tuned",
            "output": "within ModelicaByExample.Architectures.SensorComparison.Examples;\nmodel Variant2_tuned \"A tuned up version of variant 2\"\n  extends Variant2(\n controller(yMax=50, Ti=0.07, Td=0.01, k=4),\n actuator(uMax=50),\n sensor(sample_time=0.01));\nend Variant2_tuned;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 122,
            "instruction": "Generate a Modelica model named `LimitedActuator` for an actuator with lag and saturation.\n\nThe model should extend the `ModelicaByExample.Architectures.SensorComparison.Interfaces.Actuator` and include the following parameters: `delayTime` (of type `Modelica.SIunits.Time`), which represents the delay time of the output with respect to the input signal, and `uMax` (of type `Real`), which represents the upper limit of input signals.\n\nThe model should include the following components in protected part: `Modelica.Mechanics.Rotational.Sources. Torque` with `useSupport=true`, `Modelica.Blocks.Nonlinear.Limiter` with `uMax=uMax`, and `Modelica.Blocks.Nonlinear.FixedDelay` with `delayTime=delayTime`.\n\nThe model's equations should connect these components appropriately, including connecting the `torque.flange` to `shaft`, `torque.support` to `housing`, `limiter.y` to `torque.tau`, `lag.u` to `tau`, and `lag.y` to `limiter.u`.\n\n//modelica\n```model LimitedActuator",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.SensorComparison.Implementation.LimitedActuator",
            "output": "within ModelicaByExample.Architectures.SensorComparison.Implementation;\nmodel LimitedActuator \"An actuator with lag and saturation\"\n  extends Interfaces.Actuator;\n  parameter Modelica.SIunits.Time delayTime\n \"Delay time of output with respect to input signal\";\n  parameter Real uMax \"Upper limits of input signals\";\nprotected\n  Modelica.Mechanics.Rotational.Sources.Torque torque(useSupport=true)\n ;\n  Modelica.Blocks.Nonlinear.Limiter limiter(uMax=uMax)\n ;\n  Modelica.Blocks.Nonlinear.FixedDelay lag(delayTime=delayTime)\n ;\nequation\n  connect(torque.flange, shaft) ;\n  connect(torque.support, housing) ;\n  connect(limiter.y, torque.tau) ;\n  connect(lag.u, tau) ;\n  connect(lag.y, limiter.u) \n  ;\nend LimitedActuator;\n",
            "type": "model",
            "feature": "connect",
            "ref": "f",
            "check_result": "Check of LimitedActuator completed successfully.\nClass LimitedActuator has 15 equation(s) and 15 variable(s).\n13 of these are trivial equation(s)."
        },
        {
            "id": 123,
            "instruction": "Generate a Modelica model named `PID_Controller` for a PID (Proportional-Integral-Derivative) Controller subsystem. The model should:\n\n1. Extends the `ModelicaByExample.Architectures.SensorComparison.Interfaces.Controller`.\n2. The model includes the following parameters :\n - Real 'k' is Gain of controller;\n -Modelica.SIunits.Time 'Ti' is Time constant of Integrator block;\n - Modelica.SIunits.Time 'Td' isTime constant of Derivative block;\n - Real 'yMax' is Upper limit of output.\n3. Utilize a 'Modelica.Blocks.Continuous.LimPID' block named 'PID' to manage the PID control logic, configured with specific parameters for controller gain (k), time constant of the Integrator block (Ti), time constant of the Derivative block (Td), and an upper limit of output (yMax).\n4. Include three connected ports: 'setpoint' (connect to PID.u_s), 'measured' (connect to PID.u_m), and 'command' (output from PID.y).\n\n//modelica\n```model PID_Controller",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.SensorComparison.Implementation.PID_Controller",
            "output": "within ModelicaByExample.Architectures.SensorComparison.Implementation;\nmodel PID_Controller \"Controller subsystem implemented using a PID controller\"\n  extends Interfaces.Controller;\n  parameter Real k \"Gain of controller\";\n  parameter Modelica.SIunits.Time Ti \"Time constant of Integrator block\";\n  parameter Modelica.SIunits.Time Td \"Time constant of Derivative block\";\n  parameter Real yMax \"Upper limit of output\";\nprotected\n  Modelica.Blocks.Continuous.LimPID PID(k=k, Ti=Ti, Td=Td, yMax=yMax)\n ;\nequation\n  connect(setpoint, PID.u_s) ;\n  connect(measured, PID.u_m) ;\n  connect(PID.y, command) \n  ;\nend PID_Controller;\n",
            "type": "model",
            "feature": "connect"
        },
        {
            "id": 124,
            "instruction": "Generate a Modelica model for a thermal control system with on-off control variation. The model should be compatible with Modelica version 3.2.3. The model, named 'OnOffVariant', should extend from 'ModelicaByExample.Architectures.ThermalControl.Examples.ExpandableModel' and should include two redeclared and replaceable components: an 'ModelicaByExample.Architectures.ThermalControl.Implementations.OnOffActuator' named 'actuator' with 'heating_capacity=500' and an 'ModelicaByExample.Architectures.ThermalControl.Implementations.OnOffControl' named 'controller' with a 'setpoint=300'.\n\n//modelica\n```model OnOffVariant",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Architectures.ThermalControl.Examples.OnOffVariant",
            "output": "within ModelicaByExample.Architectures.ThermalControl.Examples;\nmodel OnOffVariant \"Variation with on-off control\"\n  extends ExpandableModel(\n redeclare replaceable\n   Implementations.OnOffActuator actuator(heating_capacity=500),\n redeclare replaceable\n   Implementations.OnOffControl controller(setpoint=300));\nend OnOffVariant;\n",
            "type": "model",
            "feature": "extends"
        },
        {
            "id": 125,
            "instruction": "Create a Modelica model called `ClassicModel`. This model simulates the dynamics of a predator-prey system using a set of equations. The model should include parameters for the reproduction rate of the prey (alpha=0.1), the mortality rate of the predator per prey (beta=0.02), the general mortality rate of the predator (gamma=0.4), and the reproduction rate of the predator per prey (delta=0.02), each with specified initial values. Include two state variables, x for prey population and y for predator population, with initial conditions set from the parameters x0=10 and y0=10, respectively. The model should use differential equations to describe the change in population over time, where the rate of change of prey population (der(x)) is given by x multiplied by (alpha - beta*y), and the rate of change of predator population (der(y)) is given by y multiplied by (delta*x - gamma). This model is typically used to understand the dynamics of ecosystems and study population control strategies.\n\n//modelica\n```model ClassicModel",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.BasicEquations.LotkaVolterra.ClassicModel",
            "output": "within ModelicaByExample.BasicEquations.LotkaVolterra;\nmodel ClassicModel \"This is the typical equation-oriented model\"\n  parameter Real alpha=0.1 \"Reproduction rate of prey\";\n  parameter Real beta=0.02 \"Mortality rate of predator per prey\";\n  parameter Real gamma=0.4 \"Mortality rate of predator\";\n  parameter Real delta=0.02 \"Reproduction rate of predator per prey\";\n  parameter Real x0=10 \"Start value of prey population\";\n  parameter Real y0=10 \"Start value of predator population\";\n  Real x(start=x0) \"Prey population\";\n  Real y(start=y0) \"Predator population\";\nequation\n  der(x) = x*(alpha-beta*y);\n  der(y) = y*(delta*x-gamma);\nend ClassicModel;\n",
            "type": "model",
            "feature": ""
        },
        {
            "id": 126,
            "instruction": "Generate a Modelica block that computes feedback terms. The model should have two 'ModelicaByExample.Components.BlockDiagrams.Interfaces.RealInput' (u1 and u2) and one 'ModelicaByExample.Components.BlockDiagrams.Interfaces.RealOutput' (y). The equation for the output y is the difference between the inputs u1 and u2. The model should be based on Modelica version 3.2.3 and be named `Feedback`.\n\n//modelica\n```block Feedback",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Components.BlockDiagrams.Components.Feedback",
            "output": "within ModelicaByExample.Components.BlockDiagrams.Components;\nblock Feedback \"A block to compute feedback terms\"\n  Interfaces.RealInput u1\n ;\n  Interfaces.RealInput u2 ;\n  Interfaces.RealOutput y\n ;\nequation\n  y = u1-u2\n  ;\nend Feedback;\n",
            "type": "block",
            "feature": "instantiation"
        },
        {
            "id": 127,
            "instruction": "Generate a Modelica model that represents an 'infinite reservoir' at some ambient temperature. The model should have a parameter named `T_amb` with the type `Modelica.SIunits.Temperature`, representing the ambient temperature. The model should include a heat transfer interface `node` of type `Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a`, and the equation should ensure that the temperature at the `node.T` is equal to `T_amb`. The model should be named `AmbientCondition`.\n\n//modelica\n```model AmbientCondition",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Components.HeatTransfer.AmbientCondition",
            "output": "within ModelicaByExample.Components.HeatTransfer;\nmodel AmbientCondition\n  \"Model of an \\\"infinite reservoir\\\" at some ambient temperature\"\n  parameter Modelica.SIunits.Temperature T_amb \"Ambient temperature\";\n  Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a node ;\nequation\n  node.T = T_amb\n  ;\nend AmbientCondition;\n",
            "type": "model",
            "feature": "instantiation"
        },
        {
            "id": 128,
            "instruction": "Generate a Modelica model named `Damper` for a rotational damper. The model should include a single parameter 'd' of type 'Modelica.SIunits.RotationalDampingConstant' representing the rotational damping constant with units of Newton meters per radian per second. The model should extend 'ModelicaByExample.Components.Rotational.Interfaces.Compliant' and implement an equation for the damping relationship, where the torque 'tau' equals 'd' multiplied by the derivative of 'phi_rel'. This model simulates the damping effect in rotational systems, mitigating oscillations and stabilizing motion.\n\n//modelica\n```model Damper",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.Components.Rotational.Components.Damper",
            "output": "within ModelicaByExample.Components.Rotational.Components;\nmodel Damper \"A rotational damper\"\n  parameter Modelica.SIunits.RotationalDampingConstant d;\n  extends ModelicaByExample.Components.Rotational.Interfaces.Compliant;\nequation\n  tau = d*der(phi_rel) \"Damping relationship\"\n  ;\nend Damper;\n",
            "type": "model",
            "feature": "extends",
            "ref": "f",
            "check_result": "Check of Damper completed successfully.\nClass Damper has 6 equation(s) and 6 variable(s).\n4 of these are trivial equation(s)."
        },
        {
            "id": 129,
            "instruction": "Generate a Modelica model named `FirstOrderExperiment` that defines first order equation with experiment conditions for a simple system. The model should include a real parameter 'x' and initialize 'x=2'. This variable should dynamically change based on the differential equation defined, aiming for the value of 'x' to converge towards 1.0.\n\n//modelica\n```model FirstOrderExperiment",
            "input": "Modelica version: 3.2.3\nSource: ModelicaByExample.BasicEquations.SimpleExample.FirstOrderExperiment",
            "output": "within ModelicaByExample.BasicEquations.SimpleExample;\nmodel FirstOrderExperiment \"Defining experimental conditions\"\n  Real x \"State variable\";\ninitial equation\n  x = 2 \"Used before simulation to compute initial values\";\nequation\n  der(x) = 1-x \"Drives value of x toward 1.0\"\n  ;\nend FirstOrderExperiment;\n",
            "type": "model",
            "feature": ""
        }
    ],
    "instance": [
        {
            "id": 1,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.IntegerType;\nmodel Sub \"Difference of two integer numbers\"\n  extends\n    IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = u1 - u2;\n    end when;\n  else\n     y = u1 - u2;\n  end if;\nend Sub;\n```\nModel description:\nModel of a difference of two integers.\nThe output ( y ) is the difference of the inputs ( u1, u2 ) signals.\n    y = u1 - u2\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compute the difference of two signals u1 and u2, where u1 has the value 5 and u2 has the value 10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Sub\n  IndustrialControlSystems.MathOperations.IntegerType.Sub sub(u1=5,u2=10,Ts=0.1);\n  Integer y;\nequation\n  y=sub.y;\nend Test_Sub;\n",
            "feature": ""
        },
        {
            "id": 2,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.IntegerType;\nmodel Div \"Integer division of two integer numbers\"\n  extends\n    IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nequation\n  assert(u2<>0,\"Division by zero\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = div(u1,u2);\n    end when;\n  else\n     y = div(u1,u2);\n  end if;\nend Div;\n```\nModel description:\nModel of the integer division difference of two integers.\nThe output ( y ) is the integer division of the inputs ( u1, u2 ) signals.\n    y = div(u1,u2)\nIf the input u2 is equal to 0, an error is reported.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compute the integer division difference of two signals u1 and u2, where u1 has the value 5 and u2 has the value 10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Div\n  IndustrialControlSystems.MathOperations.IntegerType.Div div(u1=5,u2=10,Ts=0.1);\n  Integer y;\nequation\n  y=div.y;\nend Test_Div;\n",
            "feature": ""
        },
        {
            "id": 3,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.IntegerType;\nmodel Mod \"Modulus of Integer division of two integer numbers\"\n  extends\n    IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nequation\n  assert(u2<>0,\"Division by zero\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = mod(u1,u2);\n    end when;\n  else\n     y = mod(u1,u2);\n  end if;\nend Mod;\n```\nModel description:\nModel of the modulus of integer division difference of two integers.\nThe output ( y ) is the modulus of the integer division of the inputs ( u1, u2 ) signals.\n    y = mod(u1,u2)\nIf the input u2 is equal to 0, an error is reported.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compute the modulus of integer division difference of two signals u1 and u2, where u1 has the value 5 and u2 has the value 10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Mod\n  IndustrialControlSystems.MathOperations.IntegerType.Mod mod(u1=5,u2=10,Ts=0.1);\n  Integer y;\nequation\n  y=mod.y;\nend Test_Mod;\n",
            "feature": ""
        },
        {
            "id": 4,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.IntegerType;\nmodel Mult \"Product of two integer numbers\"\n  extends\n    IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nequation\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = u1*u2;\n    end when;\n  else\n     y = u1*u2;\n  end if;\nend Mult;\n```\nModel description:\nModel of the product of two integers.\nThe output ( y ) is the product of the inputs ( u1, u2 ) signals.\n    y = u1*u2\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compute the product of two signals u1 and u2, where u1 has the value 5 and u2 has the value 10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Mult\n  IndustrialControlSystems.MathOperations.IntegerType.Mult mult(u1=5,u2=10,Ts=0.1);\n  Integer y;\nequation\n  y=mult.y;\nend Test_Mult;\n",
            "feature": ""
        },
        {
            "id": 5,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.IntegerType;\nmodel Pow \"Power of two integer numbers\"\n  extends\n    IndustrialControlSystems.MathOperations.IntegerType.Interfaces.IntSimpleOperation;\nprotected\n  Real u1R;\n  Real u2R;\n  Real yR;\nequation\n  assert(u1<>0 or u2>0,\"division by zero\");\n\n  // conversion from Integer to Real\n  u1R = u1;\n  u2R = u2;\n  // conversion from Real to Integer\n  y = if (yR > 0) then integer(floor( yR + 0.5)) else\n                       integer(ceil( yR - 0.5));\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      yR = u1R^u2R;\n    end when;\n  else\n     yR = u1R^u2R;\n  end if;\nend Pow;\n```\nModel description:\nModel of the power of two integers.\nThe output ( y ) is the input ( u1 ) to the power of the second input ( u2 ) signals.\n    y = u1 ^ u2\nThe input u1 cannot be equal to zero if the second one, u2, is less than zero.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compute the power of two signals u1 and u2, where u1 has the value 5 and u2 has the value 10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Pow\n  IndustrialControlSystems.MathOperations.IntegerType.Pow pow(u1=5,u2=10,Ts=0.1);\n  Integer y;\nequation\n  y=pow.y;\nend Test_Pow;\n",
            "feature": ""
        },
        {
            "id": 6,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.MathOperations.RealType.Functions;\nfunction toFixedPoint\n  input Real u;\n  input Real scaleFactor;\n  input Integer MAX;\n  input Integer MIN;\n  output Integer y;\nalgorithm\n  if u >= 0 then\n    y := integer(floor(max(MIN, min(MAX, u*scaleFactor)) + 0.5));\n  else\n    y := integer(floor(max(MIN, min(MAX, u*scaleFactor)) - 0.5));\n  end if;\nend toFixedPoint;\n```\nModel description:\nThis function converts a real value to an integer value in fixed-point representation. In digital signal processing and embedded systems, fixed-point representations are often used to process numerical values because they make more efficient use of hardware resources.\n\nPrompt:\nCall this function to calculate the value of the fixed point, where u=3.14159, scaleFactor = 100, MAX = 200, MIN = -200. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_toFixedPoint\n  Integer y;\nequation\n  y = IndustrialControlSystems.MathOperations.RealType.Functions.toFixedPoint(3.14159, 100, 200, -200);\nend Test_toFixedPoint;\n",
            "feature": ""
        },
        {
            "id": 7,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Not \"Model of a n-bit NOT\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=1, nOutput=1);\nequation\n  // for this model nInput has to be equal to nOutput\n  assert(nInput == nOutput, \"nInput has to be equal to nOutput\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = Functions.Not(u, nOutput);\n    end when;\n  else\n     y = Functions.Not(u, nOutput);\n  end if;\nend Not;\n```\nModel description:\nModel of a n bit NOT gate.\nThe number of the input (nInput) signals must be equal to the number of output (nOutput) signals.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"non\" of the signal, where u={false}, y is the array variable, please define as Boolean y[1]. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Not\n  IndustrialControlSystems.Logical.LogicalOperations.Not negation;\n  Boolean u1[1]={false};\n  Boolean y[1];\nequation\n  negation.u = u1;\n  negation.y = y;\nend Test_Not;\n",
            "feature": ""
        },
        {
            "id": 8,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel And \"Model of a n-bit AND\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = Functions.And(u[:], nInput);\n  end when;\n  else\n     y[1] = Functions.And(u[:], nInput);\n  end if;\nend And;\n```\nModel description:\nModel of a n bit AND gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"and\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_And\n  IndustrialControlSystems.Logical.LogicalOperations.And andLogic(nInput=2);\n  Boolean y[1];\nequation\n  andLogic.u[1]=false;\n  andLogic.u[2]=true;\n  y=andLogic.y;\nend Test_And;\n",
            "feature": ""
        },
        {
            "id": 9,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Nand \"Model of a n-bit NAND\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = not Functions.And(u[:], nInput);\n  end when;\n  else\n     y[1] = not Functions.And(u[:], nInput);\n  end if;\nend Nand;\n```\nModel description:\nModel of a n bit NAND gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"nand\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_Nand\n  IndustrialControlSystems.Logical.LogicalOperations.Nand Nand(Ts=0.01);\n  Boolean[2] u1 = {false,true};\n  Boolean y[1];\nequation\n  Nand.u[1] = u1[1];\n  Nand.u[2] = u1[2];\n  y = Nand.y;\nend Test_Nand;\n",
            "feature": ""
        },
        {
            "id": 10,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Or \"Model of a n-bit OR\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = Functions.Or(u[:], nInput);\n  end when;\n  else\n     y[1] = Functions.Or(u[:], nInput);\n  end if;\nend Or;\n```\nModel description:\nModel of a n bit OR gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"or\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_Or\n  IndustrialControlSystems.Logical.LogicalOperations.Or logicOR(Ts=0.1);\n  Boolean u1[2];\n  Boolean y[1];\nequation\n  u1={false, true};\n  logicOR.u=u1;\n  y=logicOR.y;\nend Test_Or;\n",
            "feature": ""
        },
        {
            "id": 11,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Nor \"Model of a n-bit NOR\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = not Functions.Or(u[:], nInput);\n  end when;\n  else\n     y[1] = not Functions.Or(u[:], nInput);\n  end if;\nend Nor;\n```\nModel description:\nModel of a n bit NOR gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"nor\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_Nor\n  IndustrialControlSystems.Logical.LogicalOperations.Nor nor(nInput=2);\n  Boolean y[1];\nequation\n  nor.u[1]=false;\n  nor.u[2]=true;\n  y=nor.y;\nend Test_Nor;\n",
            "feature": ""
        },
        {
            "id": 12,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Xor \"Model of a n-bit XOR\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = Functions.Xor(u[:], nInput);\n  end when;\n  else\n     y[1] = Functions.Xor(u[:], nInput);\n  end if;\nend Xor;\n```\nModel description:\nModel of a n bit XOR gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"xor\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_Xor\n  IndustrialControlSystems.Logical.LogicalOperations.Xor xor(Ts=0.1);\n  Boolean u1[2]={false, true};\n  Boolean y[1];\nequation\n  xor.u=u1;\n  y=xor.y;\nend Test_Xor;\n",
            "feature": ""
        },
        {
            "id": 13,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel Xnor \"Model of a n-bit XNOR\"\n  extends\n    IndustrialControlSystems.Logical.LogicalOperations.Interfaces.LogicalBlock(\n     nInput=2, final nOutput=1);\nequation\n  assert(nInput>=2,\"nIinput must be higher than 2\");\n\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y[1] = not Functions.Xor(u[:], nInput);\n  end when;\n  else\n     y[1] = not Functions.Xor(u[:], nInput);\n  end if;\nend Xnor;\n```\nModel description:\nModel of a n bit XNOR gate.\nThe number of the input (nInput) signals must be higher than 2, while the number of output (nOutput) signals is equal to 1.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to calculate the \"xnor\" of the signal, where u1={false, true}, y is the array variable, please define as the Boolean value y[1]; . Please help me generate this modelica model, you don't need to provide \"within\". Note: \"final\" variables are not allowed to be overridden in reuse.",
            "input": "",
            "output": "model Test_Xnor\n  IndustrialControlSystems.Logical.LogicalOperations.Xnor xnor(Ts=0.1);\n  Boolean u1[2]={false, true};\n  Boolean y;\nequation\n  xnor.u=u1;\n  y=xnor.y[1];\nend Test_Xnor;\n",
            "feature": ""
        },
        {
            "id": 14,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.LogicalOperations;\nmodel FlipFlopSR \"Model of a Set-reset Flip Flop\"\n  extends Interfaces.LogicalBlock2x2;\n  parameter Boolean q_start = false \"Output initial value\";\ninitial equation\n  y1 = q_start;\n  y2 = not q_start;\nequation\n\n  when sample(0,Ts) then\n      y1 = Functions.SR(u1,u2,pre(y1));\n      y2 = not y1;\n  end when;\nend FlipFlopSR;\n```\nModel description:\nModel of a Set Reset Flip Flop.\nThe inputs and outputs follows\nName\tDescription\nu1\tSet\nu2\tReset\ny1\tQ\ny2\tnot Q\nBehaviour of the FlipFlop, at each time step Ts the inputs are read and the new output Q \nis computed starting from the S and R value as well the old value of the output QOLD.\nSet\tReset\tQ\n0\t0\tQOLD\n0\t1\t0\n1\t0\t1\n1\t1\tnot QOLD\n\nPrompt:\nUsing this model to realize the signal Set-reset Flip Flop, where Ts = 0.1, q_start = false, u1 and u2 are using Modelica.Blocks.Sources.BooleanTable to generate signals setSIGNAL and resetSIGNAL.\n(The final signal connection is based on connect(connect(setSIGNAL.y, flipFlopSR.u1); connect(resetSIGNAL.y, flipFlopSR.u2). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FlipFlopSR\n  Modelica.Blocks.Sources.BooleanTable setSIGNAL(startValue=false,\n      table={1,5,8,10,12,15});\n  Modelica.Blocks.Sources.BooleanTable resetSIGNAL(startValue=false,\n      table={6,7,12,14});\n  IndustrialControlSystems.Logical.LogicalOperations.FlipFlopSR flipFlopSR(\n          Ts=0.1,\n          q_start=false);\nequation\n  connect(setSIGNAL.y, flipFlopSR.u1);\n  connect(resetSIGNAL.y, flipFlopSR.u2);\nend Test_FlipFlopSR;\n",
            "feature": ""
        },
        {
            "id": 15,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel Equal \"Equal (==)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 == u2) then true else false;\n    end when;\n  else\n     y = if (u1 == u2) then true else false;\n  end if;\nend Equal;\n```\nModel description:\nModel of a comparison for Integer numbers.\nThe output y is true if the inputs u1 and u2 are equal.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Equal\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.Equal equal(u1=5,u2=10,Ts=0.1);\n  Boolean y;\nequation\n  y=equal.y;\nend Test_Equal;\n",
            "feature": ""
        },
        {
            "id": 16,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel NotEqual \"Not equal (!=)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 == u2) then false else true;\n    end when;\n  else\n     y = if (u1 == u2) then false else true;\n  end if;\nend NotEqual;\n```\nModel description:\nModel of a comparison for Integer numbers.\nThe output y is true if the inputs u1 and u2 differ.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NotEqual\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.NotEqual notequal(u1=5,u2=10,Ts=0.1);\n  Boolean y;\nequation\n  y=notequal.y;\nend Test_NotEqual;\n",
            "feature": ""
        },
        {
            "id": 17,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel Great \"Greather (>)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 > u2) then true else false;\n    end when;\n  else\n     y = if (u1 > u2) then true else false;\n  end if;\nend Great;\n```\nModel description:\nModel of a comparison for Integer numbers.\nThe output y is true if the inputs u1 is higher than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Great\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.Great great(u1=5,u2=10,Ts=0.1);\n  Boolean y;\nequation\n  y=great.y;\nend Test_Great;\n",
            "feature": ""
        },
        {
            "id": 18,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel GreatEq \"Greather or equal (>=)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 >= u2) then true else false;\n    end when;\n  else\n     y = if (u1 >= u2) then true else false;\n  end if;\nend GreatEq;\n```\nModel description:\nModel of a comparison for Integer numbers.\nThe output y is true if the inputs u1 is higher or equal than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_GreatEq\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.GreatEq greatEq(u1=5,u2=10,Ts=0.1);\n  Boolean y;\nequation\n  y=greatEq.y;\nend Test_GreatEq;\n",
            "feature": ""
        },
        {
            "id": 19,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel Less \"Less (<)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 < u2) then true else false;\n    end when;\n  else\n     y = if (u1 < u2) then true else false;\n  end if;\nend Less;\n```\nModel description:\nModel of a comparison for Integer numbers.\nThe output y is true if the inputs u1 is less than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Less\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.Less less(u1=5,u2=10,Ts=0.1);\n  Boolean y;\nequation\n  y=less.y;\nend Test_Less;\n",
            "feature": ""
        },
        {
            "id": 20,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.IntegerType;\nmodel LessEq \"Less or equal (<=)\"\n  extends Interfaces.IntComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 <= u2) then true else false;\n    end when;\n  else\n     y = if (u1 <= u2) then true else false;\n  end if;\nend LessEq;\n```\nModel description:\nModel of comparison for Integer numbers.\nThe output y is true if the inputs u1 is less or equal than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two integers u1 and u2, where u1=5 and u2=10. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LessEq\n  IndustrialControlSystems.Logical.Comparisons.IntegerType.LessEq less_eq(Ts=0.1,u2=10,u1=5);\n  Boolean y;\nequation\n  y = less_eq.y;\nend Test_LessEq;\n",
            "feature": ""
        },
        {
            "id": 21,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel Equal \"Equal (==)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if abs(u1 - u2)<eps then true else false;\n    end when;\n  else\n     y = if abs(u1 - u2)<eps then true else false;\n  end if;\nend Equal;\n```\nModel description:\nModel of a comparison for Real numbers.\nThe output y is true if the inputs u1 and u2 are equal.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealEqual\n  IndustrialControlSystems.Logical.Comparisons.RealType.Equal equal1(eps=0.01,Ts=0.001);\n  Modelica.Blocks.Sources.Sine sine(amplitude=1, f=1);\n  Modelica.Blocks.Sources.Cosine cosine(amplitude=1, f=1, phase=1.57);\nequation\n  connect(sine.y, equal1.u1);\n  connect(cosine.y, equal1.u2);\nend Test_RealEqual;\n",
            "feature": ""
        },
        {
            "id": 22,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel NotEqual \"not equal (!=)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if abs(u1 - u2)<eps then false else true;\n    end when;\n  else\n     y = if abs(u1 - u2)<eps then false else true;\n  end if;\nend NotEqual;\n```\nModel description:\nModel of a comparison for Real numbers.\nThe output y is true if the inputs u1 and u2 differ.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealNotEqual\n  IndustrialControlSystems.Logical.Comparisons.RealType.NotEqual ne(Ts=0.001,eps=0.01);\n  Modelica.Blocks.Sources.Sine sine(f=1);\n  Modelica.Blocks.Sources.Cosine cosine(f=1, amplitude = 1, phase = 1.57);\nequation\n  connect(sine.y,ne.u1) ;\n  connect(cosine.y,ne.u2) ;\nend Test_RealNotEqual;\n",
            "feature": ""
        },
        {
            "id": 23,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel Great \"Greather (>)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 > u2) then true else false;\n    end when;\n  else\n     y = if (u1 > u2) then true else false;\n  end if;\nend Great;\n```\nModel description:\nModel of a comparison for Real numbers.\nThe output y is true if the inputs u1 is higher than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealGreat\n  IndustrialControlSystems.Logical.Comparisons.RealType.Great great(Ts=0.001,eps=0.01);\n  Modelica.Blocks.Sources.Sine Sine(f=1, amplitude=1);\n  Modelica.Blocks.Sources.Cosine Cosine(f=1, amplitude=1, phase=1.57);\n  Boolean y;\nequation\n  connect(great.u1, Sine.y) ;\n  connect(great.u2, Cosine.y) ;\n  y=great.y;\nend Test_RealGreat;\n",
            "feature": ""
        },
        {
            "id": 24,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel GreatEq \"Greather or equal (>=)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 >= u2) then true else false;\n    end when;\n  else\n     y = if (u1 >= u2) then true else false;\n  end if;\nend GreatEq;\n```\nModel description:\nModel of a comparison for Real numbers.\nThe output y is true if the inputs u1 is higher or equal than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealGreatEq\n  IndustrialControlSystems.Logical.Comparisons.RealType.GreatEq greateq(Ts=0.001,eps=0.01);\n  Modelica.Blocks.Sources.Sine Sine(f=1, amplitude=1);\n  Modelica.Blocks.Sources.Cosine Cosine(f=1, amplitude=1, phase=1.57);\n  Boolean y;\nequation\n  connect(greateq.u1, Sine.y) ;\n  connect(greateq.u2, Cosine.y) ;\n  y=greateq.y;\nend Test_RealGreatEq;\n",
            "feature": ""
        },
        {
            "id": 25,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel Less \"Less (<)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 < u2) then true else false;\n    end when;\n  else\n     y = if (u1 < u2) then true else false;\n  end if;\nend Less;\n```\nModel description:\nModel of a comparison for Real numbers.\nThe output y is true if the inputs u1 is less than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealLess\n  IndustrialControlSystems.Logical.Comparisons.RealType.Less less(eps=0.01,Ts=0.001);\n  Modelica.Blocks.Sources.Sine Sine(f=1,amplitude=1);\n  Modelica.Blocks.Sources.Cosine Cosine(f=1,amplitude=1,phase=1.57);\nequation\n  connect(Sine.y, less.u1) ;\n  connect(Cosine.y, less.u2) ;\nend Test_RealLess;\n",
            "feature": ""
        },
        {
            "id": 26,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Comparisons.RealType;\nmodel LessEq \"Less or equal (<=)\"\n  extends Interfaces.RealComparison;\nequation\n  if Ts > 0 then\n    when sample(0,Ts) then\n      y = if (u1 <= u2) then true else false;\n    end when;\n  else\n     y = if (u1 <= u2) then true else false;\n  end if;\nend LessEq;\n```\nModel description:\nModel of comparison for Real numbers.\nThe output y is true if the inputs u1 is less or equal than u2.\nDepending on the value of the sampling time (Ts), the model has two different behaviours:\nTs > 0\nit behaves as a discrete time system,\nTs <= 0\nit behaves as a continous time system. No delay is introduced and events are generated when the output changes (this mode reduces the simulation time)\n\nPrompt:\nUse this model to compare two real signals u1 and u2, where Ts = 0.001; eps = 0.01; u1 is a continuous signal generated by Modelica.Blocks.Sources.Sine, where amplitude is 1, and frequency (f) is 1; u2 is a continuous signal generated by Modelica.Blocks.Sources.Cosine, where amplitude is 1, frequency (f) is 1, and phase Angle (phase) is 1.57. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RealLessEq\n  IndustrialControlSystems.Logical.Comparisons.RealType.LessEq lessEq(Ts=0.001,eps=0.01);\n  Modelica.Blocks.Sources.Sine sine(amplitude=1, f=1, phase=0);\n  Modelica.Blocks.Sources.Cosine cosine(amplitude=1, f=1, phase=1.57);\nequation\n  connect(sine.y, lessEq.u1);\n  connect(cosine.y, lessEq.u2);\nend Test_RealLessEq;\n",
            "feature": ""
        },
        {
            "id": 27,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Counter;\nmodel Counter \"Model of an Up-Down counter\"\n  extends Interfaces.BaseCounter;\n  discrete Integer Value( start=0);\n  discrete Boolean CUd;\n  discrete Boolean CDd;\n  discrete Boolean Sd;\nequation\n  // assertions\n  assert(PV>=0 and PV<=Max, \"Preset Value out of range 0-999\");\n  assert(CV>=0 and CV<=Max, \"Counter Value out of range\");\n\n  CV = Value;\n  when sample(0,Ts) then\n    CUd = CU;\n    CDd = CD;\n    Sd  = S;\n    (Value,Q) = IndustrialControlSystems.Logical.Counter.Functions.count(\n        pre(Value),\n        PV,\n        Sd,\n        pre(Sd),\n        CUd,\n        pre(CUd),\n        CDd,\n        pre(CDd),\n        R,\n        Max);\n  end when;\nend Counter;\n```\nModel description:\nModel of an Up-Down counter.\nS - Set, R - Reset, CU - CountUP, CD - CountDown signals. CV - Current Value and PV - Preset Value.\nAt each time step Ts the inputs are read and the new output values Q and CV are computed.\nThe counter update the CV when the Set signal rises, then for each rising edge of the Count Up (CU) or Count Down (CD) signals the CV is incremented or decremented by 1.\nThe Set signal has to be high during this phase, otherwise the rising edges are not detected.\nWhen the Reset (R) signal rises, the counter is reset to zero.\nConstraints: The current value CV must be\n  0 <= CV <= Max\nWhere Max is the module of the counter.\n\nPrompt:\nUse  this model to the count of signals. \nThe preset value x0 based on Modelica.Blocks.Sources.IntegerConstant implementation, set to k = 5; countUP (table = {10,11,12,13,14,15,16,17,18,19,20,21}), countDOWN (table ={25,26,27,28,29,30}), set (table = {1,40,55}) and reset (table = {50, 51}) based on Modelica.Blocks.Sources.BooleanTable, set up their initial value 'startValue' to false. \nThe connection of the signal is based on 'connect'. \nPlease help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Counter\n  IndustrialControlSystems.Logical.Counter.Counter counter(Max=31,PV = 5, Ts=0.1);\n  Modelica.Blocks.Sources.BooleanTable counterUp(startValue=false, table={10,11,12,13,14,15,16,17,18,19,20,21});\n  Modelica.Blocks.Sources.BooleanTable counterDown(startValue=false, table={25,26,27,28,29,30});\n  Modelica.Blocks.Sources.BooleanTable set(startValue=false, table={1,40,55});\n  Modelica.Blocks.Sources.BooleanTable reset(startValue=false, table={50,51});\nequation\n  connect(counterUp.y, counter.CU);\n  connect(counterDown.y, counter.CD);\n  connect(set.y, counter.S);\n  connect(reset.y, counter.R);\nend Test_Counter;\n",
            "feature": ""
        },
        {
            "id": 28,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Timers;\nmodel Timer_On \"ON timer model\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  discrete Boolean Sd;\ninitial equation\n  startTime = 0;\n  pre(Sd) = false;\nequation\n  Sd = S;\n  when sample(0,Ts) then\n    startTime =\n      IndustrialControlSystems.Logical.Timers.Functions.positiveEdge(\n        pre(Sd),\n        Sd,\n        R,\n        pre(startTime),\n        time);\n    (run,Q) = IndustrialControlSystems.Logical.Timers.Functions.tim(\n        S,\n        R,\n        PV,\n        time,\n        startTime);\n    tr = if Q then PV - (time - startTime) else 0.0;\n  end when;\nend Timer_On;\n\n```\nModel description:\nThe timer is active when the Set signal ( S ) is true.\nThe output ( Q ) of the timer rises up when S becomes true and remains high for PV seconds.\nIf the Set signal become false while counting, the timer stops and the output become false.\nIf the Reset signal ( R ) becomes true, the output becomes false and the timer stops.\n\nPrompt:\nUse this model for timing.\nBoth SetSignal and ResetSignal are implemented by Modelica.Blocks.Sources.BooleanTable, where SetSignal is set to table={0.5,4,6.5}, and ResetSignal is set to table={5,6.5}. \ntimerVALUE is defined by Modelica.Blocks.Sources.Constant, which is set to k=30.\n(The signal connection is based on the connect(SetSignal.y, timer.S); connect(ResetSignal.y,timer.R); connect(timerVALUE.y, timer.PV). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Timer_On\n  IndustrialControlSystems.Logical.Timers.Timer_On timer1;\n  Modelica.Blocks.Sources.Constant timerVALUE(k=30);\n  Modelica.Blocks.Sources.BooleanTable SetSignal(table={0.5,4,6.5});\n  Modelica.Blocks.Sources.BooleanTable ResetSignal(table={5,6.5});\nequation\n  connect(SetSignal.y,timer1.S);\n  connect(ResetSignal.y,timer1.R);\n  connect(timerVALUE.y,timer1.PV);\nend Test_Timer_On;\n",
            "feature": ""
        },
        {
            "id": 29,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Timers;\nmodel Timer_On_Redge \"ON timer model, active on rising edge\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  Boolean S_hold\n    \"This variable is kept on by a rising edge of set signal until a rising edge of reset signal.\";\n  discrete Boolean Sd;\n  discrete Boolean Shd;\ninitial equation\n  startTime = 0;\n  run = false;\nequation\n  when sample(0,Ts) then\n    Sd = S;\n    Shd = S_hold;\n    S_hold = IndustrialControlSystems.Logical.Timers.Functions.hold(\n        pre(Sd),\n        Sd,\n        R,\n        pre(Shd));\n    startTime =\n      IndustrialControlSystems.Logical.Timers.Functions.positiveEdge(\n        pre(Sd),\n        Sd,\n        R,\n        startTime,\n        time);\n    (run,Q) = IndustrialControlSystems.Logical.Timers.Functions.tim(\n        S_hold,\n        R,\n        PV,\n        time,\n        startTime);\n    tr = if (Q) then PV - (time - startTime) else 0.0;\n  end when;\nend Timer_On_Redge;\n```\nModel description:\nThe timer is actived when the set signal ( S ) becomes true (on the rising edge of S ).\nThe output ( Q ) of the timer rises up when S becomes true and remains high for PV seconds.\nIf the Set signal become false while counting, the timer does not stop.\nIf the reset signal ( R ) becomes true (a rising edge is detected) the output becomes false and the timer stops.\n\nPrompt:\nUse this model for timing.\nBoth SetSignal and ResetSignal are implemented by Modelica.Blocks.Sources.BooleanTable, where SetSignal is set to table={0.5,0.6,7,7.1,12,12.1}, and ResetSignal is set to table={5,5.1}. \ntimerVALUE is defined by Modelica.Blocks.Sources.Constant, which is set to k=30.\n(The signal connection is based on the connect(SetSignal.y, timer.S); connect(ResetSignal.y, timer.R); connect(timerVALUE.y, timer.PV). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Timer_On_Redge\n  IndustrialControlSystems.Logical.Timers.Timer_On_Redge timer;\n  Modelica.Blocks.Sources.BooleanTable SetSignal(table={0.5,0.6,7,7.1,12,12.1});\n  Modelica.Blocks.Sources.BooleanTable ResetSignal(table={5,5.1});\n  Modelica.Blocks.Sources.Constant timerVALUE(k=30);\nequation\n  connect(SetSignal.y, timer.S);\n  connect(ResetSignal.y, timer.R);\n  connect(timerVALUE.y, timer.PV);\nend Test_Timer_On_Redge;\n",
            "feature": ""
        },
        {
            "id": 30,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Timers;\nmodel Timer_OffDelay \"OFF delay timer model\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  discrete Boolean Sd;\ninitial equation\n  startTime = 0;\n  run = false;\nequation\n  Sd = S;\n  when sample(0,Ts) then\n    startTime =\n      IndustrialControlSystems.Logical.Timers.Functions.positiveEdge(\n        pre(Sd),\n        Sd,\n        R,\n        startTime,\n        time);\n    (run,Q) = IndustrialControlSystems.Logical.Timers.Functions.odt(\n        S,\n        R,\n        PV,\n        time,\n        startTime);\n    tr = if (not Q) then PV - (time - startTime) else PV;\n  end when;\nend Timer_OffDelay;\n```\nModel description:\nThe timer is active after the set signal ( S ) becomes true.\nThe output ( Q ) of the timer rises up PV seconds after the Set ( S ) becomes true.\nIf the Set signal becomes false while counting, the timer stops and the output remains false.\nIf the Reset signal ( R ) becomes true, the output remains false and the timer stops.\n\nPrompt:\nUse this model for timing.\nBoth SetSignal and ResetSignal are implemented by Modelica.Blocks.Sources.BooleanTable, where SetSignal is set to table={0.5,4,6.5}, and ResetSignal is set to table={5,6.5}. \ntimerVALUE is defined by Modelica.Blocks.Sources.Constant, which is set to k=10.\n(The signal connection is based on the connect(SetSignal.y, timer.S); connect(ResetSignal.y, timer.R); connect(timerVALUE.y, timer.PV). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Timer_OffDelay\n  IndustrialControlSystems.Logical.Timers.Timer_OffDelay timer;\n  Modelica.Blocks.Sources.BooleanTable SetSignal(table={0.5,4,6.5});\n  Modelica.Blocks.Sources.BooleanTable ResetSignal(table={5,6.5});\n  Modelica.Blocks.Sources.Constant timerVALUE(k=10);\nequation\n  connect(SetSignal.y, timer.S);\n  connect(ResetSignal.y, timer.R);\n  connect(timerVALUE.y, timer.PV);\nend Test_Timer_OffDelay;\n",
            "feature": ""
        },
        {
            "id": 31,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Timers;\nmodel Timer_OffDelay_Redge \"OFF delay timer model, active on rising edge\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  discrete Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  discrete Boolean Sd;\ninitial equation\n  startTime = 0;\n  run = false;\nequation\n  when sample(0,Ts) then\n    Sd = S;\n    (startTime,run) =\n      IndustrialControlSystems.Logical.Timers.Functions.risingEdge(\n        pre(Sd),\n        Sd,\n        R,\n        startTime,\n        time,\n        pre(run));\n    Q = IndustrialControlSystems.Logical.Timers.Functions.odts(\n        R,\n        PV,\n        time,\n        startTime,\n        run);\n    tr = if (not Q) and run then PV - (time - startTime) else PV;\n  end when;\nend Timer_OffDelay_Redge;\n```\nModel description:\nThe timer is active after a rising edge of the set signal ( S ).\nThe output ( Q ) of the timer rises up PV seconds after the Set ( S ) becomes true.\nIf the Set signal become false while counting, the timer does not stop.\nIf the Reset signal ( R ) becomes true, the output remains false and the timer stops.\n\nPrompt:\nUse this model for timing.\nBoth SetSignal and ResetSignal are implemented by Modelica.Blocks.Sources.BooleanTable, where SetSignal is set to table={0.5,0.6,17,17.1}, and ResetSignal is set to table={5,5.1,30,30.1}. \ntimerVALUE is defined by Modelica.Blocks.Sources.Constant, which is set to k=10.\n(The signal connection is based on the connect(SetSignal.y, timer.S); connect(ResetSignal.y, timer.R); connect(timerVALUE.y, timer.PV). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Timer_OffDelay_Redge\n  IndustrialControlSystems.Logical.Timers.Timer_OffDelay_Redge timer;\n  Modelica.Blocks.Sources.BooleanTable SetSignal(table={0.5,0.6,17,17.1});\n  Modelica.Blocks.Sources.BooleanTable ResetSignal(table={5,5.1,30,30.1});\n  Modelica.Blocks.Sources.Constant timerVALUE(k=10);\nequation\n  connect(SetSignal.y,timer.S);\n  connect(ResetSignal.y,timer.R);\n  connect(timerVALUE.y,timer.PV);\nend Test_Timer_OffDelay_Redge;\n",
            "feature": ""
        },
        {
            "id": 32,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Logical.Timers;\nmodel Timer_OffDelay_Fedge \"OFF delay timer model, active on falling edge\"\n  extends IndustrialControlSystems.Logical.Timers.Interfaces.BaseResidualTimer;\n  discrete Boolean run \"Flag: true while the timer is counting\";\n  Real startTime \"start time of the timer counting\";\n  discrete Boolean Sd;\ninitial equation\n  startTime = 0;\n  run = false;\nequation\n  when sample(0,Ts) then\n    Sd = S;\n    (startTime,run) =\n      IndustrialControlSystems.Logical.Timers.Functions.fallingEdge(\n        pre(Sd),\n        Sd,\n        R,\n        startTime,\n        time,\n        pre(run));\n    Q = IndustrialControlSystems.Logical.Timers.Functions.odts(\n        R,\n        PV,\n        time,\n        startTime,\n        run);\n    tr = if (not Q) and run then PV - (time - startTime) else PV;\n  end when;\nend Timer_OffDelay_Fedge;\n```\nModel description:\nThe timer is active after a falling edge of the set signal ( S ).\nThe output ( Q ) of the timer rises up PV seconds after the Set ( S ) becomes false (falling edge).\nIf the Set signal become true while counting, the timer does not stop.\nIf the Reset signal ( R ) has a rising edge, the output remains false and the timer stops.\n\nPrompt:\nUse this model for timing.\nBoth SetSignal and ResetSignal are implemented by Modelica.Blocks.Sources.BooleanTable, where SetSignal is set to table={0.5,1,8,9}, and ResetSignal is set to table={5,6,30}. \ntimerVALUE is defined by Modelica.Blocks.Sources.Constant, which is set to k=10.\n(The signal connection is based on the connect(SetSignal.y, timer.S); connect(ResetSignal.y, timer.R); connect(timerVALUE.y, timer.PV). )\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model and you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Timer_OffDelay_Fedge\n  IndustrialControlSystems.Logical.Timers.Timer_OffDelay_Fedge timer;\n  Modelica.Blocks.Sources.BooleanTable SetSignal(table={0.5,1,8,9});\n  Modelica.Blocks.Sources.BooleanTable ResetSignal(table={5,6,30});\n  Modelica.Blocks.Sources.Constant timerVALUE(k=10);\nequation\n  connect(SetSignal.y, timer.S);  \n  connect(ResetSignal.y, timer.R);\n  connect(timerVALUE.y, timer.PV);\nend Test_Timer_OffDelay_Fedge;\n",
            "feature": ""
        },
        {
            "id": 33,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel Integrator \"Integrator: mu/s\"\n  extends Interfaces.BaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| output initial value\";\ninitial equation\n  y = y_start;\nequation\n  der(y) = mu*u;\nend Integrator;\n```\nModel description:\nContinuous time transfer function of an integrating process.\n   Y(s)/U(s) = mu/s\n\nPrompt:\nUse this model to solve the transfer function of integrating process, where the integrating process gain 'mu' takes the value of 0.04 and the initial conditions 'y_start' takes the value of 1.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Integrator\n  IndustrialControlSystems.LinearSystems.Continuous.Integrator integrator(mu=0.04, y_start=1);\n  Modelica.Blocks.Sources.Step stepSignal(startTime=10, height=2);\nequation\n  connect(stepSignal.y, integrator.u);\nend Test_Integrator;\n",
            "feature": ""
        },
        {
            "id": 34,
            "instruction": "Modelica model:```\nmodel FirstOrder \"First order process: mu/(1+tau*s)\"\n  extends Interfaces.BaseBlock;\n  parameter Real tau = 2 \"|Block parameters| pole's time constant\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| output initial value\";\ninitial equation\n  y = y_start;\nequation\n  y + tau*der(y) = mu*u;\nend FirstOrder;\n```\nModel description:\nContinuous time transfer function of first order process.\n   Y(s)/U(s) = mu/(1+s*tau)\n\nPrompt:\nUse this model to solve the transfer function of the first order process, where the pole's time constant 'tau' of the first order process is 3, the gain 'mu' is 2, and the initial conditions 'y_start' is 0.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FirstOrder\n  IndustrialControlSystems.LinearSystems.Continuous.FirstOrder firstOrder1(tau=3, mu=2, y_start=0);\n  Modelica.Blocks.Sources.Step stepSignal(startTime=10, height=2);\nequation\n    connect(firstOrder1.u, stepSignal.y);\nend Test_FirstOrder;\n",
            "feature": ""
        },
        {
            "id": 35,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel LeadLag \"Lead lag process: mu(1+T1*s)/(1+T2*s)\"\n  extends Interfaces.BaseBlock;\n  parameter Real T1 = 3 \"|Block parameters| zero's time constant\";\n  parameter Real T2 = 5 \"|Block parameters| pole's time constant\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| output initial value\";\n  Real dy;\nprotected\n  parameter Real A = T1/T2;\n  parameter Real B = 1 - A;\ninitial equation\n  dy = y_start;\nequation\n  assert(abs(A-1)>1e-8,\"T1 must be != T2\");\n  dy + T2*der(dy) = mu*B*u;\n  y = u*mu*A + dy;\nend LeadLag;\n```\nModel description:\nContinuous time transfer function of a lead lag process.\n   Y(s)/U(s) = mu*(1 + s*T1)/(1 + s*T2)\nThe time constant T1 must be different from T2.\n\nPrompt:\nUse this model to solve the transfer function of the lead lag process, where the zero's time constant 'T1' of the lead lag process is 2, pole's time constant 'T2' is 3, the gain 'mu' is 2, and the initial conditions 'y_start' is 0.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LeadLag\n  IndustrialControlSystems.LinearSystems.Continuous.LeadLag leadlag(T1=2,T2=3,mu=2,y_start=0);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y,leadlag.u);\nend Test_LeadLag;\n",
            "feature": ""
        },
        {
            "id": 36,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel ComplexPoles \"Process with complex poles\"\n  extends Interfaces.BaseBlock;\n  parameter Real xi = 0.8 \"|Block parameters| Damping coefficient\";\n  parameter Real omegan = 0.1 \"|Block parameters| Natural frequency\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\n  parameter Real dy_start = 0 \"|Initial conditions| Slope initial value\";\n  Real dy;\ninitial equation\n  y  = y_start;\n  dy = dy_start;\nequation\n  assert(xi>= 0 and xi <= 1,\"Dumping coefficient must be between 0 and 1.\");\n\n  dy = der(y);\n  mu*u = y + 2*xi/omegan*dy + der(dy)/(omegan^2);\nend ComplexPoles;\n```\nModel description:\nContinuous time transfer function of a process with complex poles.\n   Y(s)/U(s) = mu/(1 + s*2*xi/omegan + (s/omegan)^2)\nThe damping coefficient xi must be between [0,1].\n\nPrompt:\nUse this model to solve the transfer function of a process with complex poles, where the damping coefficient 'xi' of the process with complex poles is 0.4, the natural frequency 'omegan' is 1, the gain 'mu' is 2, the output initial value'y_start' is 0, and the slope initial value 'dy_start' is 0.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ComplexPoles\n  IndustrialControlSystems.LinearSystems.Continuous.ComplexPoles complexPoles(xi = 0.4, omegan = 1, mu = 2, y_start = 0, dy_start = 0);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10) ;\nequation\n  connect(stepSignal.y, complexPoles.u);\nend Test_ComplexPoles;\n",
            "feature": ""
        },
        {
            "id": 37,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel TwoPolesTwoZeroes\n  \"Process with an integrator, 1 pole and 2 zeroes: mu(1+sT1)(1+sT2)/(1+sT3)s\"\n  extends Interfaces.BaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real T1 = 4 \"|Block parameters| first zero's time constant\";\n  parameter Real T2 = 2 \"|Block parameters| second zero's time constant\";\n  parameter Real T3 = 10 \"|Block parameters| pole's time constant\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\n  Real dy;\n  Real z;\n  Real h;\nprotected\n  parameter Real A = T2/T3;\n  parameter Real B = 1 - A;\ninitial equation\n  y = y_start;\nequation\n  assert(abs(A-1)>1e-8,\"T2 must be != T3\");\n\n  z = T1*u + h;\n\n  h + der(h) = z;\n\n  dy + T3*der(dy) = mu*B*z;\n\n  y = z*mu*A + dy;\nend TwoPolesTwoZeroes;\n```\nModel description:\nContinuous time transfer function of a process with an integrator, one pole and two zeroes.\n   Y(s)/U(s) = mu*(1 + s*T1)*(1 + s*T2)/[s*(1 + s*T3)]\nThe time constants T1 and T2 must be different from T3.\n\nPrompt:\nUse this model to solve the transfer function of a process with an integrator, one pole and two zeroes, where the first zero's time constant 'T1' of the process is 4, the second zero's time constant 'T2' is 2, the pole's time constant 'T3' is 10, the gain 'mu' is 1, and the output initial value 'y_start' is 0.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_TwoPolesTwoZeroes\n  IndustrialControlSystems.LinearSystems.Continuous.TwoPolesTwoZeroes\n    TwoPolesTwoZeroes(mu=1, T1=4, T2=2, T3=10, y_start=0);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y, TwoPolesTwoZeroes.u);\nend Test_TwoPolesTwoZeroes;\n",
            "feature": ""
        },
        {
            "id": 38,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel TransferFunction \" Model of a generic rational transfer function\n  [a(m)*s^m + a(m-1)*s^(m-1) + ... + a(1)*s + a(0) ]/[b(n)*s^n + b(n-1)*s^(n-1) + ... + b(1)*s + b(0) ] \"\n  extends Interfaces.BaseBlock;\n  parameter Real num[:] = {1,1}\n    \"|Block parameters| Numerators coefficients (4*s + 2) is {4,2}\";\n  parameter Real den[:] = {2,1,1}\n    \"|Block parameters| Denumerators coefficients (4*s + 2) is {4,2}\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\n  parameter Boolean initOutput = false\n    \"|Initial conditions| Initialise the output\";\n  parameter Boolean initSteadyState = false\n    \"|Initial conditions| Initialise at steady state\";\n  parameter Boolean initSteadyOutput = false\n    \"|Initial conditions| Initialise at steady output\";\nprotected\n  parameter Integer N = size(num,1) \"grade of the numerator\";\n  parameter Integer D = size(den,1) \"grade of the denumerator\";\n  parameter Real b[D] = den[:] \"den. coefficients\";\n  Real a[D] \"num. coefficients\";\n  Real c[D-1] \"num. coefficients (proper part)\";\n  Real Y[D];\n  Real U[D-1];\n  Real A \"terms used if the system is not strictly proper\";\n  Real w \"proper part of the output\";\ninitial equation\n  if initOutput then\n    y = y_start;\n  end if;\n  if initSteadyOutput then\n    der(y) = 0;\n  end if;\n  if initSteadyState then\n    der(w) = 0;\n  end if;\nequation\n  assert(D >= N,\"The system is not proper\");\n\n  if D==N then\n    a[1:D] = num[1:D];\n  else\n    a[1:D-N] = zeros(D-N);\n    a[D-N+1:D] = num[1:N];\n  end if;\n\n  A = a[1]/b[1];\n\n  for i in 1:D-1 loop\n    c[i] = a[i+1] - A*b[i+1];\n  end for;\n\n  Y[1] = der(w);\n  Y[2] = w;\n  for i in 3:D loop\n    der(Y[i]) = Y[i-1];\n  end for;\n\n  U[1] = u;\n  for i in 2:D-1 loop\n    der(U[i]) = U[i-1];\n  end for;\n\n  y = A*u + w;\n\n  b[:]*Y[:] = c[:]*U[:];\nend TransferFunction;\n```\nModel description:\nContinuous time transfer function, defined by its numerator and denumerator.\n   Y(s)     a(m)*s^m + a(m-1)*s^(m-1) + ... + a(1)*s + a(0) \n   ----  = -------------------------------------------------\n   U(s)     b(n)*s^n + b(n-1)*s^(n-1) + ... + b(1)*s + b(0)\nThe order of the numerator cannot be higher than the denumerator one: m <= n.\n\nPrompt:\nUse this model to solve the generic transfer function, where the numerator coefficients 'a[:]' is {-1,1}, the denominator coefficients 'b[:]' is {2,4,1}, and the output initial value 'y_start' is 0. \nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_TransferFunction\n  IndustrialControlSystems.LinearSystems.Continuous.TransferFunction transferFunction(num={-1,1},den={2,4,1},y_start=0);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10) ;\nequation\n  connect(stepSignal.y, transferFunction.u) ;\nend Test_TransferFunction;\n",
            "feature": ""
        },
        {
            "id": 39,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel Delay \"Time delay\"\n  extends LinearSystems.Interfaces.BaseBlock;\n  parameter Real T = 1 \"Fixed delay time\";\nequation\n  assert(T>=0,\"Delay constant must be positive\");\n\n  y = delay(u,T);\nend Delay;\n```\nModel description:\nContinuous time delay.\n   Y(s) = e^(-s*T)*U(s)\nThe delay must be positive T >= 0.\n\nPrompt:\nUse this model to solve the continuous time delay of a signal, where the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=2, offset=2, startTime=2, f=0.2).\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Delay\n  IndustrialControlSystems.LinearSystems.Continuous.Delay delay2;\n  Modelica.Blocks.Sources.Sine sine(amplitude=2, offset=2, startTime=2, f=0.2);\nequation\n  connect(delay2.u,sine.y);\nend Test_Delay;\n",
            "feature": ""
        },
        {
            "id": 40,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Continuous;\nmodel SmithDelay \"Time delay block for Smith's predictor\"\n  extends LinearSystems.Interfaces.BaseBlock;\n  parameter Real T = 1 \"Fixed delay time\";\nequation\n  assert(T>=0,\"Delay constant must be positive\");\n\n  y = u - delay(u,T);\nend SmithDelay;\n```\nModel description:\nContinuous time delay block for the Smith's predictor.\n   Y(s) = (1 - e^(-s*T))*U(s)\nThe delay must be positive T >= 0.\n\nPrompt:\nUse this model to solve the continuous time delay for Smith's predictor of a signal, where the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=2, offset=2, startTime=2, f=0.2).\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SmithDelay\n  IndustrialControlSystems.LinearSystems.Continuous.SmithDelay smithDelay(T=1);\n  Modelica.Blocks.Sources.Sine sine(amplitude=2, offset=2, startTime=2, f=0.2);\nequation\n  connect(sine.y, smithDelay.u);\nend Test_SmithDelay;\n",
            "feature": ""
        },
        {
            "id": 41,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel Integrator \"Integrator: mu/s\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\ninitial equation\n  pre(y) = y_start;\nequation\n  when sample(0,Ts) then\n    y = Functions.fIntegrator(alfa,u,pre(u),pre(y),Ts,mu);\n  end when;\nend Integrator;\n```\nModel description:\nDiscretised version of the continuous time transfer function of an integrating process.\n   Y(s)/U(s) = mu/s\n\nPrompt:\nUse this model to solve the transfer function of integrating process, where the integrating process gain 'mu' takes the value of 0.04, the initial conditions 'y_start' takes the value of 1 and the discrete sample time 'Ts' is 0.5.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Integrator_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.Integrator integrator(mu=0.04,y_start=1,Ts=0.5);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y,integrator.u);\nend Test_Integrator_Dis;\n",
            "feature": ""
        },
        {
            "id": 42,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel FirstOrder \"First order process: mu/(1+tau*s)\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real tau = 0.3 \"|Block parameters| Time constant\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\ninitial equation\n  pre(y) = y_start;\nequation\n  when sample(0,Ts) then\n    y = Functions.f1Pole(alfa,u,pre(u),pre(y),Ts,mu,tau);\n  end when;\nend FirstOrder;\n```\nModel description:\nDiscretised version of the continuous time transfer function of first order process.\n   Y(s)/U(s) = mu/(1+s*tau)\n\nPrompt:\nUse this model to solve the transfer function of the first order process, where the pole's time constant 'tau' of the first order process is 3, the gain 'mu' is 2, the initial conditions 'y_start' is 0, and the discrete sample time 'Ts' is 0.5.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FirstOrder_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.FirstOrder firstOrder(mu=2,tau=3,y_start=0,Ts=0.5);\n  Modelica.Blocks.Sources.Step stepSignal(height=2,startTime=10);\nequation\n  connect(stepSignal.y, firstOrder.u);\nend Test_FirstOrder_Dis;\n",
            "feature": ""
        },
        {
            "id": 43,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel LeadLag \"Lead lag process: mu(1+T1*s)/(1+T2*s)\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real T1 = 0.001 \"|Block parameters| Costante di tempo dello zero\";\n  parameter Real T2 = 0.25 \"|Block parameters| Costante di tempo del polo\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\ninitial equation\n  pre(y) = y_start;\nequation\n  assert(abs(T1-T2)>1e-8,\"T1 must be != T2\");\n\n  when sample(0,Ts) then\n    y = Functions.f1p1z(alfa,T1,T2,u,pre(u),pre(y),Ts,mu);\n  end when;、\nend LeadLag;\n```\nModel description:\nDiscretised version of the continuous time transfer function of a lead lag process.\n   Y(s)/U(s) = mu*(1 + s*T1)/(1 + s*T2)\nThe time constant T1 must be different from T2.\n   \nPrompt:\nUse this model to solve the transfer function of the lead lag process, where the zero's time constant 'T1' of the lead lag process is 2, pole's time constant 'T2' is 3, the gain 'mu' is 2, the initial conditions 'y_start' is 0, and the discrete sample time 'Ts' is 0.5.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LeadLag_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.LeadLag leadLag(T1=2, T2=3, mu=2, y_start=0, Ts=0.5);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y, leadLag.u) ;\nend Test_LeadLag_Dis;\n",
            "feature": ""
        },
        {
            "id": 44,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel ComplexPoles \"Process with complex poles\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real xi = 0.8 \"|Block parameters| Damping coefficient\";\n  parameter Real omegan = 0.1 \"|Block parameters| Natural frequency\";\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\n  parameter Real dy_start = 0 \"|Initial conditions| Slope initial value\";\nprotected\n  Real u_pre1;\n  Real y_pre1;\ninitial equation\n  pre(y) = y_start;\n  pre(y_pre1) = dy_start;\nequation\n  assert(xi>= 0 and xi <= 1,\"Dumping coefficient must be between 0 and 1.\");\n\n  when sample(0,Ts) then\n    y = Functions.fCmplx(alfa,u,pre(u),pre(u_pre1),pre(y),pre(y_pre1),Ts,mu,xi,omegan);\n    u_pre1 = pre(u);\n    y_pre1 = pre(y);\n  end when;\nend ComplexPoles;\n```\nModel description:\nDiscretised version of the continuous time transfer function of a process with complex poles.\n   Y(s)/U(s) = mu/(1 + s*2*xi/omegan + (s/omegan)^2)\nThe damping coefficient xi must be between [0,1].\n\nPrompt:\nUse this model to solve the transfer function of a process with complex poles, where the damping coefficient 'xi' of the process with complex poles is 0.4, the natural frequency 'omegan' is 1, the gain 'mu' is 2, the output initial value'y_start' is 0, the slope initial value 'dy_start' is 0, and the discrete sample time 'Ts' is 0.5.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ComplexPoles_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.ComplexPoles ComplexPoles(xi=0.4,omegan=1,mu=2,y_start=0,dy_start=0,Ts=0.5) ;\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y, ComplexPoles.u);\nend Test_ComplexPoles_Dis;\n",
            "feature": ""
        },
        {
            "id": 45,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel TwoPolesTwoZeroes\n  \"Process with an integrator, 1 pole and 2 zeroes: mu(1+sT1)(1+sT2)/(1+sT3)s\"\n  extends Interfaces.DiscreteBaseBlock;\n  parameter Real mu = 1 \"|Block parameters| Gain\";\n  parameter Real T1 = 2 \"|Block parameters| first zero's time constant\";\n  parameter Real T2 = 0.03 \"|Block parameters| second zero's time constant\";\n  parameter Real T3 = 0.5 \"|Block parameters| pole's time constant\";\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\nprotected\n  Real u_pre;\n  Real y_pre;\ninitial equation\n  pre(y) = y_start;\nequation\n  assert(abs(T2-T3)>1e-8 and abs(T1-T3)>1e-8,\"T1 and T2 must be != T3\");\n\n  when sample(0,Ts) then\n    y = IndustrialControlSystems.LinearSystems.Discrete.Functions.f2p2z(\n      alfa,\n      T1,\n      T2,\n      T3,\n      u,\n      pre(u),\n      pre(u_pre),\n      pre(y),\n      pre(y_pre),\n      Ts,\n      mu);\n    u_pre = pre(u);\n    y_pre = pre(y);\n  end when;\nend TwoPolesTwoZeroes;\n```\nModel description:\nDiscretised version of the continuous time transfer function of a process with an integrator, one pole and two zeroes.\n   Y(s)/U(s) = mu*(1 + s*T1)*(1 + s*T2)//[s*(1 + s*T3)]\nThe time constants T1 and T2 must be different from T3.\n\nPrompt:\nUse this model to solve the transfer function of a process with an integrator, one pole and two zeroes, where the first zero's time constant 'T1' of the process is 4, the second zero's time constant 'T2' is 2, the pole's time constant 'T3' is 10, the gain 'mu' is 1, the output initial value 'y_start' is 0, and the discrete sample time 'Ts' is 0.5.\nThe input signal 'stepSignal' is implemented by Modelica.Blocks.Sources.Step, stepSignal is set to height=2, startTime=10.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_TwoPolesTwoZeroes_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.TwoPolesTwoZeroes\n    tp2z_model(mu=1,T1=4,T2=2,T3=10,y_start=0,Ts=0.5);\n  Modelica.Blocks.Sources.Step stepSignal(height=2, startTime=10);\nequation\n  connect(stepSignal.y,tp2z_model.u) ;\nend Test_TwoPolesTwoZeroes_Dis;\n",
            "feature": ""
        },
        {
            "id": 46,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel Delay \"Unitary time delay\"\n  extends LinearSystems.Interfaces.DiscreteBaseBlock;\n  parameter Real y_start = 0 \"|Initial conditions| Output initial value\";\ninitial equation\n  y = y_start;\nequation\n  when sample(0,Ts) then\n    y = pre(u);\n  end when;\nend Delay;\n```\nModel description:\nDiscrete version of the single step time delay.\n   Y(s) = e^(-s*Ts)*U(s)\nThe delay must be positive T >= 0.\n\nPrompt:\nUse this model to solve the unitary time delay of a signal, where the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=2, offset=2, startTime=2, f=0.2).\nThe parameters of model Delay are Ts=0.1 and y_start=0. \nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Delay_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.Delay delay(Ts=1, y_start=0);\n  Modelica.Blocks.Sources.Sine sine(amplitude=2, offset=2, startTime=2, f=0.2);\nequation\n  connect(sine.y,delay.u);\nend Test_Delay_Dis;\n",
            "feature": ""
        },
        {
            "id": 47,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.LinearSystems.Discrete;\nmodel MultiStepsDelay \"Multistep time delay\"\n  extends LinearSystems.Interfaces.DiscreteBaseBlock;\n  parameter Integer N = 1 \"Fixed multi-step dalay\";\n  parameter Real y_start = 0 \"Initial output value\";\nprotected\n  discrete Real buffer[N](each start = y_start);\nalgorithm\n  assert(N>1,\"The number of N steps delay must be positive\");\n\n  when sample(0,Ts) then\n\n    for i in 2:N loop\n      buffer[i] := pre(buffer[i-1]);\n    end for;\n\n    buffer[1] := u;\n\n    y := buffer[N];\n\n  end when;\nend MultiStepsDelay;\n```\nModel description:\nDiscrete version of the multistep time delay.\n   Y(s) = e^(-s*N*Ts)*U(s)\nThe delay must be positive T >= 0.\n\nPrompt:\nUse this model to solve the multistep time delay of a signal, where the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=2, offset=2, startTime=2, f=0.2).\nThe parameters of model MultiStepsDelay are Ts=0.1, N=2 and y_start=0. \nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_MultiStepsDelay_Dis\n  IndustrialControlSystems.LinearSystems.Discrete.MultiStepsDelay multiStepsDelay(Ts=0.1, N=2, y_start=0);\n  Modelica.Blocks.Sources.Sine sine(amplitude=2, offset=2, startTime=2, f=0.2);\nequation\n  connect(sine.y,multiStepsDelay.u);\nend Test_MultiStepsDelay_Dis;\n",
            "feature": ""
        },
        {
            "id": 48,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Controllers.Logic;\nmodel Relay \"Relay\"\n  extends IndustrialControlSystems.Controllers.Interfaces.BaseBlock;\n  parameter Real Ymax = 1 \"maximum output value\" annotation(Evaluate = true);\n  parameter Real Ymin = 0 \"minimum output value\" annotation(Evaluate = true);\n  parameter Real Th = 0 \"input treshold value\" annotation(Evaluate = true);\nequation\n  if Ts > 0 then\n    // Discrete time relay\n    when sample(0,Ts) then\n      if pre(u) >= Th then\n        y = Ymax;\n      else\n        y = Ymin;\n      end if;\n    end when;\n  else\n    // Continuous time relay\n    if u >= Th then\n        y = Ymax;\n      else\n        y = Ymin;\n      end if;\n  end if;\nend Relay;\n\n```\nModel description:\nOn-Off relay controller.\n   y(t)  = 1 if u(t) >= 0\n   y(t)  = 0 if u(t) < 0\n\nPrompt:\nUse this model to solve the relay of a signal, where the sampling time 'Ts' is 0.2, the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=1, f=1).\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Relay\n  IndustrialControlSystems.Controllers.Logic.Relay relay1(Ts=0.2);\n  Modelica.Blocks.Sources.Sine sine1(f=1, amplitude=1);\nequation\n  connect(sine1.y, relay1.u) ;\nend Test_Relay;\n",
            "feature": ""
        },
        {
            "id": 49,
            "instruction": "Modelica model:```\nwithin IndustrialControlSystems.Controllers.Logic;\nmodel RelayHysteresis \"Relay with hysteresis\"\n  extends IndustrialControlSystems.Controllers.Interfaces.BaseBlock;\n  parameter Real Ymax = 1 \"maximum output value\" annotation(Evaluate = true);\n  parameter Real Ymin = 0 \"minimum output value\" annotation(Evaluate = true);\n  parameter Real ThL = 0 \"input treshold (low) value\" annotation(Evaluate = true);\n  parameter Real ThH = 0 \"input treshold (high) value\" annotation(Evaluate = true);\n  parameter Boolean initState = false \"initial state\" annotation(Evaluate = true);\nprotected\n  discrete Boolean state( start = initState);\ninitial equation\n  pre(state) = initState;\nequation\n  if Ts > 0 then\n    // Discrete time relay\n    when sample(0,Ts) then\n\n      if (u >= ThH and not pre(state)) or (u <= ThL and pre(state)) then\n        state = not pre(state);\n      else\n        state = pre(state);\n      end if;\n\n      if state then\n        y = Ymax;\n      else\n        y = Ymin;\n      end if;\n\n    end when;\n  else\n    // continuous time relay\n    if state then\n      y = Ymax;\n    else\n      y = Ymin;\n    end if;\n\n    when (u >= ThH and not pre(state)) or (u <= ThL and pre(state)) then\n      state = not pre(state);\n    end when;\n  end if;\nend RelayHysteresis;\n```\nModel description:\nOn-Off relay with hysteresis controller.\n   y(t)  = 1 if u(t) >= ThH and y(t) == 0\n   y(t)  = 0 if u(t) < ThL  and y(t) == 1\n\nPrompt:\nUse this model to solve the relay of a signal, where the sampling time 'Ts' is 0.2, the signal is implemented by Modelica.Blocks.Sources.Sine with (amplitude=1, f=1).\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RelayHysteresis\n  IndustrialControlSystems.Controllers.Logic.RelayHysteresis relayHysteresis(Ts=0.2);\n  Modelica.Blocks.Sources.Sine sine(amplitude=1, f=1);\nequation\n  connect(sine.y, relayHysteresis.u) ;\nend Test_RelayHysteresis;\n",
            "feature": ""
        },
        {
            "id": 50,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\n\nmodel FreeOffset\n  extends Modelica.Blocks.Interfaces.SO;\n  import PowerGrids.Types.Choices.InitializationOption;\n\n  parameter Boolean use_u = false \"= true if time varying output is required\";\n  final parameter Boolean fixedOffsetDefault = \n    if systemPowerGrids.initOpt == InitializationOption.globalSteadyStateFixedPowerFlow or\n       systemPowerGrids.initOpt == InitializationOption.localSteadyStateFixedPowerFlow\n    then false\n    else true \"Default choice of fixedOffsetDefault from system object\";\n  parameter Boolean fixedOffset = fixedOffsetDefault \"= true if offset is fixed to zero, = false if offset is left free\";    \n  final parameter Real offset(fixed = false) \"Free offset of output y\";\n\n  outer PowerGrids.Electrical.System systemPowerGrids \"Reference to system object\";\n\n  Modelica.Blocks.Interfaces.RealInput u if use_u annotation(\n    Placement(visible = true, transformation(origin = {-106, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-110, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\nprotected\n  Modelica.Blocks.Interfaces.RealInput u_internal \"Protected connector to be used in equations in place of conditional u\";\n\ninitial equation\n  if fixedOffset then\n    offset = 0;\n  end if;\n\nequation\n  y = u_internal + offset;\n  connect(u, u_internal) \"Automatically removed if u is disabled\";\n  if not use_u then\n    u_internal = 0 \"Provide a default zero value if u is disabled\";\n  end if;\nend FreeOffset;\n```\nModel description:\nThis block adds an offset to the input u, or to zero if use_u is false.\nIf fixedOffset = false, then the offset is a free parameter, that needs to be determined by an additional initial equation on the system, otherwise the offset is fixed to zero. This block can be used to adjust the set point of controllers that have additional initial equations to fix their controlled outputs to the start values given by the load flow. The value of the fixedOffset parameter is set by default by the system object, depending on the value of systemPowerGrids.initOpt.\n\nPrompt:\nUse this model to test the FreeOffset of a signal, where the use_u of instances freeOffset1 and freeOffset2 are false and true, respectively, the signal is implemented by Modelica.Blocks.Sources.Sine with f=1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FreeOffset\n  PowerGrids.Controls.FreeOffset freeOffset1(use_u = false, fixedOffset = true);\n  PowerGrids.Controls.FreeOffset freeOffset2(use_u = true);\n  Modelica.Blocks.Sources.Sine Sine(f=1);\nequation\n  connect(Sine.y,freeOffset1.u);\n  connect(Sine.y,freeOffset2.u);\nend Test_FreeOffset;\n",
            "feature": ""
        },
        {
            "id": 51,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel LeadLag \"Simple lead-lag filter\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter Real k = 1 \"Gain\";\n  parameter SI.Time T1 \"Lead time constant\";\n  parameter SI.Time T2 \"Lag time constant\";\n  parameter Boolean noDynamics = not(T2 > 0) \"Trivial configuration with no dynamics G(s) = k\";\n  parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\" annotation(Evaluate=true,\n      Dialog(group=\"Initialization\"));\n  parameter Real yStart=0 \"Initial or guess value of output (= state)\" annotation (\n  Dialog(group=\"Initialization\"));\n  Modelica.Blocks.Math.Feedback feedback annotation(\n    Placement(visible = true, transformation(origin = {-40, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain gain(k = if noDynamics then k else k * T1 / T2)  annotation(\n    Placement(visible = true, transformation(origin = {2, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.FirstOrder firstOrder(\n    T = T1,\n    initType = initType,k = (T1 - T2) / (k * T1), y_start = yStart * (T1 - T2) / (k * T1)) if not noDynamics  \n    annotation(\n    Placement(visible = true, transformation(origin = {2, -46}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));\n  Modelica.Blocks.Sources.RealExpression zero if noDynamics annotation(\n    Placement(visible = true, transformation(origin = {-70, -46}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert((T1 > 0 and T2 > 0) or ((not T1 > 0) and (not T2 > 0)), \"Either T1 = T2 = 0 or T1 > 0 and T2 > 0\");\nequation\n  connect(zero.y, feedback.u2) annotation(\n    Line(points = {{-58, -46}, {-40, -46}, {-40, -8}}, color = {0, 0, 127}, pattern = LinePattern.Dash));\n  connect(firstOrder.y, feedback.u2) annotation(\n    Line(points = {{-8, -46}, {-40, -46}, {-40, -8}}, color = {0, 0, 127}));\n  connect(u, feedback.u1) annotation(\n    Line(points = {{-120, 0}, {-48, 0}}, color = {0, 0, 127}));\n  connect(feedback.y, gain.u) annotation(\n    Line(points = {{-31, 0}, {-10, 0}}, color = {0, 0, 127}));\n  connect(gain.y, firstOrder.u) annotation(\n    Line(points = {{14, 0}, {60, 0}, {60, -46}, {14, -46}, {14, -46}, {14, -46}}, color = {0, 0, 127}));\n  connect(gain.y, y) annotation(\n    Line(points = {{14, 0}, {102, 0}, {102, 0}, {110, 0}}, color = {0, 0, 127}));\nend LeadLag;\n```\nModel description:\nLead-lag filter (no output limitations):\n\ty\t1 + s*T1\n\t- = k  *    -----------\n\tu\t1 + s*T2\nNeither output limitation nor anti-windup are implemented.\nThe dynamic parts are removed if T1=0 and T2=0. Otherwise, both T1 and T2 need to be positive.\nBy default, T1 and T2 are structural parameters, so they cannot be changed at runtime without recompiling the model. In order to do so, set the noDynamics parameter explicitly to false (note that you can't change T1 and T2 to zero at runtime in this case).\n\nPrompt:\nUse this model to test the LeadLag filter of a signal, where the instances has T1 = 4, T2 = 2, initType = Modelica.Blocks.Types.Init.SteadyState, k = 10, yStart = 10, the signal is implemented by Modelica.Blocks.Sources.Step with offset = 1, startTime = 1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LeadLag\n  PowerGrids.Controls.LeadLag leadLagModel(T1=4, T2=2, initType=Modelica.Blocks.Types.Init.SteadyState, k=10, yStart = Modelica.Constants.pi,noDynamics = false);  \n  Modelica.Blocks.Sources.Step stepModel(height=1, offset=1, startTime=1) ;\nequation\n  connect(leadLagModel.u, stepModel.y);\nend Test_LeadLag;\n",
            "feature": ""
        },
        {
            "id": 52,
            "instruction": "Modelica model:```within PowerGrids.Controls;\nmodel DerivativeLag \"Derivative filter with lag\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter SI.Time T1 \"Lag time constant\";\n  parameter SI.Time Td = T1 \"Derivative time constant\";\n  parameter Boolean noDynamics = not(T1 > 0) \"Trivial configuration with no dynamics G(s) = 1\";\n  parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\" annotation(Evaluate=true,\n      Dialog(group=\"Initialization\"));\n  parameter Real yStart=0 \"Initial or guess value of output (= state)\" annotation (\n  Dialog(group=\"Initialization\"));\n  Modelica.Blocks.Math.Feedback feedback annotation(\n    Placement(visible = true, transformation(origin = {-30, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain gain(k = if noDynamics then 1 else Td / T1)  annotation(\n    Placement(visible = true, transformation(origin = {-60, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.Integrator integrator(\n    initType = initType, \n    k = 1 / T1,\n    y_start = yStart*Td/T1) if not noDynamics  annotation(\n    Placement(visible = true, transformation(origin = {2, -40}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));\n  Modelica.Blocks.Sources.RealExpression zero if noDynamics annotation(\n    Placement(visible = true, transformation(origin = {-68, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert((T1 > 0 and Td > 0) or ((not T1 > 0) and (not Td > 0)), \"Either T1 = T2 = 0 or T1 > 0 and T2 > 0\");\nequation\n  connect(zero.y, feedback.u2) annotation(\n    Line(points = {{-56, -40}, {-30, -40}, {-30, -8}, {-30, -8}, {-30, -8}}, color = {0, 0, 127}, pattern = LinePattern.Dash));\n  connect(integrator.y, feedback.u2) annotation(\n    Line(points = {{-9, -40}, {-30, -40}, {-30, -8}}, color = {0, 0, 127}));\n  connect(feedback.y, integrator.u) annotation(\n    Line(points = {{-20, 0}, {30, 0}, {30, -40}, {14, -40}}, color = {0, 0, 127}));\n  connect(feedback.y, y) annotation(\n    Line(points = {{-20, 0}, {104, 0}, {104, 0}, {110, 0}}, color = {0, 0, 127}));\n  connect(gain.y, feedback.u1) annotation(\n    Line(points = {{-48, 0}, {-38, 0}, {-38, 0}, {-38, 0}}, color = {0, 0, 127}));\n  connect(u, gain.u) annotation(\n    Line(points = {{-120, 0}, {-72, 0}, {-72, 0}, {-72, 0}}, color = {0, 0, 127}));\nend DerivativeLag;\n```\nModel description:\nImplements a derivative filter with lag, a.k.a. real differentiator:\n\ty           s*Td\n\t- =   -----------\n\tu        1 + s*T1\nIf Td = T1 > 0, a high-pass or washout filter with cut-off frequency 1/Td is obtained.\nIf Td = T1 = 0 a filter with transfer function 1 is obtained. \nBy default, T1 and T2 are structural parameters, so they cannot be changed at runtime without recompiling the model. In order to do so, set the noDynamics parameter explicitly to false (note that you can't set T1  and T2 to zero = 0 at runtime in this case).\n\nPrompt:\nUse this model to test the DerivativeLag of a signal, where the instances has Td = 4, T1 = 2, initType = Modelica.Blocks.Types.Init. SteadyState, the signal is implemented by Modelica.Blocks.Sources.Step with offset = 1, startTime = 1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_DerivativeLag\n  PowerGrids.Controls.DerivativeLag derivativeLag(Td = 4, T1 = 2, initType = Modelica.Blocks.Types.Init.SteadyState);\n  Modelica.Blocks.Sources.Step step(startTime = 1, offset = 1);\nequation\n  connect(step.y, derivativeLag.u);\nend Test_DerivativeLag;\n",
            "feature": ""
        },
        {
            "id": 53,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel LeadMOrderLag \"Lead-lag filter with M poles\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter Integer M = 1 \"Lag Order\";\n  parameter Real k(unit=\"1\") = 1 \"Gain\";\n  parameter SI.Time T1 \"Lead time constant\";\n  parameter SI.Time T2 \"Lag time constant\";\n  parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\" annotation(Evaluate=true,\n      Dialog(group=\"Initialization\"));\n  parameter Real yStart=0 \"Initial or guess value of output (= state)\" annotation (\n  Dialog(group=\"Initialization\"));\n  LeadLag leadLag(T1 = T1, T2 = T2, initType = initType, k = k, yStart = yStart)  annotation(\n    Placement(visible = true, transformation(origin = {-50, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  PowerGrids.Controls.FirstOrder firstOrderCascade[max(0,M-1)](each T = T2, each initType = initType, each k = 1, each y_start = yStart) if M > 1 annotation(\n    Placement(visible = true, transformation(origin = {10, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert((T1 > 0 and T2 > 0) or ((not T1 > 0) and (not T2 > 0)), \"Either T1 = T2 = 0 or T1 > 0 and T2 > 0\");\n  assert(M > 0, \"minimum lag order is 1\");\nequation\n  connect(u, leadLag.u) annotation(\n    Line(points = {{-120, 0}, {-62, 0}}, color = {0, 0, 127}));\n  \n  if M > 1 then\n    connect(leadLag.y, firstOrderCascade[1].u);\n    connect(firstOrderCascade[M-1].y, y);\n  else\n    connect(leadLag.y, y);\n  end if;  \n  \n  if M > 2 then\n    for i in 1:M-2 loop\n      connect(firstOrderCascade[i].y, firstOrderCascade[i+1].u);\n    end for;\n  end if;\nend LeadMOrderLag;\n```\nModel description:\nModel to implement the following transfer function:\n\ty              1 + s*T1\n\t- = k * ---------------\n\tu          (1 + s*T2)^M\nIt is required that M > 0. If T1 = 0 and T2 = 0 then the block is a static gain, otherwise it is required that T1 >0, and T2 > 0.\n\nPrompt:\nUse this model to test the Lead-lag filter with M poles of a signal, where the instances has M = 100, T1 = 1e-5, T2 = 1 / 100, initType = Modelica.Blocks.Types.Init.SteadyState, k = 1, yStart = 1, the signal is implemented by Modelica.Blocks.Sources.Step with height = 1, offset = 1, startTime = 1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LeadMOrderLag\n  PowerGrids.Controls.LeadMOrderLag leadMOrderLag(M=100, T1=1e-5, T2=1/100, initType=Modelica.Blocks.Types.Init.SteadyState, k=1, yStart=1);\n  Modelica.Blocks.Sources.Step signal(height=1, offset=1, startTime=1);\nequation\n  connect(signal.y, leadMOrderLag.u);\nend Test_LeadMOrderLag;\n",
            "feature": ""
        },
        {
            "id": 54,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel RampTrackingFilter \"Ramp tracking filter\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter Integer N(min = 0) = 1 \"N Order\";\n  parameter Integer M(min = 0) = 1 \"M Order\";\n  parameter Real k(unit=\"1\")=1 \"Gain\";\n  parameter SI.Time T1 \"Lead time constant\";\n  parameter SI.Time T2 \"Lag time constant\";\n  parameter Modelica.Blocks.Types.Init initType=Modelica.Blocks.Types.Init.NoInit \"Type of initialization (1: no init, 2: steady state, 3/4: initial output)\" annotation(Evaluate=true,\n      Dialog(group=\"Initialization\"));\n  parameter Real yStart=0 \"Initial or guess value of output (= state)\" annotation (\n  Dialog(group=\"Initialization\"));\n  PowerGrids.Controls.LeadMOrderLag leadMOrderLagCascade[N](each M = M, each T1 = T1, each T2 = T2, each initType = initType, each k = 1, each yStart = yStart)  annotation(\n    Placement(visible = true, transformation(origin = {-3.55271e-15, 3.55271e-15}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain gain(k = k)  annotation(\n    Placement(visible = true, transformation(origin = {-62, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert((N > 0 and M > 0) or N == 0, \"If N > 0 then also M must be positive\");\n  assert((T1 > 0 and T2 > 0) or ((not T1 > 0) and (not T2 > 0)), \"Either T1 = T2 = 0 or T1 > 0 and T2 > 0\");\nequation\n  connect(u, gain.u) annotation(\n    Line(points = {{-120, 0}, {-76, 0}, {-76, 0}, {-74, 0}}, color = {0, 0, 127}));\n  if N == 0 then\n    connect(gain.y, y);\n  else\n    connect(gain.y, leadMOrderLagCascade[1].u) annotation(\n    Line(points = {{-50, 0}, {-26, 0}, {-26, 0}, {-24, 0}}, color = {0, 0, 127}, pattern = LinePattern.Dash));\n    connect(y, leadMOrderLagCascade[N].y) annotation(\n    Line(points = {{110, 0}, {20, 0}, {20, 0}, {22, 0}}, color = {0, 0, 127}, pattern = LinePattern.Dash));\n    if N > 1 then\n      for i in 1:N-1 loop\n        connect(leadMOrderLagCascade[i].y, leadMOrderLagCascade[i+1].u);\n      end for;\n    end if;\n  end if;\nend RampTrackingFilter;\n```\nModel description:\nModel to implement the following transfer function:\n\n\ty          |  (1 + s*T1)  |^N\n\t- = k * |--------------|\n\tu          | (1 + s*T2)^M |\n\nIf N = 0 then the block implements a static gain, otherwise both M and N must be greater than 0. If T1 = 0 and T2 = 0, the block also implements a static gain.\nNeither output limitation nor anti-windup are implemented.\n\nPrompt:\nUse this model to test the Ramp tracking filter of a signal, where the instances has M = 2, N = 50, T1 = 1e-5, T2 = 1 / 100, initType = Modelica.Blocks.Types.Init.SteadyState, k = 10, yStart = 10, the signal is implemented by Modelica.Blocks.Sources.Step with height = 1, offset = 1, startTime = 1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RampTrackingFilter\n  PowerGrids.Controls.RampTrackingFilter rampTrackingFilter(M = 2, N = 50, T1 = 1e-5, T2 = 1 / 100, initType = Modelica.Blocks.Types.Init.SteadyState, k = 10, yStart = 10);\n    Modelica.Blocks.Sources.Step step(height = 1, offset = 1, startTime = 1);\nequation\n  connect(step.y, rampTrackingFilter.u);\nend Test_RampTrackingFilter;\n",
            "feature": ""
        },
        {
            "id": 55,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel FirstOrderWithNonWindupLimiter \"First order filter with non-windup limiter\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter Real k = 1 \"Gain\";\n  parameter SI.Time T \"Time Constant\";\n  parameter Real yMax \"Upper limits of output signal\";\n  parameter Real yMin = -yMax \"Lower limits of output signal\";\n  parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\" annotation(\n    Evaluate = true,\n    Dialog(group = \"Initialization\"));\n  parameter Real yStart = 0 \"Initial or guess value of output (= state)\" annotation(\n    Dialog(group = \"Initialization\"));\n  parameter Boolean strict = false \"= true, if strict limits with noEvent(..)\" annotation(\n    Evaluate = true,\n    choices(checkBox = true),\n    Dialog(tab = \"Advanced\"));\n  Modelica.Blocks.Nonlinear.Limiter lim(strict = strict, uMax = yMax, uMin = yMin) annotation(\n    Placement(visible = true, transformation(origin = {52, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Feedback feedback annotation(\n    Placement(visible = true, transformation(origin = {-56, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain G(k = 1 / T) annotation(\n    Placement(visible = true, transformation(origin = {-24, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.Integrator I(initType = initType, k = 1, y_start = yStart) annotation(\n    Placement(visible = true, transformation(origin = {16, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain Gk(k = k) annotation(\n    Placement(visible = true, transformation(origin = {-82, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert(T > 0, \"T must be positive\");\nequation\n  connect(Gk.u, u) annotation(\n    Line(points = {{-94, 0}, {-108, 0}, {-108, 0}, {-120, 0}}, color = {0, 0, 127}));\n  connect(Gk.y, feedback.u1) annotation(\n    Line(points = {{-70, 0}, {-66, 0}, {-66, 0}, {-64, 0}}, color = {0, 0, 127}));\n  connect(lim.y, feedback.u2) annotation(\n    Line(points = {{63, 0}, {74, 0}, {74, -32}, {-56, -32}, {-56, -8}}, color = {0, 0, 127}));\n  connect(feedback.y, G.u) annotation(\n    Line(points = {{-47, 0}, {-36, 0}}, color = {0, 0, 127}));\n  connect(lim.y, y) annotation(\n    Line(points = {{64, 0}, {104, 0}, {104, 0}, {110, 0}}, color = {0, 0, 127}));\n  connect(I.y, lim.u) annotation(\n    Line(points = {{27, 0}, {40, 0}}, color = {0, 0, 127}));\n  // The simplified model has no saturation, to make the controller equations linear\n  I.u = homotopy(\n    actual = if (G.y >= 0 and lim.u > lim.uMax) or (G.y <= 0 and lim.u < lim.uMin) then 0 else G.y,\n    simplified = G.y);\nend FirstOrderWithNonWindupLimiter;\n```\nModel description:\nModel to implement a first order filter:\n\ty          k\n\t- = -----------\n\tu      1 + s*T\nIt is required that T > 0.\nOutput limiter with anti-windup is also implemented.\n\nPrompt:\nUse this model to test the First order filter with non-windup limiter of a signal, where the instances has T = 2, initType = Modelica.Blocks.Types.Init.SteadyState, k = 2, yMax = 5, yMin = -5, yStart = 2, the signal is implemented by Modelica.Blocks.Sources.TimeTable with table = [0, 1; 1, 1; 1, 4; 10, 4; 10, -4; 100, -4].\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FirstOrderWithNonWindupLimiter\n  PowerGrids.Controls.FirstOrderWithNonWindupLimiter FirstOrderWithNonWindupLimiter(k = 2, T = 2, initType = Modelica.Blocks.Types.Init.SteadyState, yMax = 5, yMin = -5, yStart = 2);\nModelica.Blocks.Sources.TimeTable table(table = [0, 1; 1, 1; 1, 4; 10, 4; 10, -4; 100, -4]);\nequation\n  connect(table.y, FirstOrderWithNonWindupLimiter.u) ;\nend Test_FirstOrderWithNonWindupLimiter;\n",
            "feature": ""
        },
        {
            "id": 56,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\n\nmodel LeadLagWithNonWindupLimiter \"Lead-lag filter with non-windup limiter\"\n  extends Modelica.Blocks.Interfaces.SISO(y(start = yStart));\n  parameter Real k = 1 \"Gain\";\n  parameter SI.Time T1 = 1 \"Lead time constant\";\n  parameter SI.Time T2 = 10 \"Lag time constant\";\n  parameter Real yMax = 1 \"Upper limits of output signal\";\n  parameter Real yMin = -yMax \"Lower limits of output signal\";\n  parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\" annotation(\n   Dialog(group = \"Initialization\"));\n  parameter Real yStart = 0 \"Initial or guess value of output (= state)\" annotation(\n   Dialog(group = \"Initialization\"));\n  parameter Boolean strict = false \"= true, if strict limits with noEvent(..)\" annotation(\n    Evaluate = true,\n    choices(checkBox = true),\n    Dialog(tab = \"Advanced\"));\n  Modelica.Blocks.Math.Gain gain_dir(k = k * T1 / T2) annotation(\n    Placement(visible = true, transformation(origin = {-4, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Nonlinear.Limiter limiter_y(strict = strict, uMax = yMax, uMin = yMin) annotation(\n    Placement(visible = true, transformation(origin = {32, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Feedback feedback_y annotation(\n    Placement(visible = true, transformation(origin = {46, -52}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.Integrator integ_fb(initType = initType, k = 1 / T1, y_start = yStart) annotation(\n    Placement(visible = true, transformation(origin = {10, -52}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain gain_fb(k = (1 - T2 / T1) / k) annotation(\n    Placement(visible = true, transformation(origin = {-60, -28}, extent = {{-10, -10}, {10, 10}}, rotation = 90)));\n  Modelica.Blocks.Math.Feedback feedback_u annotation(\n    Placement(visible = true, transformation(origin = {-60, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert(T1 > 0, \"T1 must be positive\");\n  assert(T2 > 0, \"T2 must be positive\");\nequation\n  connect(gain_fb.y, feedback_u.u2) annotation(\n    Line(points = {{-60, -17}, {-60, -8}}, color = {0, 0, 127}));\n  connect(integ_fb.y, gain_fb.u) annotation(\n    Line(points = {{1, -52}, {-60, -52}, {-60, -40}}, color = {0, 0, 127}));\n  connect(feedback_u.y, gain_dir.u) annotation(\n    Line(points = {{-51, 0}, {-16, 0}}, color = {0, 0, 127}));\n  connect(u, feedback_u.u1) annotation(\n    Line(points = {{-120, 0}, {-68, 0}}, color = {0, 0, 127}));\n  connect(integ_fb.y, feedback_y.u2) annotation(\n    Line(points = {{-1, -52}, {-15, -52}, {-15, -74}, {45, -74}, {45, -60}, {46, -60}}, color = {0, 0, 127}));\n  connect(feedback_y.y, integ_fb.u) annotation(\n    Line(points = {{37, -52}, {23, -52}}, color = {0, 0, 127}));\n  connect(limiter_y.y, feedback_y.u1) annotation(\n    Line(points = {{43, 0}, {67, 0}, {67, -52}, {54, -52}}, color = {0, 0, 127}));\n  connect(limiter_y.y, y) annotation(\n    Line(points = {{45, 0}, {110, 0}}, color = {0, 0, 127}));\n  connect(gain_dir.y, limiter_y.u) annotation(\n    Line(points = {{7, 0}, {13, 0}, {13, 0}, {19, 0}, {19, 0}, {19, 0}, {19, 0}, {19, 0}}, color = {0, 0, 127}));\nend LeadLagWithNonWindupLimiter;\n```\nModel description:\nModel to implement a lead-lag filter:\n\ty\t1 + s*T1\n\t- = k *    -----------\n\tu\t1 + s*T2\nIt is required that T1 > 0 and T2 > 0.\nOutput limiter with anti-windup is also implemented.\n\nPrompt:\nUse this model to test the Lead-lag filter with non-windup limiter of a signal, where the instances has T1 = 1, T2 = 2, initType = Modelica.Blocks.Types.Init.SteadyState, k = 2, yMax = 5, yMin = -5, yStart = 2, the inputsignal is implemented by Modelica.Blocks.Sources.TimeTable with table = [0, 1; 1, 1; 1, 4; 10, 4; 10, -4; 100, -4].\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LeadLagWithNonWindupLimiter\n  PowerGrids.Controls.LeadLagWithNonWindupLimiter leadlag_test(\n    T1 = 1,\n    T2 = 2,\n    initType = Modelica.Blocks.Types.Init.SteadyState,\n    k = 2,\n    yMax = 5,\n    yMin = -5,\n    yStart = 2);\n  Modelica.Blocks.Sources.TimeTable timetable(table = [0, 1; 1, 1; 1, 4; 10, 4; 10, -4; 100, -4]);\nequation\n  connect(timetable.y, leadlag_test.u);\nend Test_LeadLagWithNonWindupLimiter;\n",
            "feature": ""
        },
        {
            "id": 57,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel IntegratorWithNonWindupLimiter \"Integrator with non-windup limiter\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real k(unit = \"1/s\") = 1 \"Integral constant\";\n  parameter Real yMax = 1 \"Upper limits of output signal\";\n  parameter Real yMin = -yMax \"Lower limits of output signal\";\n  parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\" annotation(\n    Evaluate = true,\n    Dialog(group = \"Initialization\"));\n  parameter Real yStart = 0 \"Initial or guess value of output (= state)\" annotation(\n    Dialog(group = \"Initialization\"));\n  parameter Boolean strict = false \"= true, if strict limits with noEvent(..)\" annotation(\n    Evaluate = true,\n    choices(checkBox = true),\n    Dialog(tab = \"Advanced\"));\n  Modelica.Blocks.Nonlinear.Limiter lim(strict = strict, uMax = yMax, uMin = yMin) annotation(\n    Placement(visible = true, transformation(origin = {32, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.Integrator I(initType = initType, k = k, y_start = yStart) annotation(\n    Placement(visible = true, transformation(origin = {-24, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\nequation\n  connect(I.y, lim.u) annotation(\n    Line(points = {{-13, 0}, {20, 0}}, color = {0, 0, 127}));\n  connect(lim.y, y) annotation(\n    Line(points = {{43, 0}, {110, 0}}, color = {0, 0, 127}));\n  // The simplified model has no saturation, to make the controller equations linear\n  I.u = homotopy(\n    actual = if (u*k > 0 and lim.u > lim.uMax) or (u*k < 0 and lim.u < lim.uMin) then 0 else u,\n    simplified = u);\nend IntegratorWithNonWindupLimiter;\n```\nModel description:\nModel to implement an integrator filter:\n\ty     k\n\t- = -----\n\tu     s\nIt is required that k > 0K\nOutput limiter with anti-windup is also implemented.\n\nPrompt:\nUse this model to test the Integrator with non-windup limiter of a signal, where the instances has initType = Modelica.Blocks.Types.Init.InitialOutput, k = 2, yMax = 4, the inputsignal is implemented by Modelica.Blocks.Sources.TimeTable with table = [0, 0; 1, 0; 1, 1; 5, 1; 5, -1; 100, -1].\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_IntegratorWithNonWindupLimiter\n  PowerGrids.Controls.IntegratorWithNonWindupLimiter integratorWithNonWindupLimiter(\n    initType=Modelica.Blocks.Types.Init.InitialOutput,\n    k=2,\n    yMax=4);\n  Modelica.Blocks.Sources.TimeTable signal(\n    startTime=0,\n    table=[0, 0; 1, 0; 1, 1; 5, 1; 5, -1; 100, -1]);\nequation\n  connect(signal.y, integratorWithNonWindupLimiter.u);\nend Test_IntegratorWithNonWindupLimiter;\n",
            "feature": ""
        },
        {
            "id": 58,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel PIWithNonWindupLimiter \"Proportional-Integral filter with non-windup limiter\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real Kp \"Proportional gain\";\n  parameter Real Ki(unit = \"1/s\") = 0 \"Integral constant\";\n  parameter Boolean noDynamics = not(Ki > 0) and not(Ki < 0) \"Trivial configuration with no dynamics G(s) = k\";\n  parameter Real yMax = 1 \"Upper limits of output signal\";\n  parameter Real yMin = -yMax \"Lower limits of output signal\";\n  parameter Modelica.Blocks.Types.Init initType = Modelica.Blocks.Types.Init.InitialState \"Type of initialization (1: no init, 2: steady state, 3,4: initial output)\" annotation(\n    Evaluate = true,\n    Dialog(group = \"Initialization\"));\n  parameter Real yStart = 0 \"Initial or guess value of output (= state)\" annotation(\n    Dialog(group = \"Initialization\"));\n  parameter Boolean strict = false \"= true, if strict limits with noEvent(..)\" annotation(\n    Evaluate = true,\n    choices(checkBox = true),\n    Dialog(tab = \"Advanced\"));\n  Modelica.Blocks.Nonlinear.Limiter lim(strict = strict, uMax = yMax, uMin = yMin) annotation(\n    Placement(visible = true, transformation(origin = {0, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Feedback feedback annotation(\n    Placement(visible = true, transformation(origin = {-40, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Gain G(k = Kp) annotation(\n    Placement(visible = true, transformation(origin = {-72, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.FirstOrder firstOrder(T = Kp / Ki, initType = initType, k = -1, y_start = -yStart) if not noDynamics  annotation(\n    Placement(visible = true, transformation(origin = {0, -40}, extent = {{10, -10}, {-10, 10}}, rotation = 0)));\n  Modelica.Blocks.Sources.RealExpression zero if noDynamics annotation(\n    Placement(visible = true, transformation(origin = {-90, -40}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\ninitial equation\n  assert(Kp*Ki >= 0, \"Kp and Ki must not have opposite sign\");\nequation\n  connect(zero.y, feedback.u2) annotation(\n    Line(points = {{-78, -40}, {-40, -40}, {-40, -8}, {-40, -8}}, color = {0, 0, 127}, pattern = LinePattern.Dash));\n  connect(feedback.y, lim.u) annotation(\n    Line(points = {{-30, 0}, {-12, 0}, {-12, 0}, {-12, 0}}, color = {0, 0, 127}));\n  connect(G.y, feedback.u1) annotation(\n    Line(points = {{-60, 0}, {-48, 0}}, color = {0, 0, 127}));\n  connect(firstOrder.y, feedback.u2) annotation(\n    Line(points = {{-12, -40}, {-40, -40}, {-40, -8}}, color = {0, 0, 127}));\n  connect(u, G.u) annotation(\n    Line(points = {{-120, 0}, {-84, 0}, {-84, 0}, {-84, 0}}, color = {0, 0, 127}));\n  connect(lim.y, firstOrder.u) annotation(\n    Line(points = {{12, 0}, {36, 0}, {36, -40}, {12, -40}, {12, -40}}, color = {0, 0, 127}));\n  connect(lim.y, y) annotation(\n    Line(points = {{11, 0}, {110, 0}}, color = {0, 0, 127}));\nend PIWithNonWindupLimiter;\n```\nModel description:\nModel to implement a Proportional-Integral filter:\n\ty         Ki\n\t- = Kp + \n\tu         s\nOutput limiter with anti-windup is also implemented.\n\nPrompt:\nUse this model to test the Proportional-Integral filter with non-windup limiter of a signal, where the instances has Ki = 4, Kp = 2, initType = Modelica.Blocks.Types.Init.InitialOutput, yMax = 10, the inputsignal is implemented by Modelica.Blocks.Sources.TimeTable with table = [0, 0; 1, 0; 1, 1; 5, 1; 5, -1; 100, -1].\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_PIWithNonWindupLimiter\n  PowerGrids.Controls.PIWithNonWindupLimiter pidFilter(\n    Ki = 4, \n    Kp = 2, \n    initType = Modelica.Blocks.Types.Init.InitialOutput, \n    yMax = 10);\n  Modelica.Blocks.Sources.TimeTable inputSignal(\n    table = [0, 0; 1, 0; 1, 1; 5, 1; 5, -1; 100, -1]);\nequation\n  connect(inputSignal.y, pidFilter.u);\nend Test_PIWithNonWindupLimiter;\n",
            "feature": ""
        },
        {
            "id": 59,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel DeadBand \"Dead-Band\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real uMax(start=1) \"Upper limits of dead zones\";\n  parameter Real uMin=-uMax \"Lower limits of dead zones\";\n  parameter Boolean smoothed = false \"Smooth operator is applied\" annotation(\n    choices(checkBox = true));\n \nequation\n  assert(uMax >= uMin, \"Limits must be consistent\");\n  if smoothed then\n    // The simplified model has no saturation, to make the controller equations linear\n    y = homotopy(\n      actual = smooth(0, if u < uMin then u - uMin elseif u > uMax then u - uMax else 0),\n      simplified = u);  \n  else\n    // The simplified model has no saturation, to make the controller equations linear\n    y = homotopy(\n      actual = if u < uMin then u - uMin elseif u > uMax then u - uMax else 0,\n      simplified = u);  \n  end if;\nend DeadBand;\n```\nModel description:\nModel to implement a continuous dead-band:\nAsymmetric dead-band is allowed,\nIf smoothed checkbox is checked than the smooth operator is applied.\nDuring initialization the homotopy operator is applied, the simplified model is y = u.\n\nPrompt:\nUse this model to test the continuous dead-band of a signal, where the instances has smoothed = false, uMax = 1, the inputsignal is implemented by Modelica.Blocks.Sources.RealExpression with y = time - 2.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_DeadBand\n  PowerGrids.Controls.DeadBand deadBand(smoothed = false, uMax = 1);\n  Modelica.Blocks.Sources.RealExpression inputSignal(y = time - 2);\nequation\n  connect(inputSignal.y, deadBand.u);\nend Test_DeadBand;\n",
            "feature": ""
        },
        {
            "id": 60,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nmodel DiscontinuousDeadBand \"Discontinuous dead-band\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real uMax(start=1) \"Upper limits of dead zones\";\n  parameter Real uMin=-uMax \"Lower limits of dead zones\";\n  parameter Boolean smoothed = false \"Smooth operator is applied\" annotation(\n    choices(checkBox = true));\n \nequation\n  assert(uMax >= uMin, \"Limits must be consistent\");\n  if smoothed then\n    // The simplified model has no saturation, to make the controller equations linear\n    y = homotopy(\n      actual = smooth(0, if u < uMin then u elseif u > uMax then u else 0),\n      simplified = u);  \n  else\n    // The simplified model has no saturation, to make the controller equations linear\n    y = homotopy(\n      actual = if u < uMin then u elseif u > uMax then u else 0,\n      simplified = u);  \n  end if;\nend DiscontinuousDeadBand;\n```\nModel description:\nModel to implement a discontinuous dead-band:\nAsymmetric dead-band is allowed,\nIf smoothed checkbox is checked than the smooth operator is applied.\nDuring initialization the homotopy operator is applied, the simplified model is y = u.\n\nPrompt:\nUse this model to test the discontinuous dead-band of a signal, where the instances has uMax = 1, the inputsignal is implemented by Modelica.Blocks.Sources.RealExpression with y = time - 2.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_DiscontinuousDeadBand\n  PowerGrids.Controls.DiscontinuousDeadBand discDeadBand(uMax = 1);\n  Modelica.Blocks.Sources.RealExpression realExpression(y = time - 2);\nequation\n  connect(realExpression.y, discDeadBand.u);\nend Test_DiscontinuousDeadBand;\n",
            "feature": ""
        },
        {
            "id": 61,
            "instruction": "Modelica model:```\nwithin PowerGrids.Controls;\nblock LimiterWithLag\n  extends Modelica.Blocks.Interfaces.SISO;\n  \n  encapsulated type State = enumeration(\n    upperSat \"Upper limit reached\",\n    lowerSat \"Lower limit reached\",\n    notSat   \"u is in range\"\n  );\n  \n  parameter Real uMax  \"Upper limit\";\n  parameter Real uMin  \"Lower limit\";\n  parameter Types.Time LagMax  \"Time lag before taking action when u going above uMax\";\n  parameter Types.Time LagMin  \"Time lag before taking action when u going below uMin\";\n  parameter State stateStart = State.notSat \"saturation initial state\";\n  final parameter Boolean useLag = (LagMax > 0) or (LagMin > 0) \"Lags are used only if at least one is not null\";\n  \n  State state(start = stateStart, fixed = true) \"saturation state\";\n  discrete SI.Time saturationLimitReached(start = 0, fixed = true) \"Time in which the saturation limit is reached\";\n  Boolean satON \"Saturation is active\";\n\nalgorithm  \n  when u > uMax then\n    state := State.upperSat;\n    saturationLimitReached := time;\n  end when;  \n\n  when u < uMin then\n    state := State.lowerSat;\n    saturationLimitReached := time;\n  end when;  \n\n  when u < uMax and u > uMin then  \n    state := State.notSat;\n  end when;     \n\n  when useLag and state == State.notSat then\n    satON := false;\n  elsewhen useLag and state == State.upperSat and (time - saturationLimitReached) > LagMax then\n    satON := true;\n  elsewhen useLag and state == State.lowerSat and (time - saturationLimitReached) > LagMin then\n    satON := true;\n  end when;\n\n  if not useLag then\n    satON := true;\n  end if;\n    \nequation\n  // The simplified model has no saturation, to make the controller equations linear\n  y = homotopy(\n    actual = if state == State.upperSat and satON then uMax \n             elseif state == State.lowerSat and satON then uMin\n             else u,\n    simplified =  u);\nend LimiterWithLag;\n```\nModel description:\nModel of Limiter that enforces saturations only after they were violated without interruption during a certain amount of time.\nSwitching from saturated to non saturated mode has no lag.\nDifferent lag can be set for upper and lower saturations.\nSaturated or not saturated initial state can be selected, if a saturated initial state is selected then it remain active until a change from saturated to not saturated state is detected.\n\nPrompt:\nUse this model to test the LimiterWithLag of a signal, where the instances has LagMax = 2, LagMin = 3, uMax = 0.7, uMin = 0.3, the inputsignal is implemented by  Modelica.Blocks.Math.Sum, it is the sum of two Modelica.Blocks.Sources.Trapezoid signals with falling = 0.5, nperiod = 2, period = 10, rising = 0.5, width = 4 and falling = 0.5, nperiod = 4, period = 4, rising = 0.5, startTime = 20, width = 1.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LimiterWithLag\n  PowerGrids.Controls.LimiterWithLag LimiterWithLag1(\n    LagMin = 3, \n    LagMax = 2, \n    uMax = 0.7, \n    uMin = 0.3);\n  Modelica.Blocks.Sources.Trapezoid LfSignal(\n    falling = 0.5, \n    nperiod = 2, \n    rising = 0.5, \n    period = 10, \n    width = 4);\n  Modelica.Blocks.Sources.Trapezoid HfSignal(\n    falling = 0.5, \n    nperiod = 4, \n    period = 4, \n    rising = 0.5, \n    startTime = 20, \n    width = 1);\n  Modelica.Blocks.Math.Sum sum1(nin = 2);\nequation\n  connect(LfSignal.y, sum1.u[1]);\n  connect(HfSignal.y, sum1.u[2]);\n  connect(sum1.y, LimiterWithLag1.u);\nend Test_LimiterWithLag;\n",
            "feature": ""
        },
        {
            "id": 62,
            "instruction": "Modelica model:```\nwithin PowerGrids.Functions;\n\nfunction largerTimeConstant\n  extends Modelica.Icons.Function;\n  input Real a;\n  input Real b;\n  output Real T;\nalgorithm\n  T := (a + sqrt(abs(a^2-4*b)))/2;\nend largerTimeConstant;\n```\nModel description:\nGiven a polynomial (1 + sT1)(1 + sT2) = 1 + as + bs^2, with T1 > T2, largerTimeConstant(a, b) returns T2.\n\nPrompt:\nUse this model to solve the larger Time Constant, where the input is 8 and 15. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_largerTimeConstant\n  Real T;\nalgorithm\n  T := PowerGrids.Functions.largerTimeConstant(a=8, b=15);\nend Test_largerTimeConstant;\n",
            "feature": ""
        },
        {
            "id": 63,
            "instruction": "Modelica model:```\nwithin PowerGrids.Functions;\n\nfunction smallerTimeConstant\n  extends Modelica.Icons.Function;\n  input Real a;\n  input Real b;\n  output Real T;\nalgorithm\n  T := 2*b/(a + sqrt(abs(a^2-4*b)));\nend smallerTimeConstant;\n```\nModel description:\nGiven a polynomial (1 + sT1)(1 + sT2) = 1 + as + bs^2, with T1 > T2, largerTimeConstant(a, b) returns T1.\n\nPrompt:\nUse this model to solve the smaller Time Constant, where the input is 8 and 15. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_smallerTimeConstant\n  Real T;\nalgorithm\n  T := PowerGrids.Functions.smallerTimeConstant(a=8, b=15);\nend Test_smallerTimeConstant;\n",
            "feature": ""
        },
        {
            "id": 64,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction angle\n  extends Modelica.Icons.Function;\n  input Complex u;\n  output Real y;\nalgorithm\n  y := atan2(u.im,u.re);\nend angle;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the angle of a complex number, where u.im=3, u.re=4. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_angle\n  Complex u(re=4, im=3);\n  Modelica.Units.SI.Angle y;\nequation\n  y = AES.Functions.angle(u);\nend Test_angle;\n",
            "feature": ""
        },
        {
            "id": 65,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction conjugate\n  extends Modelica.Icons.Function;\n  input Complex u;\n  output Complex y;\nalgorithm\n  y.re := u.re;\n  y.im := -u.im;\nend conjugate;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the conjugate of a complex number, where u.im=3, u.re=4. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_conjugate\n   Complex u=Complex(4,3);\n   Complex y;\nequation\n  y=AES.Functions.conjugate(u);\nend Test_conjugate;\n",
            "feature": ""
        },
        {
            "id": 66,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction conv\n  extends Modelica.Icons.Function;\n\n  input Real[:] cp1 \"coeffs of poly 1 (dec pwr)\";\n  input Real[:] cp2 \"coeffs of poly 2 (dec pwr)\";\n  output Real[size(cp1,1)+size(cp2,1)-1] cpo  \"coeffs of product (dec pwr)\";\nprotected \n  Integer n1,n2;  \nalgorithm\n \n  n1 := size(cp1,1);\n  n2 := size(cp2,1);\n\n  for i in 1:n1+n2-1 loop\n    cpo[i] := 0;\n    for j in 1:n2 loop\n        if i-j+1>0 and i-j+1<=n1 then\n           cpo[i] := cpo[i]+cp1[i-j+1]*cp2[j];\n        end if;\n    end for;\nend for;\n\nend conv;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the convolution, where the input cp1={1,2,3,1}, cp2={3,5}.  Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_conv\n  Real cp1[4]={1,2,3,1};\n  Real cp2[2]={3,5};\n  Real[5] cpo;\nequation\n  cpo = AES.Functions.conv(cp1, cp2);\nend Test_conv;\n",
            "feature": ""
        },
        {
            "id": 67,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction magnitude\n  extends Modelica.Icons.Function;\n  input Complex u;\n  output Real y;\nalgorithm\n  y := sqrt(u.re^2+u.im^2);\nend magnitude;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the magnitude of a complex number, where u.im=3, u.re=4.  Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_magnitude\n  parameter Complex u = Complex(re=4, im=3);\n  Real y;\nequation\n  y=AES.Functions.magnitude(u);\nend Test_magnitude;\n",
            "feature": ""
        },
        {
            "id": 68,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction sqrtReg \"Symmetric square root approximation with finite derivative in zero\"\n  extends Modelica.Icons.Function;\n  input Real x;\n  input Real delta = 0.01 \"Range of significant deviation from sqrt(x)\";\n  output Real y;\nalgorithm\n  y := x / sqrt(sqrt(x * x + delta * delta));\n  annotation(derivative(zeroDerivative = delta)=Functions.sqrtReg_der,\n    Documentation(info = \"<html>\n<p>This function approximates square root, such that the derivative is finite in zero.</p>\n</html>\"));\nend sqrtReg;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the symmetric square root approximation with finite derivative in zero of a real number, where x=3.1415926. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_sqrtReg\n  Real y;\nequation\n  y = AES.Functions.sqrtReg(x=3.1415926);\nend Test_sqrtReg;\n",
            "feature": ""
        },
        {
            "id": 69,
            "instruction": "Modelica model:```\nwithin AES.Functions;\nfunction sqrtReg_der \"Derivative of sqrtReg\"\n  extends Modelica.Icons.Function;\n  input Real x;\n  input Real delta = 0.01 \"Range of significant deviation from sqrt(x)\";\n  input Real dx \"Derivative of x\";\n  output Real dy;\nalgorithm\n  dy := dx * 0.5 * (x * x + 2 * delta * delta) / (x * x + delta * delta) ^ 1.25;\nend sqrtReg_der;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the derivative of sqrtReg, where x=3.1415926, delta = 0.01 and dx = 0.1. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_sqrtReg_der\n  Real y;\nequation\n  y = AES.Functions.sqrtReg_der(x=3.1415926,delta=0.01,dx=0.1);\nend Test_sqrtReg_der;\n",
            "feature": ""
        },
        {
            "id": 70,
            "instruction": "Modelica model:```\nwithin AES.Functions;\nfunction layer_fcf_distances \"face-centres-face\" \n  extends Modelica.Icons.Function;\n  input Real s[:] \"layer thicknesses\";\n  output Real d[size(s,1) + 1];\nprotected\n  Integer n;\nalgorithm\n  n := size(s,1);\n  d[1] := s[1] / 2;\n  d[n + 1] := s[n] / 2;\n  for i in 2:n loop\n    d[i] := s[i - 1] / 2 + s[i] / 2;\n  end for;\nend layer_fcf_distances;\n```\nModel description:\nThis function that sets the thickness in each layer component, given as input the number of layers and each thickness.\n\nPrompt:\nCall this function to calculate the layer face-centres-face distances, where the layer thicknesses s={1,2,3,1}. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_layer_fcf_distances\n  Real a[4] = {1,2,3,1};\n  Real d[5];\nequation\n  d = AES.Functions.layer_fcf_distances(a);\nend Test_layer_fcf_distances;\n",
            "feature": ""
        },
        {
            "id": 71,
            "instruction": "Modelica model:```\nwithin AES.Functions;\nfunction layer_fcf_conductivities \"face-centres-face\"\n  extends Modelica.Icons.Function;\n  input Real s[:];\n  input Real lambda[:];\n  output Real L[size(s,1) + 1];\nprotected\n  Integer n;\nalgorithm\n  n := size(s,1);\n  L[1] := lambda[1];\n  L[n + 1] := lambda[n];\n  for i in 2:n loop\n    L[i] := lambda[i - 1] * lambda[i]\n            / (s[i - 1] * lambda[i] + s[i] * lambda[i - 1])\n            * (s[i - 1] + s[i]);\n  end for;\nend layer_fcf_conductivities;\n```\nModel description:\nThis function that sets the conductivities in each layer component, given as input the number of layers , each thickness and thermal conductivities.\n\nPrompt:\nCall this function to calculate the layer face-centres-face conductivities, where the layer thicknesses s={1,2,3,1}, thermal conductivities lambda={1.5,2,1.5,2}. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_layer_fcf_conductivities\n  Real s[4]={1,2,3,1};\n  Real lambda[4]={1.5,2,1.5,2};\n  Real d[5];\nequation\n  d = AES.Functions.layer_fcf_conductivities(s, lambda);\nend Test_layer_fcf_conductivities;\n",
            "feature": ""
        },
        {
            "id": 72,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction sod \"second of day (0-86399)\"\n  extends Modelica.Icons.Function;\n  input Real t;\n  input Real hour_start=0;\n  input Real min_start=0;\n  input Real sec_start=0;\n  output Real y;\nalgorithm\n  y := mod(t+3600*hour_start+60*min_start+sec_start,86400);\nend sod;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the second of day, where the t=15, hour_start=8, min_start=0, sec_start=28. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_sod\n  Real y;\nequation\n  y = AES.Functions.sod(15, 8, 0, 28);\nend Test_sod;\n",
            "feature": ""
        },
        {
            "id": 73,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction hod \"hour of day (0-23)\"\n  extends Modelica.Icons.Function;\n  input Real t;\n  input Real hour_start=0;\n  input Real min_start=0;\n  input Real sec_start=0;\n  output Real y;\nalgorithm\n  y := 1.0*(floor(Functions.sod(t,hour_start,min_start,sec_start)/3600));\nend hod;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the hour of day, where the t=15, hour_start=8, min_start=0, sec_start=28. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_hod\n Real y;\nequation\n  y = AES.Functions.hod(15,8,0,28);\nend Test_hod;\n",
            "feature": ""
        },
        {
            "id": 74,
            "instruction": "Modelica model:```\nwithin AES.Functions;\n\nfunction moh \"minute of hour (0-59)\"\n  extends Modelica.Icons.Function;\n  input Real t;\n  input Real hour_start=0;\n  input Real min_start=0;\n  input Real sec_start=0;\n  output Real y;\nprotected\n  Real s,h;\nalgorithm\n  s := Functions.sod(t,hour_start,min_start,sec_start);\n  h := Functions.hod(t,hour_start,min_start,sec_start);\n  y := 1.0*(floor((s-3600*h)/60));\nend moh;\n```\nModel description:\n\nPrompt:\nCall this function to calculate the minute of day, where the t=15, hour_start=8, min_start=0, sec_start=28. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_moh\n  Real y;\nequation\n  y = AES.Functions.moh(15,8,0,28);\nend Test_moh;\n",
            "feature": ""
        },
        {
            "id": 75,
            "instruction": "Modelica model:```\nwithin AES.Media.Substances;\n\nmodel MoistAir \"Moist air\"\n  extends Modelica.Icons.MaterialProperty;\n  import MAC = AES.Media.Constants;\n  input SI.Pressure p \"pressure\";\n  input SI.Temperature T \"temperature\";\n  input SI.MassFraction X \"absolute humidity [kg vap/kg da]\";\n  //-----------------------------------------------------------------------------\n  SI.MassFraction x \"vapour mass fraction [kg vap/kg tot]\";\n  SI.Pressure pv \"vapour partial pressure\";\n  SI.Pressure pvs \"vapour saturation pressure\";\n  Real phi \"relative humidity\";\n  SI.Temperature Twb \"wet bulb temperature\";\n  SI.MassFraction Xs \"absolute humidity [kg vap/kg da] at saturation (phi=1)\";\n  SI.MassFraction xs \"vapour fraction [kg vap/kg tot] at saturation (phi=1)\";\n  SI.SpecificEnthalpy ha \"specific enthalpy of dry air [J/kg da]\";\n  SI.SpecificEnthalpy hv \"specific enthalpy of vapour [J/kg vap]\";\n  SI.SpecificEnthalpy h \"specific enthalpy of moist air [J/kg da]\";\n  SI.SpecificEnthalpy hl \"specific enthalpy of liquid water at T [J/kg liq]\";\n  SI.Density d \"density of moist air\";\n  SI.SpecificHeatCapacity cp \"moist air specific heat capacity [J/kg da K]\";\n  SI.SpecificHeatCapacity R \"equivalent gas constant of moist air\";\nprotected\n  Real Tc;\nequation\n  Tc  = T-273.15;\n  x   = X / (1 + X);\n  x   = pv/p;\n  phi = pv/pvs;\n  Xs  = pvs/(p-pvs)*MAC.MMw/MAC.MMa;\n  xs  = Xs / (1 + Xs);\n  pvs = exp(6.41542+2.302585*Tc/(31.614894+0.1327603*Tc+1.5593343e-5*Tc^2));\n\n  pv = 610.78 * exp((Twb - 273.15) / (Twb - 273.15 + 238.3) * 17.2694) \"for Twb\";\n  /*pvs = p * (Xs / 0.622) / (1 + Xs / 0.622) \"for Xs\"; */\n  \n  \n  ha = MAC.cp_a * Tc;\n  hv = MAC.h_v_3pt + MAC.cp_v * Tc;\n  h = ha + X * hv;\n  hl = MAC.cp_l * Tc;\n  d = (p - pv) / (MAC.Ra * T) + pv / (MAC.Rv * T);\n  cp = MAC.cp_a + X * MAC.cp_v;\n  R = MAC.Ra*(1-x) + MAC.Rv * x;\nend MoistAir;\n```\nModel description:\nThis is the moist air model that is based on Mollier Diagram.\nIn the HVAC systems, the air is generally considered as a binary mixture of dry air and water vapor, i.e. moist air. State properties of moist air are calculated by using the Dalton’s law on perfect gas mixtures.\nIn order to find out the thermodynamic state of the moist air, we use the Gibbs’ phase rule\nF = C − P + 2\nwhere C is the number of components (in this case, vapor and dry air), P the number of phases in thermodynamic equilibrium (in this case the only phase is the gas one), and F the number of degrees of freedom.\nThus, dealing with moist air, C is two (vapor and dry air), P is one (gas phase only) and therefore F is equal to three. So we need to know the total pressure, the specific enthalpy h (using convetion that h=0 if T=0°C and no water vapour is present), and the mass fraction X, which is the vapor and dry air mass ratio.\n\nPrompt:\nUse this model to simulate the moist air, where the pressure p=800000, the temperature T=375.15 and the absolute humidity X=15. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_MoistAir\n  AES.Media.Substances.MoistAir MoistAir(p=800000,T=375.15,X=15);\nend Test_MoistAir;\n",
            "feature": ""
        },
        {
            "id": 76,
            "instruction": "Modelica model:```\nwithin AES.ProcessBlocks;\n\nmodel FOPDT\nextends Icons.ProcessBlock;\n  parameter Real mu=1 \"gain\";\n  parameter Real T=1 \"time constant\";\n  parameter Real D=0 \"delay\";\n  parameter Real ystart=0 \"initial output\";\n  \n  Modelica.Blocks.Interfaces.RealInput u annotation(\n    Placement(visible = true, transformation(origin = {-100, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-98, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealOutput y annotation(\n    Placement(visible = true, transformation(origin = {102, -3.55271e-15}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {98, -2}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Continuous.FirstOrder Pr(T = T, k = mu, y(fixed = true), y_start = ystart)  annotation(\n    Placement(visible = true, transformation(origin = {-32, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Nonlinear.FixedDelay Pd(delayTime = D)  annotation(\n    Placement(visible = true, transformation(origin = {30, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\nequation\n  connect(Pr.y, Pd.u) annotation(\n    Line(points = {{-20, 0}, {16, 0}, {16, 0}, {18, 0}}, color = {0, 0, 127}));\n  connect(Pd.y, y) annotation(\n    Line(points = {{42, 0}, {88, 0}, {88, 0}, {102, 0}}, color = {0, 0, 127}));\n  connect(u, Pr.u) annotation(\n    Line(points = {{-100, 0}, {-42, 0}, {-42, 0}, {-44, 0}}, color = {0, 0, 127}));\nend FOPDT;\n```\nModel description:\n\nPrompt:\nUse this model to solve the FOPDT of a signal, where the time constant T=2, gain mu=1, the signal is implemented by Modelica.Blocks.Sources.RealExpression with y = if time < 1 then 0 else 1. The connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FOPDT\n  AES.ProcessBlocks.FOPDT fOPDT1(mu = 1, T = 2);\nModelica.Blocks.Sources.RealExpression y(y = if time < 1 then 0 else 1);\nequation\n  connect(y.y, fOPDT1.u);\nend Test_FOPDT;\n",
            "feature": ""
        },
        {
            "id": 77,
            "instruction": "Modelica model:```\nwithin AES.ProcessBlocks;\n\nmodel SOPDT_overdamped\n  extends Icons.ProcessBlock;\n  parameter Real mu = 1 \"gain\";\n  parameter Real T1 = 1 \"time constant 1\";\n  parameter Real T2 = 1 \"time constant 2\";\n  parameter Real D = 0 \"delay\";\n  parameter Real ystart = 0 \"initial output\";\n  Modelica.Blocks.Interfaces.RealInput u annotation(\n    Placement(visible = true, transformation(origin = {-100, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-98, 0}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealOutput y annotation(\n    Placement(visible = true, transformation(origin = {102, -3.55271e-15}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {98, -2}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Continuous.TransferFunction Pr(a = {T1 * T2, T1 + T2, 1}, b = {mu}, initType = Modelica.Blocks.Types.Init.InitialOutput, y_start = ystart) annotation(\n    Placement(visible = true, transformation(origin = {-32, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Nonlinear.FixedDelay Pd(delayTime = D) annotation(\n    Placement(visible = true, transformation(origin = {30, 0}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\nequation\n  connect(Pr.y, Pd.u) annotation(\n    Line(points = {{-20, 0}, {16, 0}, {16, 0}, {18, 0}}, color = {0, 0, 127}));\n  connect(Pd.y, y) annotation(\n    Line(points = {{42, 0}, {88, 0}, {88, 0}, {102, 0}}, color = {0, 0, 127}));\n  connect(u, Pr.u) annotation(\n    Line(points = {{-100, 0}, {-42, 0}, {-42, 0}, {-44, 0}}, color = {0, 0, 127}));\nend SOPDT_overdamped;\n```\nModel description:\n\nPrompt:\nUse this model to solve the SOPDT overdamped of a signal, where the time constant T1=2, T2=3, gain mu=1, the signal is implemented by Modelica.Blocks.Sources.RealExpression with y = if time < 1 then 0 else 1. The connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SOPDT_overdamped\n  AES.ProcessBlocks.SOPDT_overdamped sop(T2=3, T1=2, mu=1, D=1, ystart=0.0);\n  Modelica.Blocks.Sources.RealExpression realExpression(y = if time < 1 then 0 else 1);\nequation\n  connect(realExpression.y, sop.u);\nend Test_SOPDT_overdamped;\n",
            "feature": ""
        },
        {
            "id": 78,
            "instruction": "Modelica model:```\nwithin AES.ProcessBlocks;\n\nmodel TITO_rational_zeroInit\n  extends Icons.ProcessBlock;\n  parameter Real[:] P11n = {1};\n  parameter Real[:] P11d = {1,1};\n  parameter Real[:] P12n = {0.5};\n  parameter Real[:] P12d = {2,1};\n  parameter Real[:] P21n = {0.3};\n  parameter Real[:] P21d = {3,1};\n  parameter Real[:] P22n = {1.5};\n  parameter Real[:] P22d = {1.2,1};\n\n  Modelica.Blocks.Interfaces.RealOutput y1 annotation(\n    Placement(visible = true, transformation(origin = {180, 54}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {100, 40}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealInput u1 annotation(\n    Placement(visible = true, transformation(origin = {-140, 60}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-100, 40}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealInput u2 annotation(\n    Placement(visible = true, transformation(origin = {-140, -60}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {-100, -40}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealOutput y2 annotation(\n    Placement(visible = true, transformation(origin = {180, -54}, extent = {{-20, -20}, {20, 20}}, rotation = 0), iconTransformation(origin = {100, -40}, extent = {{-20, -20}, {20, 20}}, rotation = 0)));\n\nprotected\n  Modelica.Blocks.Continuous.TransferFunction P11(a = P11d, b = P11n, initType =  Modelica.Blocks.Types.Init.InitialOutput, y_start = 0) annotation(\n    Placement(visible = true, transformation(origin = {-10, 60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n\n  Modelica.Blocks.Continuous.TransferFunction P12(a = P12d, b = P12n, initType = Modelica.Blocks.Types.Init.InitialOutput, y_start = 0) annotation(\n    Placement(visible = true, transformation(origin = {-10, 20}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.TransferFunction P21(a = P21d, b = P21n, initType = Modelica.Blocks.Types.Init.InitialOutput, y_start = 0) annotation(\n    Placement(visible = true, transformation(origin = {-10, -20}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Continuous.TransferFunction P22(a = P22d, b = P22n, initType = Modelica.Blocks.Types.Init.InitialOutput, y_start = 0) annotation(\n    Placement(visible = true, transformation(origin = {-10, -60}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Add a1 annotation(\n    Placement(visible = true, transformation(origin = {110, 54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\n  Modelica.Blocks.Math.Add a2 annotation(\n    Placement(visible = true, transformation(origin = {110, -54}, extent = {{-10, -10}, {10, 10}}, rotation = 0)));\nequation\n  connect(P21.y, a2.u1) annotation(\n    Line(points = {{2, -20}, {60, -20}, {60, -48}, {98, -48}, {98, -48}}, color = {0, 0, 127}));\n  connect(u1, P21.u) annotation(\n    Line(points = {{-140, 60}, {-60, 60}, {-60, -20}, {-22, -20}, {-22, -20}}, color = {0, 0, 127}));\n  connect(u2, P12.u) annotation(\n    Line(points = {{-140, -60}, {-80, -60}, {-80, 20}, {-22, 20}, {-22, 20}}, color = {0, 0, 127}));\n  connect(P12.y, a1.u2) annotation(\n    Line(points = {{2, 20}, {60, 20}, {60, 48}, {98, 48}, {98, 48}}, color = {0, 0, 127}));\n  connect(a2.y, y2) annotation(\n    Line(points = {{122, -54}, {160, -54}, {160, -54}, {180, -54}}, color = {0, 0, 127}));\n  connect(P22.y, a2.u2) annotation(\n    Line(points = {{2, -60}, {98, -60}, {98, -60}, {98, -60}}, color = {0, 0, 127}));\n  connect(a1.y, y1) annotation(\n    Line(points = {{121, 54}, {180, 54}}, color = {0, 0, 127}));\n  connect(P11.y, a1.u1) annotation(\n    Line(points = {{1, 60}, {98, 60}}, color = {0, 0, 127}));\n  connect(u2, P22.u) annotation(\n    Line(points = {{-140, -60}, {-24, -60}, {-24, -60}, {-22, -60}}, color = {0, 0, 127}));\n  connect(u1, P11.u) annotation(\n    Line(points = {{-140, 60}, {-22, 60}}, color = {0, 0, 127}));\nend TITO_rational_zeroInit;\n```\nModel description:\n\nPrompt:\nUse this model to solve the TITO rational zeroInit of signals, where the signals are implemented by Modelica.Blocks.Sources.RealExpression with u1(y = if time < 10 then 0 else 1) and u2(y = if time < 1 then 0 else 1). The connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_TITO_rational_zeroInit\n  AES.ProcessBlocks.TITO_rational_zeroInit TITO;\n  Modelica.Blocks.Sources.RealExpression u1(y = if time < 10 then 0 else 1);\n  Modelica.Blocks.Sources.RealExpression u2(y = if time < 1 then 0 else 1);\nequation\n  connect(TITO.u1,u1.y);\n  connect(TITO.u2,u2.y);\nend Test_TITO_rational_zeroInit;\n",
            "feature": ""
        },
        {
            "id": 79,
            "instruction": "Modelica model:```\nwithin AES.ControlBlocks.ActuationSchemes;\n\nmodel SplitRange01\n  extends Icons.ControlBlock;\n  parameter Real DeadZone(final min = 1e-6, final max = 1 - 1e-6) = 0.1;\n  Modelica.Blocks.Interfaces.RealInput CSi01 annotation(\n  Placement(visible = true,transformation(extent = {{-100, -20}, {-60, 20}}, rotation = 0), iconTransformation(extent = {{-140, -20}, {-100, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealOutput CSo01_pos annotation(\n  Placement(visible = true,transformation(extent = {{60, 42}, {100, 82}}, rotation = 0), iconTransformation(extent = {{100, 40}, {140, 80}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealOutput CSo01_neg annotation(\n  Placement(visible = true,transformation(extent = {{60, -80}, {100, -40}}, rotation = 0), iconTransformation(extent = {{100, -80}, {140, -40}}, rotation = 0)));\nprotected\n  parameter Real a = 1 / (DeadZone - 1);\n  parameter Real b = DeadZone / (DeadZone - 1);\nequation\n  CSo01_pos = max(0, min(1, (-a * CSi01) + b));\n  CSo01_neg = max(0, min(1, a * CSi01 + b));\nend SplitRange01;\n```\nModel description:\n\nPrompt:\nUse this model to solve the Split Range of a signal, where the signal is implemented by Modelica.Blocks.Sources.RealExpression with y = time - 5. The connection of the signal is based on 'connect'.  Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SplitRange01\n  AES.ControlBlocks.ActuationSchemes.SplitRange01 splitRange01;\n  Modelica.Blocks.Sources.RealExpression CSi01(y = time - 5) ;\nequation\n  connect(CSi01.y,splitRange01.CSi01);\nend Test_SplitRange01;\n",
            "feature": ""
        },
        {
            "id": 80,
            "instruction": "Modelica model:```\nwithin IDEAS.Controls.Continuous;\nblock NumberOfRequests\n  \"Outputs the number of signals that are above/below a certain threshold\"\n   extends Modelica.Blocks.Icons.Block;\n\n  parameter Integer nin \"Number of inputs\";\n  parameter Real threShold = 0 \"Threshold\";\n  parameter Integer kind\n    \"Set to 0 for u>threShold, to 1 for >=, to 2 for <= or to 3 for <\";\n  Modelica.Blocks.Interfaces.IntegerOutput y\n    \"Number of input signals that violate the threshold\"\n    annotation (Placement(transformation(extent={{100,-10},{120,10}})));\n  Modelica.Blocks.Interfaces.RealInput u[nin] \"Input signals\"\n    annotation (Placement(transformation(extent={{-140,-20},{-100,20}})));\nalgorithm\n  y := 0;\n  for i in 1:nin loop\n    if kind == 0 then\n      if u[i] > threShold then\n        y := y+1;\n      end if;\n    end if;\n    if kind == 1 then\n      if u[i] >= threShold then\n        y := y+1;\n      end if;\n    end if;\n    if kind == 2 then\n      if u[i] <= threShold then\n        y := y+1;\n      end if;\n    end if;\n    if kind == 3 then\n      if u[i] < threShold then\n        y := y+1;\n      end if;\n    end if;\n  end for;\nend NumberOfRequests;\n```\nModel description:\nOutputs the number of signals that are above/below a certain threshold.\n\nPrompt:\nTest this model, where the the nin=2,  one of the input signals is implemented by Modelica.Blocks.Sources.Sine with f=2, and one of the input signals is implemented by Modelica.Blocks.Sources.Pulse with period=0.35.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NumberOfRequests\n  IDEAS.Controls.Continuous.NumberOfRequests req(nin=2);\n  Modelica.Blocks.Sources.Sine sin1(f=2);\n  Modelica.Blocks.Sources.Pulse pulse(period=0.35);\nequation\n  connect(sin1.y,req. u[1]) ;\n  connect(pulse.y,req. u[2]) ;\nend Test_NumberOfRequests;\n",
            "feature": ""
        },
        {
            "id": 81,
            "instruction": "Modelica model:```\nwithin IDEAS.Controls.Continuous;\nmodel OffTimer \"Records the time since the input changed to false\"\n  extends Modelica.Blocks.Icons.PartialBooleanBlock;\n\n  Modelica.Blocks.Interfaces.BooleanInput u \"Connector of Boolean input signal\"\n    annotation (Placement(transformation(\n          extent={{-140,-20},{-100,20}})));\n  Modelica.Blocks.Interfaces.RealOutput y \"Connector of Real output signal\"\n    annotation (Placement(transformation(extent={{100,-10},{120,10}})));\n\nprotected\n  discrete Modelica.Units.SI.Time entryTime \"Time instant when u became true\";\ninitial equation\n  pre(entryTime) = time;\nequation\n  when (not u) then\n    entryTime = time;\n  end when;\n  y = time - entryTime;\nend OffTimer;\n```\nModel description:\nRecords the time since the input changed to false.\n\nPrompt:\nTest this model, where the input signals is implemented by Modelica.Blocks.Sources.BooleanPulse with period=0.2. \nThe signal enters BooleanPulse after a logical \"not\".\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_OffTimer\nequation\n\nend Test_OffTimer;\n",
            "feature": ""
        },
        {
            "id": 82,
            "instruction": "Modelica model:```\nwithin IDEAS.Controls.Continuous;\nblock SignalRanker \"Ranks output signals such that y[i] >= y[i+1]\"\n   extends Modelica.Blocks.Interfaces.MIMO(final nout=nin);\nequation\n  y = Modelica.Math.Vectors.sort(u, ascending=false);\nend SignalRanker;\n```\nModel description:\nRanks output signals such that y[i] >= y[i+1].\n\nPrompt:\nTest this model, where the nin=3, one of the input signals is implemented by Modelica.Blocks.Sources.Sine with f=2, startTime=0.025, one of the input signals is implemented by Modelica.Blocks.Sources.Pulse with period=0.25, and one of the input signals is implemented by Modelica.Blocks.Sources.ExpSine with f=10, damping=1.\nThe connection of the signal is based on 'connect'.  Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SignalRanker\n  IDEAS.Controls.Continuous.SignalRanker signalRanker(nin=3);\n  Modelica.Blocks.Sources.Sine sine(f=2, startTime=0.025);\n  Modelica.Blocks.Sources.Pulse pulse(period=0.25);\n  Modelica.Blocks.Sources.ExpSine expSine(f=10, damping=1);\nequation\n  connect(sine.y, signalRanker.u[1]);\n  connect(pulse.y, signalRanker.u[2]);\n  connect(expSine.y, signalRanker.u[3]);\nend Test_SignalRanker;\n",
            "feature": ""
        },
        {
            "id": 83,
            "instruction": "Modelica model:```\nwithin IDEAS.Controls.Discrete;\nblock BooleanDelay \"Zero order hold for boolean variable\"\n  extends Modelica.Blocks.Interfaces.BooleanSISO;\n  extends Modelica.Blocks.Interfaces.DiscreteBlock(\n    firstTrigger(fixed=true,\n                 start=firstTrigger_start));\n  parameter Boolean firstTrigger_start=false\n    \"Start value for rising edge signals first sample instant\"\n    annotation (Dialog(tab=\"Initialization\"));\nprotected\n  Boolean ySample;\nalgorithm\n  when {sampleTrigger, initial()} then\n    y := ySample;\n    ySample := u;\n  end when;\nend BooleanDelay;\n```\nModel description:\nZero order hold for boolean variable.\n\nPrompt:\nTest this model, where the samplePeriod=0.05, the input signal is implemented by Modelica.Blocks.Sources.BooleanPulse with period=0.1, width=50, startTime=0.01. \nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_BooleanDelay\n  IDEAS.Controls.Discrete.BooleanDelay booleanDelay(y(fixed=true), samplePeriod=0.05);\n  Modelica.Blocks.Sources.BooleanPulse booleanPulse(period=0.1, startTime=0.01, width=50);\nequation\n  connect(booleanPulse.y, booleanDelay.u);\nend Test_BooleanDelay;\n",
            "feature": ""
        },
        {
            "id": 84,
            "instruction": "Modelica model:```\nwithin IDEAS.Controls.SetPoints;\nmodel Table\n  \"Model for a set point that is interpolated based on a user-specified table\"\n  extends Modelica.Blocks.Interfaces.SISO;\n  parameter Real table[:,2]=fill(0.0, 1, 2)\n    \"Table matrix ( e.g., table=[u1, y1; u2, y2; u3, y3])\";\n\n  parameter Real offset=0 \"Offset of output signal\";\n\n  parameter Boolean constantExtrapolation = true\n    \"If true, then y=y1 for u<u1, and y=yMax for u>uMax\";\n\nprotected\n  final parameter Integer nRow = if constantExtrapolation then\n                        size(table,1)+2 else\n                        size(table,1) \"Number of rows\";\n  final parameter Real[nRow,2] offsetVector = [zeros(nRow), offset*ones(nRow)]\n    \"Vector to take offset of output signal into account\";\n  Modelica.Blocks.Tables.CombiTable1Dv tab(tableOnFile=false, final table=(if\n        constantExtrapolation then cat(\n        1,\n        [table[1, 1] - 1,table[1, 2]],\n        table,\n        [table[end, 1] + 1,table[end, 2]]) else table) + offsetVector)\n    \"Table used for interpolation\"\n    annotation (Placement(transformation(extent={{-20,-10},{2,10}})));\nequation\n  connect(u, tab.u[1]) annotation (Line(\n      points={{-120,0},{-70,0},{-70,0},{-22,0}},\n      color={0,0,127}));\n\n  connect(tab.y[1], y) annotation (Line(\n      points={{3.1,0},{53.55,0},{53.55,0},{110,0}},\n      color={0,0,127}));\nend Table;\n```\nModel description:\nModel for a set point that is interpolated based on a user-specified table.\n\nPrompt:\nTest this model, where the table=[20,0; 22,0.5; 25,0.5; 26,1], the signal is implemented by Modelica.Blocks.Sources.Ramp with duration=1, offset=15, height=15.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Table\n  IDEAS.Controls.SetPoints.Table tableOnFile(\n    table=[20,0; 22,0.5; 25,0.5; 26,1]);\n  Modelica.Blocks.Sources.Ramp ramp(\n    duration=1,\n    offset=15,\n    height=15);\nequation\n  connect(ramp.y, tableOnFile.u);\nend Test_Table;\n",
            "feature": ""
        },
        {
            "id": 85,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.SimpleExample;\nmodel FirstOrder\n  Real x;\nequation\n  der(x) = 1-x;\nend FirstOrder;\n```\nModel description:\n\nPrompt:\nTest this model, where the initial value of x is 10.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_FirstOrder\n  ModelicaByExample.BasicEquations.SimpleExample.FirstOrder firstOrder(x(start=10));\nend Test_FirstOrder;\n",
            "feature": ""
        },
        {
            "id": 86,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.CoolingExample;\nmodel NewtonCooling \"An example of Newton's law of cooling\"\n  parameter Real T_inf \"Ambient temperature\";\n  parameter Real T0 \"Initial temperature\";\n  parameter Real h \"Convective cooling coefficient\";\n  parameter Real A \"Surface area\";\n  parameter Real m \"Mass of thermal capacitance\";\n  parameter Real c_p \"Specific heat\";\n  Real T \"Temperature\";\ninitial equation\n  T = T0 \"Specify initial value for T\";\nequation\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCooling;\n```\nModel description:\nAn example of Newton's law of cooling.\n\nPrompt:\nTest this model, where the ambient temperature T_inf=25, the initial temperature T0=90, the convective cooling coefficient h=0.7, the surface area A=1.0, the mass of thermal capacitance m=0.1 and the specific heat c_p=1.2.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NewtonCooling\n  ModelicaByExample.BasicEquations.CoolingExample.NewtonCooling newtonCooling(\n    T_inf=25, \n    T0=90, \n    h=0.7, \n    A=1.0, \n    m=0.1, \n    c_p=1.2);\nend Test_NewtonCooling;\n",
            "feature": ""
        },
        {
            "id": 87,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.RLC;\nmodel RLC1 \"A resistor-inductor-capacitor circuit model\"\n  type Voltage=Real(unit=\"V\");\n  type Current=Real(unit=\"A\");\n  type Resistance=Real(unit=\"Ohm\");\n  type Capacitance=Real(unit=\"F\");\n  type Inductance=Real(unit=\"H\");\n  parameter Voltage Vb=24 \"Battery voltage\";\n  parameter Inductance L = 1;\n  parameter Resistance R = 100;\n  parameter Capacitance C = 1e-3;\n  Voltage V;\n  Current i_L;\n  Current i_R;\n  Current i_C;\nequation\n  V = i_R*R;\n  C*der(V) = i_C;\n  L*der(i_L) = (Vb-V);\n  i_L=i_R+i_C;\nend RLC1;\n```\nModel description:\nA resistor-inductor-capacitor circuit model.\n\nPrompt:\nTest this model, where the inductance L = 2, the resistance R = 150 and the capacitance C = 1.2e-3.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RLC1\n  ModelicaByExample.BasicEquations.RLC.RLC1 RLC1(L=2, R=150, C=1.2e-3);\nend Test_RLC1;\n",
            "feature": ""
        },
        {
            "id": 88,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.RLC;\nmodel RLC2\n  type Voltage=Real(unit=\"V\");\n  type Current=Real(unit=\"A\");\n  type Resistance=Real(unit=\"Ohm\");\n  type Capacitance=Real(unit=\"F\");\n  type Inductance=Real(unit=\"H\");\n  parameter Voltage Vb=24 \"Battery voltage\";\n  parameter Inductance L = 1;\n  parameter Resistance R = 100;\n  parameter Capacitance C = 1e-3;\n  Voltage V;\n  Current i_L;\n  Current i_R;\n  Current i_C;\nequation\n  der(V) = i_C/C;\n  der(i_L) = (Vb-V)/L;\n  i_R = i_L-i_C;\n  V = i_R*R;\nend RLC2;\n```\nModel description:\nA resistor-inductor-capacitor circuit model.\n\nPrompt:\nTest this model, where the inductance L = 2, the resistance R = 150 and the capacitance C = 1.2e-3.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_RLC2\n  ModelicaByExample.BasicEquations.RLC.RLC2 rlc2(L=2, R=150, C=1.2e-3);\nend Test_RLC2;\n",
            "feature": ""
        },
        {
            "id": 89,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.LotkaVolterra;\nmodel ClassicModel \"This is the typical equation-oriented model\"\n  parameter Real alpha=0.1 \"Reproduction rate of prey\";\n  parameter Real beta=0.02 \"Mortality rate of predator per prey\";\n  parameter Real gamma=0.4 \"Mortality rate of predator\";\n  parameter Real delta=0.02 \"Reproduction rate of predator per prey\";\n  parameter Real x0=10 \"Start value of prey population\";\n  parameter Real y0=10 \"Start value of predator population\";\n  Real x(start=x0) \"Prey population\";\n  Real y(start=y0) \"Predator population\";\nequation\n  der(x) = x*(alpha-beta*y);\n  der(y) = y*(delta*x-gamma);\nend ClassicModel;\n```\nModel description:\n\nPrompt:\nTest this model, where the input parameter alpha=0.2, beta=0.04, gamma=0.5, delta=0.03, x0=20, y0=20.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ClassicModel\n  ModelicaByExample.BasicEquations.LotkaVolterra.ClassicModel classicModel(\n    alpha=0.2,\n    beta=0.04,\n    gamma=0.5,\n    delta=0.03,\n    x0=20,\n    y0=20);\n  Real x,y;\nequation\n  x = classicModel.x;\n  y = classicModel.y;\nend Test_ClassicModel;\n",
            "feature": ""
        },
        {
            "id": 90,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.LotkaVolterra;\nmodel QuiescentModel \"Find steady state solutions to LotkaVolterra equations\"\n  parameter Real alpha=0.1 \"Reproduction rate of prey\";\n  parameter Real beta=0.02 \"Mortality rate of predator per prey\";\n  parameter Real gamma=0.4 \"Mortality rate of predator\";\n  parameter Real delta=0.02 \"Reproduction rate of predator per prey\";\n  Real x \"Prey population\";\n  Real y \"Predator population\";\ninitial equation\n  der(x) = 0;\n  der(y) = 0;\nequation\n  der(x) = x*(alpha-beta*y);\n  der(y) = y*(delta*x-gamma);\nend QuiescentModel;\n```\nModel description:\nFind steady state solutions to LotkaVolterra equations.\n\nPrompt:\nTest this model, where the input parameter alpha=0.2, beta=0.04, gamma=0.5, delta=0.03.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_QuiescentModel\n  ModelicaByExample.BasicEquations.LotkaVolterra.QuiescentModel QuiescentModel(\n    alpha=0.2, \n    beta=0.04, \n    gamma=0.5, \n    delta=0.03);\nend Test_QuiescentModel;\n",
            "feature": ""
        },
        {
            "id": 91,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.BasicEquations.RotationalSMD;\nmodel SecondOrderSystem \"A second order rotational system\"\n  type Angle=Real(unit=\"rad\");\n  type AngularVelocity=Real(unit=\"rad/s\");\n  type Inertia=Real(unit=\"kg.m2\");\n  type Stiffness=Real(unit=\"N.m/rad\");\n  type Damping=Real(unit=\"N.m.s/rad\");\n  parameter Inertia J1=0.4 \"Moment of inertia for inertia 1\";\n  parameter Inertia J2=1.0 \"Moment of inertia for inertia 2\";\n  parameter Stiffness c1=11 \"Spring constant for spring 1\";\n  parameter Stiffness c2=5 \"Spring constant for spring 2\";\n  parameter Damping d1=0.2 \"Damping for damper 1\";\n  parameter Damping d2=1.0 \"Damping for damper 2\";\n  Angle phi1 \"Angle for inertia 1\";\n  Angle phi2 \"Angle for inertia 2\";\n  AngularVelocity omega1 \"Velocity of inertia 1\";\n  AngularVelocity omega2 \"Velocity of inertia 2\";\ninitial equation\n  phi1 = 0;\n  phi2 = 1;\n  omega1 = 0;\n  omega2 = 0;\nequation\n  // Equations for inertia 1\n  omega1 = der(phi1);\n  J1*der(omega1) = c1*(phi2-phi1)+d1*der(phi2-phi1);\n  // Equations for inertia 2\n  omega2 = der(phi2);\n  J2*der(omega2) = c1*(phi1-phi2)+d1*der(phi1-phi2)-c2*phi2-d2*der(phi2);\nend SecondOrderSystem;\n```\nModel description:\nA second order rotational system.\n\nPrompt:\nTest this model, where the moment of inertia for inertia 1 J1=0.6, the moment of inertia for inertia 2 J2=1.2,  the spring constant for spring 1 c1=13, and the spring constant for spring 2 c2=7.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SecondOrderSystem\n  ModelicaByExample.BasicEquations.RotationalSMD.SecondOrderSystem secondOrderSystem(\n    J1=0.6,\n    J2=1.2,\n    c1=13,\n    c2=7);\nend Test_SecondOrderSystem;\n",
            "feature": ""
        },
        {
            "id": 92,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.CoolingRevisited;\nmodel NewtonCoolingDynamic\n  \"Cooling example with fluctuating ambient conditions\"\n  // Types\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  // Parameters\n  parameter Temperature T0=363.15 \"Initial temperature\";\n  parameter ConvectionCoefficient h=0.7 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=0.1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=1.2 \"Specific heat\";\n\n  // Variables\n  Temperature T_inf \"Ambient temperature\";\n  Temperature T \"Temperature\";\ninitial equation\n  T = T0 \"Specify initial value for T\";\nequation\n  if time<=0.5 then\n    T_inf = 298.15 \"Constant temperature when time<=0.5\";\n  else\n    T_inf = 298.15-20*(time-0.5) \"Otherwise, decreasing\";\n  end if;\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingDynamic;\n```\nModel description:\nCooling example with fluctuating ambient conditions.\n\nPrompt:\nTest this model, where the initial temperature T0=400, the convective cooling coefficient h=0.7, the surface area A=1.2, the mass of thermal capacitance m=0.2 and the specific heat c_p=1.4.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NewtonCoolingDynamic\n  ModelicaByExample.DiscreteBehavior.CoolingRevisited.NewtonCoolingDynamic nc(\n    T0=400, \n    h=0.7,\n    A=1.2,\n    m=0.2,\n    c_p=1.4);\nend Test_NewtonCoolingDynamic;\n",
            "feature": ""
        },
        {
            "id": 93,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.CoolingRevisited;\nmodel NewtonCoolingSteadyThenDynamic\n  \"Dynamic cooling example with steady state conditions\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  parameter ConvectionCoefficient h=0.7 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=0.1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=1.2 \"Specific heat\";\n\n  Temperature T_inf \"Ambient temperature\";\n  Temperature T \"Temperature\";\ninitial equation\n  der(T) = 0 \"Steady state initial conditions\";\nequation\n  if time<=0.5 then\n    T_inf = 298.15 \"Constant temperature when time<=0.5\";\n  else\n    T_inf = 298.15-20*(time-0.5) \"Otherwise, decreasing\";\n  end if;\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingSteadyThenDynamic;\n```\nModel description:\nDynamic cooling example with steady state conditions.\n\nPrompt:\nTest this model, where the convective cooling coefficient h=0.7, the surface area A=1.2, the mass of thermal capacitance m=0.2 and the specific heat c_p=1.4.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NewtonCoolingSteadyThenDynamic\n  ModelicaByExample.DiscreteBehavior.CoolingRevisited.NewtonCoolingSteadyThenDynamic newtonCoolingSteadyThenDynamic(\n  h=0.7,\n  A=1.2,\n  m=0.2,\n  c_p=1.4);\nend Test_NewtonCoolingSteadyThenDynamic;\n",
            "feature": ""
        },
        {
            "id": 94,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.CoolingRevisited;\nmodel NewtonCoolingIfExpression \"Cooling example with if expression\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  parameter ConvectionCoefficient h=0.7 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=0.1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=1.2 \"Specific heat\";\n\n  Temperature T_inf \"Ambient temperature\";\n  Temperature T \"Temperature\";\ninitial equation\n  der(T) = 0 \"Steady state initial conditions\";\nequation\n  T_inf = 298.15 - (if time<0.5 then 0 else 20*(time-0.5));\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingIfExpression;\n```\nModel description:\nCooling example with if expression.\n\nPrompt:\nTest this model, where the convective cooling coefficient h=0.7, the surface area A=1.2, the mass of thermal capacitance m=0.2 and the specific heat c_p=1.4.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NewtonCoolingIfExpression\n  ModelicaByExample.DiscreteBehavior.CoolingRevisited.NewtonCoolingIfExpression newtonCoolingIfExpression(\n    h=0.7,\n    A=1.2,\n    m=0.2,\n    c_p=1.4);\nend Test_NewtonCoolingIfExpression;\n",
            "feature": ""
        },
        {
            "id": 95,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.CoolingRevisited;\nmodel NewtonCoolingMaxFunction \"Cooling example with max function\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/(m2.K)\", min=0);\n  type Area=Real(unit=\"m2\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n\n  parameter ConvectionCoefficient h=0.7 \"Convective cooling coefficient\";\n  parameter Area A=1.0 \"Surface area\";\n  parameter Mass m=0.1 \"Mass of thermal capacitance\";\n  parameter SpecificHeat c_p=1.2 \"Specific heat\";\n\n  Temperature T_inf \"Ambient temperature\";\n  Temperature T \"Temperature\";\ninitial equation\n  der(T) = 0 \"Steady state initial condition\";\nequation\n  T_inf = 298.15 - max(0, 20*(time-0.5));\n  m*c_p*der(T) = h*A*(T_inf-T) \"Newton's law of cooling\";\nend NewtonCoolingMaxFunction;\n```\nModel description:\nCooling example with max function.\n\nPrompt:\nTest this model, where the convective cooling coefficient h=0.7, the surface area A=1.2, the mass of thermal capacitance m=0.2 and the specific heat c_p=1.4.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_NewtonCoolingMaxFunction\n  ModelicaByExample.DiscreteBehavior.CoolingRevisited.NewtonCoolingMaxFunction newtonCoolingMaxFunction(\n    h=0.7,\n    A=1.2,\n    m=0.2,\n    c_p=1.4);\nend Test_NewtonCoolingMaxFunction;\n",
            "feature": ""
        },
        {
            "id": 96,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.BouncingBall;\nmodel BouncingBall \"The 'classic' bouncing ball model\"\n  type Height=Real(unit=\"m\");\n  type Velocity=Real(unit=\"m/s\");\n  parameter Real e=0.8 \"Coefficient of restitution\";\n  parameter Height h0=1.0 \"Initial height\";\n  Height h \"Height\";\n  Velocity v(start=0.0, fixed=true) \"Velocity\";\ninitial equation\n  h = h0;\nequation\n  v = der(h);\n  der(v) = -9.81;\n  when h<0 then\n    reinit(v, -e*pre(v));\n  end when;\nend BouncingBall;\n```\nModel description:\nThe 'classic' bouncing ball model.\n\nPrompt:\nTest this model, where the coefficient of restitution e=0.9, the initial height h=2.0.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_BouncingBall\n  ModelicaByExample.DiscreteBehavior.BouncingBall.BouncingBall bouncingball(e=0.9, h0=2.0);\nend Test_BouncingBall;\n",
            "feature": ""
        },
        {
            "id": 97,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.BouncingBall;\nmodel StableBouncingBall\n  \"The 'classic' bouncing ball model with numerical tolerances\"\n  type Height=Real(unit=\"m\");\n  type Velocity=Real(unit=\"m/s\");\n  parameter Real e=0.8 \"Coefficient of restitution\";\n  parameter Height h0=1.0 \"Initial height\";\n  constant Height eps=1e-3 \"Small height\";\n  Boolean done \"Flag when to turn off gravity\";\n  Height h \"Height\";\n  Velocity v(start=0.0, fixed=true) \"Velocity\";\ninitial equation\n  h = h0;\n  done = false;\nequation\n  v = der(h);\n  der(v) = if done then 0 else -9.81;\n  when {h<0,h<-eps} then\n    done = h<-eps;\n    reinit(v, -e*(if h<-eps then 0 else pre(v)));\n  end when;\nend StableBouncingBall\n```\nModel description:\nThe 'classic' bouncing ball model with numerical tolerances.\n\nPrompt:\nTest this model, where the coefficient of restitution e=0.9, the initial height h=2.0.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_StableBouncingBall\n  ModelicaByExample.DiscreteBehavior.BouncingBall.StableBouncingBall ball(h0=2.0, e=0.9);\n  Real height;\nequation\n  height=ball.h;\nend Test_StableBouncingBall;\n",
            "feature": ""
        },
        {
            "id": 98,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Accuracy;\nmodel WithEvents \"Integrate with events\"\n  parameter Real freq = 1.0;\n  Real x(start=0);\n  Real y = time;\nequation\n  der(x) = if sin(2*Modelica.Constants.pi*freq*time)>0 then 2.0 else 0.0;\nend WithEvents;\n```\nModel description:\nIntegrate with events.\n\nPrompt:\nTest this model, where the freq = 1.5, the initial value of x is 0.1.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_WithEvents\n  ModelicaByExample.DiscreteBehavior.Accuracy.WithEvents w(freq=1.5,x(start=0.1));\nend Test_WithEvents;\n",
            "feature": ""
        },
        {
            "id": 99,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Accuracy;\nmodel WithNoEvents \"Integrate without events\"\n  parameter Real freq = 1.0;\n  Real x(start=0);\n  Real y = time;\nequation\n  der(x) = noEvent(if sin(2*Modelica.Constants.pi*freq*time)>0 then 2.0 else 0.0);\nend WithNoEvents;\n```\nModel description:\nIntegrate without events.\n\nPrompt:\nTest this model, where the freq = 1.5, the initial value of x is 0.1.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_WithNoEvents\n  ModelicaByExample.DiscreteBehavior.Accuracy.WithNoEvents withNoEvents(freq=1.5, x(start=0.1));\n  Real y;\nequation\n  y=withNoEvents.y;\nend Test_WithNoEvents;\n",
            "feature": ""
        },
        {
            "id": 100,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.SwitchedRLC;\nmodel SwitchedRLC \"An RLC circuit with a switch\"\n  type Voltage=Real(unit=\"V\");\n  type Current=Real(unit=\"A\");\n  type Resistance=Real(unit=\"Ohm\");\n  type Capacitance=Real(unit=\"F\");\n  type Inductance=Real(unit=\"H\");\n  parameter Voltage Vb=24 \"Battery voltage\";\n  parameter Inductance L = 1;\n  parameter Resistance R = 100;\n  parameter Capacitance C = 1e-3;\n  Voltage Vs;\n  Voltage V;\n  Current i_L;\n  Current i_R;\n  Current i_C;\nequation\n  Vs = if time>0.5 then Vb else 0;\n  i_R = V/R;\n  i_C = C*der(V);\n  i_L=i_R+i_C;\n  L*der(i_L) = (Vs-V);\nend SwitchedRLC;\n```\nModel description:\nAn RLC circuit with a switch.\n\nPrompt:\nTest this model, where the inductance L = 2, the resistance R = 150 and the capacitance C = 1.2e-3.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SwitchedRLC\n  ModelicaByExample.DiscreteBehavior.SwitchedRLC.SwitchedRLC switch(L=2, R=150, C=1.2e-3);\nend Test_SwitchedRLC;\n",
            "feature": ""
        },
        {
            "id": 101,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Backlash;\nmodel Backlash \"Implementing the behavior of a backlash using a 'stiff spring'\"\n  type Angle=Real(unit=\"rad\");\n  type AngularVelocity=Real(unit=\"rad/s\");\n  type Inertia=Real(unit=\"kg.m2\");\n  type Stiffness=Real(unit=\"N.m/rad\");\n  type Damping=Real(unit=\"N.m.s/rad\");\n  parameter Angle phi1_init = 0;\n  parameter Angle phi2_init = 0;\n  parameter AngularVelocity omega1_init = 5;\n  parameter AngularVelocity omega2_init = 0;\n  parameter Angle b=0.5 \"Total backlash angle\";\n  parameter Inertia J1=0.4;\n  parameter Inertia J2=1.0;\n  parameter Stiffness c1=11;\n  parameter Stiffness c2=5;\n  parameter Stiffness kb=1000;\n  parameter Damping d1=0.2;\n  parameter Damping d2=1.0;\n  Angle phi1;\n  Angle phi2;\n  Angle dphi = phi2-phi1;\n  AngularVelocity omega1;\n  AngularVelocity omega2;\ninitial equation\n  phi1 = phi1_init;\n  phi2 = phi2_init;\n  omega1 = omega1_init;\n  omega2 = omega2_init;\nequation\n  omega1 = der(phi1);\n  omega2 = der(phi2);\n  J1*der(omega1) = kb*sign(dphi)*max(abs(dphi)-b/2,0)+c1*(dphi)+d1*der(dphi);\n  J2*der(omega2) = kb*sign(-dphi)*max(abs(dphi)-b/2,0)-c1*dphi-d1*der(dphi)-c2*phi2-d2*der(phi2);\nend Backlash;\n```\nModel description:\nImplementing the behavior of a backlash using a 'stiff spring'.\n\nPrompt:\nTest this model, where the moment of inertia for inertia 1 J1=0.6, the moment of inertia for inertia 2 J2=1.2,  the spring constant for spring 1 c1=13, and the spring constant for spring 2 c2=7.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Backlash\n  ModelicaByExample.DiscreteBehavior.Backlash.Backlash backlash(J1=0.6,J2=1.2,c1=13,c2=7);\nend Test_Backlash;\n",
            "feature": ""
        },
        {
            "id": 102,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.PulseGenerator;\nmodel PulseGenerator \"A model that produces pulses at a fixed interval\"\n  type Time=Real(unit=\"s\");\n  parameter Time width=100e-3;\n  Boolean pulse;\ninitial equation\n  pulse = false;\nequation\n  when sample(width,width) then\n    pulse = not pre(pulse);\n  end when;\nend PulseGenerator;\n```\nModel description:\nA model that produces pulses at a fixed interval.\n\nPrompt:\nTest this model, where the width=10e-3.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_PulseGenerator\n  ModelicaByExample.DiscreteBehavior.PulseGenerator.PulseGenerator pulseGenerator(width=10e-3);\n  Boolean pulse;\nequation\n  pulse = pulseGenerator.pulse;\nend Test_PulseGenerator;\n",
            "feature": ""
        },
        {
            "id": 103,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Counter;\nmodel Counter \"Counting samples\"\n  type Time = Real(unit=\"s\");\n  parameter Time interval=100e-3;\n  Integer count;\ninitial equation\n  count = 0;\nequation\n  when sample(interval, interval) then\n    count = pre(count)+1;\n  end when;\nend Counter;\n```\nModel description:\nCounting samples.\n\nPrompt:\nTest this model, where the interval=10e-3.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Counter\n  ModelicaByExample.DiscreteBehavior.Counter.Counter counter(interval=10e-3);\n  Integer count;\nequation\n  count=counter.count;\nend Test_Counter;\n",
            "feature": ""
        },
        {
            "id": 104,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.SpeedMeasurement;\nmodel SampleAndHold \"Measure speed and hold\"\n  extends BasicEquations.RotationalSMD.SecondOrderSystem;\n  parameter Real sample_time(unit=\"s\")=0.125;\n  discrete Real omega1_measured;\nequation\n  when sample(0,sample_time) then\n    omega1_measured = omega1;\n  end when;\nend SampleAndHold;\n```\nModel description:\nMeasure speed and hold.\n\nPrompt:\nTest this model, where the sample_time=0.25.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_SampleAndHold\n  parameter Real sample_time=0.25;\n  ModelicaByExample.DiscreteBehavior.SpeedMeasurement.SampleAndHold sampleAndHold(\n    sample_time = sample_time);\nend Test_SampleAndHold;\n",
            "feature": ""
        },
        {
            "id": 105,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.SpeedMeasurement;\nmodel IntervalMeasure \"Measure interval between teeth\"\n  extends BasicEquations.RotationalSMD.SecondOrderSystem;\n  parameter Integer teeth=200;\n  parameter Real tooth_angle(unit=\"rad\")=2*3.14159/teeth;\n  Real next_phi, prev_phi;\n  Real last_time;\n  Real omega1_measured;\ninitial equation\n  next_phi = phi1+tooth_angle;\n  prev_phi = phi1-tooth_angle;\n  last_time = time;\nequation\n  when {phi1>=pre(next_phi),phi1<=pre(prev_phi)} then\n    omega1_measured = tooth_angle/(time-pre(last_time));\n    next_phi = phi1+tooth_angle;\n    prev_phi = phi1-tooth_angle;\n    last_time = time;\n  end when;\nend IntervalMeasure;\n```\nModel description:\nMeasure interval between teeth.\n\nPrompt:\nTest this model, where the teeth=250.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_IntervalMeasure\n  ModelicaByExample.DiscreteBehavior.SpeedMeasurement.IntervalMeasure intervalMeasure(teeth=250);\nend Test_IntervalMeasure;\n",
            "feature": ""
        },
        {
            "id": 106,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.SpeedMeasurement;\nmodel CounterWithAlgorithm \"Count teeth in a given interval using an algorithm\"\n  extends BasicEquations.RotationalSMD.SecondOrderSystem;\n  parameter Real sample_time(unit=\"s\")=0.125;\n  parameter Integer teeth=200;\n  parameter Real tooth_angle(unit=\"rad\")=2*3.14159/teeth;\n  Real next_phi, prev_phi;\n  Integer count;\n  Real omega1_measured;\ninitial equation\n  next_phi = phi1+tooth_angle;\n  prev_phi = phi1-tooth_angle;\n  count = 0;\nalgorithm\n  when {phi1>=pre(next_phi),phi1<=pre(prev_phi)} then\n    next_phi := phi1 + tooth_angle;\n    prev_phi := phi1 - tooth_angle;\n    count := pre(count) + 1;\n  end when;\n  when sample(0,sample_time) then\n    omega1_measured := pre(count)*tooth_angle/sample_time;\n    count :=0;\n  end when;\nend CounterWithAlgorithm;\n```\nModel description:\nCount teeth in a given interval using an algorithm.\n\nPrompt:\nTest this model, where the sample_time=0.25 and the teeth=250.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_CounterWithAlgorithm\n  ModelicaByExample.DiscreteBehavior.SpeedMeasurement.CounterWithAlgorithm counter(\n    sample_time=0.25, teeth=250);\nend Test_CounterWithAlgorithm;\n",
            "feature": ""
        },
        {
            "id": 107,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Hysteresis;\nmodel ChatteringControl \"A control strategy that will 'chatter'\"\n  type HeatCapacitance=Real(unit=\"J/K\");\n  type Temperature=Real(unit=\"K\");\n  type Heat=Real(unit=\"W\");\n  type Mass=Real(unit=\"kg\");\n  type HeatTransferCoefficient=Real(unit=\"W/K\");\n  Boolean heat \"Indicates whether heater is on\";\n  parameter HeatCapacitance C=1.0;\n  parameter HeatTransferCoefficient h=2.0;\n  parameter Heat Qcapacity=25.0;\n  parameter Temperature Tamb=285;\n  parameter Temperature Tbar=295;\n  Temperature T;\n  Heat Q;\ninitial equation\n  T = Tbar+5;\nequation\n  heat = T<Tbar;\n  Q = if heat then Qcapacity else 0;\n  C*der(T) = Q-h*(T-Tamb);\nend ChatteringControl;\n```\nModel description:\nA control strategy that will 'chatter'.\n\nPrompt:\nTest this model, where the C=1.1, h=2.1, Qcapacity=25.1, Tamb=295 and Tbar=315.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ChatteringControl\n  ModelicaByExample.DiscreteBehavior.Hysteresis.ChatteringControl chatter(\n    C=1.1, \n    h=2.1, \n    Tamb=295, \n    Tbar=315, \n    Qcapacity=25.1);\nend Test_ChatteringControl;\n",
            "feature": ""
        },
        {
            "id": 108,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Hysteresis;\nmodel HysteresisControl \"A control strategy that doesn't chatter\"\n  type HeatCapacitance=Real(unit=\"J/K\");\n  type Temperature=Real(unit=\"K\");\n  type Heat=Real(unit=\"W\");\n  type Mass=Real(unit=\"kg\");\n  type HeatTransferCoefficient=Real(unit=\"W/K\");\n  Boolean heat(start=false) \"Indicates whether heater is on\";\n  parameter HeatCapacitance C=1.0;\n  parameter HeatTransferCoefficient h=2.0;\n  parameter Heat Qcapacity=25.0;\n  parameter Temperature Tamb=285;\n  parameter Temperature Tbar=295;\n  Temperature T;\n  Heat Q;\ninitial equation\n  T = Tbar+5;\n  heat = false;\nequation\n  Q = if heat then Qcapacity else 0;\n  C*der(T) = Q-h*(T-Tamb);\n  when {T>Tbar+1,T<Tbar-1} then\n    heat = T<Tbar;\n  end when;\nend HysteresisControl;\n```\nModel description:\nA control strategy that doesn't chatter.\n\nPrompt:\nTest this model, where the C=1.1, h=2.1, Qcapacity=25.1, Tamb=295 and Tbar=315.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_HysteresisControl\n  ModelicaByExample.DiscreteBehavior.Hysteresis.HysteresisControl hysteresisControl(\n    C=1.1, \n    h=2.1, \n    Tamb=295,\n    Qcapacity=25.1, \n    Tbar=315);\nend Test_HysteresisControl;\n",
            "feature": ""
        },
        {
            "id": 109,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.DiscreteBehavior.Hysteresis;\nmodel HysteresisControlWithAlgorithms \"Control using algorithms\"\n  type HeatCapacitance=Real(unit=\"J/K\");\n  type Temperature=Real(unit=\"K\");\n  type Heat=Real(unit=\"W\");\n  type Mass=Real(unit=\"kg\");\n  type HeatTransferCoefficient=Real(unit=\"W/K\");\n  Boolean heat \"Indicates whether heater is on\";\n  parameter HeatCapacitance C=1.0;\n  parameter HeatTransferCoefficient h=2.0;\n  parameter Heat Qcapacity=25.0;\n  parameter Temperature Tamb=285;\n  parameter Temperature Tbar=295;\n  Temperature T;\n  Heat Q;\ninitial equation\n  T = Tbar+5;\n  heat = false;\nequation\n  Q = if heat then Qcapacity else 0;\n  C*der(T) = Q-h*(T-Tamb);\nalgorithm\n  when T<Tbar-1 then\n    heat :=true;\n  end when;\n  when T>Tbar+1 then\n    heat :=false;\n  end when;\nend HysteresisControlWithAlgorithms;\n```\nModel description:\nControl using algorithms.\n\nPrompt:\nTest this model, where the C=1.1, h=2.1, Qcapacity=25.1, Tamb=295 and Tbar=315.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_HysteresisControlWithAlgorithms \n  ModelicaByExample.DiscreteBehavior.Hysteresis.HysteresisControlWithAlgorithms HysteresisControlWithAlgorithms(\n    C=1.1, \n    h=2.1, \n    Qcapacity=25.1, \n    Tamb=295, \n    Tbar=315) ;\nend Test_HysteresisControlWithAlgorithms ;\n",
            "feature": ""
        },
        {
            "id": 110,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.StateSpace;\nmodel LTI\n  \"Equations written in ABCD form where matrices are also time-invariant\"\n  parameter Integer nx=0 \"Number of states\";\n  parameter Integer nu=0 \"Number of inputs\";\n  parameter Integer ny=0 \"Number of outputs\";\n  parameter Real A[nx,nx]=fill(0,nx,nx);\n  parameter Real B[nx,nu]=fill(0,nx,nu);\n  parameter Real C[ny,nx]=fill(0,ny,nx);\n  parameter Real D[ny,nu]=fill(0,ny,nu);\n  parameter Real x0[nx]=fill(0,nx) \"Initial conditions\";\n  Real x[nx] \"State vector\";\n  Real u[nu] \"Input vector\";\n  Real y[ny] \"Output vector\";\ninitial equation\n  x = x0 \"Specify initial conditions\";\nequation\n  der(x) = A*x+B*u;\n  y = C*x+D*u;\nend LTI;\n```\n\nModel description:\nEquations written in ABCD form where matrices are also time-invariant.\n\nPrompt:\nExtends this model, where nx=1,nu=1,A=[-1], B=[1] and u = {1}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_LTI\n  extends ModelicaByExample.ArrayEquations.StateSpace.LTI(\n    nx = 1, \n    nu = 1, \n    A = [-1], \n    B = [1], \n    u = {1});\nend Test_LTI;\n",
            "feature": ""
        },
        {
            "id": 111,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.StateSpace;\npartial model ABCD \"Equations written in (potentially non-linear) ABCD form\"\n  parameter Integer nx;\n  parameter Integer ny;\n  parameter Integer nu;\n  parameter Real x0[nx]=fill(0,nx);\n  Real A[nx,nx];\n  Real B[nx,nu];\n  Real C[ny,nx];\n  Real D[ny,nu];\n  Real u[nu];\n  Real x[nx];\n  Real y[ny];\ninitial equation\n  x = x0;\nequation\n  der(x) = A*x+B*u;\n  y = C*x+D*u;\nend ABCD;\n```\n\nModel description:\nEquations written in (potentially non-linear) ABCD form.\n\nPrompt:\nExtends this model, where nx=2, nu=0, ny=0, x0={10, 10}.\nA = [alpha-beta*x[2], 0; 0, -gamma+delta*x[1]]; B = fill(0,2,0); C = fill(0,0,2); D = fill(0,0,0); u = fill(0,0), where alpha=0.1, beta=0.02, gamma=0.4, and delta=0.02. \nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ABCD\n  extends ModelicaByExample.ArrayEquations.StateSpace.ABCD(nx=2, nu=0, ny=0, x0={10, 10});\n  Real alpha=0.1;\n  Real beta=0.02;\n  Real gamma=0.4;\n  Real delta=0.02;\nequation\n  A=[alpha-beta*x[2], 0; 0, -gamma+delta*x[1]];\n  B = fill(0,2,0);\n  C = fill(0,0,2);\n  D = fill(0,0,0);\n  u = fill(0,0);\nend Test_ABCD;\n",
            "feature": ""
        },
        {
            "id": 112,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.HeatTransfer;\nmodel Rod_ForLoop \"Modeling heat conduction in a rod using a for loop\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/K\", min=0);\n  type ConductionCoefficient=Real(unit=\"W.m-1.K-1\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n  type Density=Real(unit=\"kg/m3\", min=0);\n  type Area=Real(unit=\"m2\");\n  type Volume=Real(unit=\"m3\");\n  type Length=Real(unit=\"m\", min=0);\n  type Radius=Real(unit=\"m\", min=0);\n\n  constant Real pi = 3.14159;\n\n  parameter Integer n=10;\n  parameter Length L=1.0;\n  parameter Radius R=0.1;\n  parameter Density rho=2.0;\n  parameter ConvectionCoefficient h=2.0;\n  parameter ConductionCoefficient k=10;\n  parameter SpecificHeat C=10.0;\n  parameter Temperature Tamb=300 \"Ambient temperature\";\n\n  parameter Area A_c = pi*R^2, A_s = 2*pi*R*L;\n  parameter Volume V = A_c*L/n;\n\n  Temperature T[n];\ninitial equation\n  T = linspace(200,300,n);\nequation\n  rho*V*C*der(T[1]) = -h*A_s*(T[1]-Tamb)-k*A_c*(T[1]-T[2])/(L/n);\n  for i in 2:(n-1) loop\n    rho*V*C*der(T[i]) = -h*A_s*(T[i]-Tamb)-k*A_c*(T[i]-T[i-1])/(L/n)-k*A_c*(T[i]-T[i+1])/(L/n);\n  end for;\n  rho*V*C*der(T[end]) = -h*A_s*(T[end]-Tamb)-k*A_c*(T[end]-T[end-1])/(L/n);\nend Rod_ForLoop;\n```\n\nModel description:\nModeling heat conduction in a rod using a for loop.\n\nPrompt:\nTest this model, where n=10, the length L=5.0, the radius R=0.1, the density rho=2.0, the convective cooling coefficient h=7, the conduction coefficient k=10,the specific heat C=15.0 and the ambient temperature Tamb=325.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Rod_ForLoop\n  ModelicaByExample.ArrayEquations.HeatTransfer.Rod_ForLoop rod(\n    n=10, L=5.0, R=0.1, rho=2.0, h=70, k=10, C=150, Tamb=325);\nend Test_Rod_ForLoop;\n",
            "feature": ""
        },
        {
            "id": 113,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.HeatTransfer;\nmodel Rod_ArrayComprehensions\n  \"Modeling heat conduction in a rod using array comprehensions\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/K\", min=0);\n  type ConductionCoefficient=Real(unit=\"W.m-1.K-1\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n  type Density=Real(unit=\"kg/m3\", min=0);\n  type Area=Real(unit=\"m2\");\n  type Volume=Real(unit=\"m3\");\n  type Length=Real(unit=\"m\", min=0);\n  type Radius=Real(unit=\"m\", min=0);\n\n  constant Real pi = 3.14159;\n\n  parameter Integer n=10;\n  parameter Length L=1.0;\n  parameter Radius R=0.1;\n  parameter Density rho=2.0;\n  parameter ConvectionCoefficient h=2.0;\n  parameter ConductionCoefficient k=10;\n  parameter SpecificHeat C=10.0;\n  parameter Temperature Tamb=300 \"Ambient temperature\";\n\n  parameter Area A_c = pi*R^2, A_s = 2*pi*R*L;\n  parameter Volume V = A_c*L/n;\n\n  Temperature T[n];\ninitial equation\n  T = linspace(200,300,n);\nequation\n  rho*V*C*der(T[1]) = -h*A_s*(T[1]-Tamb)-k*A_c*(T[1]-T[2])/(L/n);\n  rho*V*C*der(T[2:n-1]) = {-h*A_s*(T[i]-Tamb)-k*A_c*(T[i]-T[i-1])/(L/n)-k*A_c*(T[i]-T[i+1])/(L/n) for i in 2:(n-1)};\n  rho*V*C*der(T[end]) = -h*A_s*(T[end]-Tamb)-k*A_c*(T[end]-T[end-1])/(L/n);\nend Rod_ArrayComprehensions;\n```\n\nModel description:\nModeling heat conduction in a rod using array comprehensions.\n\nPrompt:\nTest this model, where n=10, the length L=5.0, the radius R=0.1, the density rho=2.0, the convective cooling coefficient h=7, the conduction coefficient k=10,the specific heat C=15.0 and the ambient temperature Tamb=325.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Rod_ArrayComprehensions\n  ModelicaByExample.ArrayEquations.HeatTransfer.Rod_ArrayComprehensions rod_ArrayComprehensions(\n    n=10, L=5.0, R=0.1, rho=2.0, h=7, k=10, C=15.0, Tamb=325);\n  Real temperature;\nequation\n  temperature=rod_ArrayComprehensions.T[end];\nend Test_Rod_ArrayComprehensions;\n",
            "feature": ""
        },
        {
            "id": 114,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.HeatTransfer;\nmodel Rod_ArrayComprehensionsOneEquation\n  \"Modeling heat conduction in a rod using single equation with array comprehensions\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/K\", min=0);\n  type ConductionCoefficient=Real(unit=\"W.m-1.K-1\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n  type Density=Real(unit=\"kg/m3\", min=0);\n  type Area=Real(unit=\"m2\");\n  type Volume=Real(unit=\"m3\");\n  type Length=Real(unit=\"m\", min=0);\n  type Radius=Real(unit=\"m\", min=0);\n\n  constant Real pi = 3.14159;\n\n  parameter Integer n=10;\n  parameter Length L=1.0;\n  parameter Radius R=0.1;\n  parameter Density rho=2.0;\n  parameter ConvectionCoefficient h=2.0;\n  parameter ConductionCoefficient k=10;\n  parameter SpecificHeat C=10.0;\n  parameter Temperature Tamb=300 \"Ambient temperature\";\n\n  parameter Area A_c = pi*R^2, A_s = 2*pi*R*L;\n  parameter Volume V = A_c*L/n;\n\n  Temperature T[n];\ninitial equation\n  T = linspace(200,300,n);\nequation\n  rho*V*C*der(T) = {-h*A_s*(T[i]-Tamb)\n                    -(if i==1 then 0 else k*A_c/(L/n)*(T[i]-T[i-1]))\n                    -(if i==n then 0 else k*A_c/(L/n)*(T[i]-T[i+1])) for i in 1:n};\nend Rod_ArrayComprehensionsOneEquation;\n```\n\nModel description:\nModeling heat conduction in a rod using single equation with array comprehensions.\n\nPrompt:\nTest this model, where n=10, the length L=5.0, the radius R=0.1, the density rho=2.0, the convective cooling coefficient h=7, the conduction coefficient k=10,the specific heat C=15.0 and the ambient temperature Tamb=325.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Rod_ArrayComprehensionsOneEquation\n  ModelicaByExample.ArrayEquations.HeatTransfer.Rod_ArrayComprehensionsOneEquation rodArray(\n    n=10, L=5.0, R=0.1, rho=2.0, h=7.0, k=10.0, C=15.0, Tamb=325.0);\nend Test_Rod_ArrayComprehensionsOneEquation;\n",
            "feature": ""
        },
        {
            "id": 115,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.HeatTransfer;\nmodel Rod_VectorNotationNoSubscripts\n  \"Modeling heat conduction in a rod using vector notation\"\n  type Temperature=Real(unit=\"K\", min=0);\n  type ConvectionCoefficient=Real(unit=\"W/K\", min=0);\n  type ConductionCoefficient=Real(unit=\"W.m-1.K-1\", min=0);\n  type Mass=Real(unit=\"kg\", min=0);\n  type SpecificHeat=Real(unit=\"J/(K.kg)\", min=0);\n  type Density=Real(unit=\"kg/m3\", min=0);\n  type Area=Real(unit=\"m2\");\n  type Volume=Real(unit=\"m3\");\n  type Length=Real(unit=\"m\", min=0);\n  type Radius=Real(unit=\"m\", min=0);\n  type Heat=Real(unit=\"W\");\n\n  constant Real pi = 3.14159;\n\n  parameter Integer n=10;\n  parameter Length L=1.0;\n  parameter Radius R=0.1;\n  parameter Density rho=2.0;\n  parameter ConvectionCoefficient h=2.0;\n  parameter ConductionCoefficient k=10;\n  parameter SpecificHeat C=10.0;\n  parameter Temperature Tamb=300 \"Ambient temperature\";\n\n  parameter Area A_c = pi*R^2, A_s = 2*pi*R*L;\n  parameter Volume V = A_c*L/n;\n\n  Temperature T[n];\n  Heat Qconv[n];\n  Heat Qleft[n];\n  Heat Qright[n];\ninitial equation\n  T = linspace(200,300,n);\nequation\n  Qconv = {-h*A_s*(T[i]-Tamb) for i in 1:n};\n  Qleft = {(if i==1 then 0 else -k*A_c*(T[i]-T[i-1])/(L/n)) for i in 1:n};\n  Qright = {(if i==n then 0 else -k*A_c*(T[i]-T[i+1])/(L/n)) for i in 1:n};\n  rho*V*C*der(T) = Qconv+Qleft+Qright;\nend Rod_VectorNotationNoSubscripts;\n```\n\nModel description:\nModeling heat conduction in a rod using vector notation.\n\nPrompt:\nTest this model, where n=10, the length L=5.0, the radius R=0.1, the density rho=2.0, the convective cooling coefficient h=7, the conduction coefficient k=10,the specific heat C=15.0 and the ambient temperature Tamb=325.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Rod_VectorNotationNoSubscripts\n  ModelicaByExample.ArrayEquations.HeatTransfer.Rod_VectorNotationNoSubscripts rod(\n    n=10,L=5.0,R=0.1,rho=2.0,h=7,k=10,C=15,Tamb=325);\nend Test_Rod_VectorNotationNoSubscripts;\n",
            "feature": ""
        },
        {
            "id": 116,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.ChemicalReactions;\nmodel Reactions_NoArrays \"Modeling a chemical reaction without arrays\"\n  Real cA;\n  Real cB;\n  Real cX;\n  parameter Real k1=0.1;\n  parameter Real k2=0.1;\n  parameter Real k3=10;\ninitial equation\n  cA = 1;\n  cB = 1;\n  cX = 0;\nequation\n  der(cA) = -k1*cA*cB + k2*cX;\n  der(cB) = -k1*cA*cB + k2*cX - k3*cB*cX;\n  der(cX) = k1*cA*cB - k2*cX - k3*cB*cX;\nend Reactions_NoArrays;\n```\n\nModel description:\nModeling a chemical reaction without arrays.\n\nPrompt:\nTest this model, where k1=0.1, k2=0.15, k3=15.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Reactions_NoArrays\n  ModelicaByExample.ArrayEquations.ChemicalReactions.Reactions_NoArrays reaction(\n    k1=0.1, k2=0.15, k3=15);\n  Real cA;\n  Real cB;\n  Real cX;\nequation\n  cA = reaction.cA;\n  cB = reaction.cB;\n  cX = reaction.cX;\nend Test_Reactions_NoArrays;\n",
            "feature": ""
        },
        {
            "id": 117,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.ChemicalReactions;\nmodel Reactions_Array \"Modeling a chemical reaction with arrays\"\n  Real C[3];\n  parameter Real k[3] = {0.1, 0.1, 10};\ninitial equation\n  C = {1, 1, 0};\nequation\n  der(C) = {-k[1]*C[1]*C[2] + k[2]*C[3],\n            -k[1]*C[1]*C[2] + k[2]*C[3] - k[3]*C[2]*C[3],\n            k[1]*C[1]*C[2] - k[2]*C[3] - k[3]*C[2]*C[3]};\nend Reactions_Array;\n```\n\nModel description:\nModeling a chemical reaction with arrays.\n\nPrompt:\nTest this model, where k[3] = {0.1, 0.15, 15}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Reactions_Array\n  ModelicaByExample.ArrayEquations.ChemicalReactions.Reactions_Array reactions_array(\n    k={0.1, 0.15, 15});\nend Test_Reactions_Array;\n",
            "feature": ""
        },
        {
            "id": 118,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.ChemicalReactions;\nmodel Reactions_Enum \"Modeling a chemical reaction with enums\"\n  type Species = enumeration(\n      A,\n      B,\n      X);\n  Real C[Species] \"Species concentrations\";\n  parameter Real k[3] = {0.1, 0.1, 10};\n  constant Species A = Species.A;\n  constant Species B = Species.B;\n  constant Species X = Species.X;\ninitial equation\n  C[A] = 1.0;\n  C[B] = 1.0;\n  C[X] = 0.0;\nequation\n  der(C[A]) = -k[1]*C[A]*C[B] + k[2]*C[X];\n  der(C[B]) = -k[1]*C[A]*C[B] + k[2]*C[X] - k[3]*C[B]*C[X];\n  der(C[X]) = k[1]*C[A]*C[B] - k[2]*C[X] - k[3]*C[B]*C[X];\nend Reactions_Enum;\n```\n\nModel description:\nModeling a chemical reaction with enums.\n\nPrompt:\nTest this model, where k[3] = {0.1, 0.15, 15}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Reactions_Enum\n  ModelicaByExample.ArrayEquations.ChemicalReactions.Reactions_Enum react(k = {0.1, 0.15, 15});\nend Test_Reactions_Enum;\n",
            "feature": ""
        },
        {
            "id": 119,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.ArrayEquations.ChemicalReactions;\nmodel Reactions_EnumMatrix \"Modeling a chemical reaction with matrix equations\"\n  type Species = enumeration(\n      A,\n      B,\n      X);\n  Real C[Species] \"Species concentrations\";\n  parameter Real k[3] = {0.1, 0.1, 10};\n  constant Species A = Species.A;\n  constant Species B = Species.B;\n  constant Species X = Species.X;\ninitial equation\n  C[A] = 1.0;\n  C[B] = 1.0;\n  C[X] = 0.0;\nequation\n  der(C) = [-k[1]*C[B], 0,          k[2];\n            -k[1]*C[B], -k[3]*C[X], k[2];\n            k[1]*C[B],  -k[3]*C[X], -k[2]]*C;\nend Reactions_EnumMatrix;\n```\n\nModel description:\nModeling a chemical reaction with matrix equations.\n\nPrompt:\nTest this model, where k[3] = {0.1, 0.15, 15}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Reactions_EnumMatrix\n  ModelicaByExample.ArrayEquations.ChemicalReactions.Reactions_EnumMatrix reactions(\n    k={0.1, 0.15, 15});\nend Test_Reactions_EnumMatrix;\n",
            "feature": ""
        },
        {
            "id": 120,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Functions.Polynomials;\nfunction Polynomial \"Create a generic polynomial from coefficients\"\n  input Real x     \"Independent variable\";\n  input Real c[:]  \"Polynomial coefficients\";\n  output Real y    \"Computed polynomial value\";\nprotected\n  Integer n = size(c,1);\nalgorithm\n  y := c[1];\n  for i in 2:n loop\n    y := y*x + c[i];\n  end for;\nend Polynomial;\n```\n\nModel description:\nCreate a generic polynomial from coefficients.\n\nPrompt:\nTest this model, where the input parameter values are time and {1, -2, 2}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Polynomial\n  Real y;\nequation\n  y = ModelicaByExample.Functions.Polynomials.Polynomial(time, {1, -2, 2});\nend Test_Polynomial;\n",
            "feature": ""
        },
        {
            "id": 121,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Functions.Polynomials;\nfunction PolynomialWithDerivative\n  \"Create a generic polynomial from coefficients (with derivative information)\"\n  input Real x     \"Independent variable\";\n  input Real c[:]  \"Polynomial coefficients\";\n  output Real y    \"Computed polynomial value\";\nprotected\n  Integer n = size(c,1);\nalgorithm\n  y := c[1];\n  for i in 2:n loop\n    y := y*x + c[i];\n  end for;\n  annotation(derivative=PolynomialFirstDerivative);\nend PolynomialWithDerivative;\n```\n\nModel description:\nCreate a generic polynomial from coefficients (with derivative information).\n\nPrompt:\nTest this model, where the input parameter values are time and {1, -2, 2}.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_PolynomialWithDerivative\n  Real result;\nequation\n  result = ModelicaByExample.Functions.Polynomials.PolynomialWithDerivative(time,{1,-2,2});\nend Test_PolynomialWithDerivative;\n",
            "feature": ""
        },
        {
            "id": 122,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Functions.Interpolation;\nfunction InterpolateVector \"Interpolate a function defined by a vector\"\n  input Real x         \"Independent variable\";\n  input Real ybar[:,2] \"Interpolation data\";\n  output Real y        \"Dependent variable\";\nprotected\n  Integer i;\n  Integer n = size(ybar,1) \"Number of interpolation points\";\n  Real p;\nalgorithm\n  assert(x>=ybar[1,1], \"Independent variable must be greater than or equal to \"+String(ybar[1,1]));\n  assert(x<=ybar[n,1], \"Independent variable must be less than or equal to \"+String(ybar[n,1]));\n  i := 1;\n  while x>=ybar[i+1,1] loop\n    i := i + 1;\n  end while;\n  p := (x-ybar[i,1])/(ybar[i+1,1]-ybar[i,1]);\n  y := p*ybar[i+1,2]+(1-p)*ybar[i,2];\nend InterpolateVector;\n```\n\nModel description:\nInterpolate a function defined by a vector.\n\nPrompt:\nTest this model, where the input parameter values are time and [0.0, 0.0; 2.0, 0.0; 4.0, 2.0; 6.0, 0.0; 8.0, 0.0].\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_InterpolateVector\n  parameter Real ybar[5,2]=[0.0, 0.0; 2.0, 0.0; 4.0, 2.0; 6.0, 0.0; 8.0, 0.0];\n  Real y;\nequation\n  y = ModelicaByExample.Functions.Interpolation.InterpolateVector(time, ybar);\nend Test_InterpolateVector;\n",
            "feature": ""
        },
        {
            "id": 123,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Functions.Nonlinearities;\nfunction Quadratic \"A quadratic function\"\n  input Real a \"2nd order coefficient\";\n  input Real b \"1st order coefficient\";\n  input Real c \"constant term\";\n  input Real x \"independent variable\";\n  output Real y \"dependent variable\";\nalgorithm\n  y := a*x*x + b*x + c;\n  annotation(inverse(x = InverseQuadratic(a,b,c,y)));\nend Quadratic;\n```\n\nModel description:\nA quadratic function.\n\nPrompt:\nTest this model, where the input parameter values are 2.0, 3.0, 1.0 and time.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Quadratic\n  Real y;\nequation\n  y = ModelicaByExample.Functions.Nonlinearities.Quadratic(a=2.0,b=3.0,c=1.0,x=time);\nend Test_Quadratic;\n",
            "feature": ""
        },
        {
            "id": 124,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Components.HeatTransfer;\nmodel ThermalCapacitance \"A model of thermal capacitance\"\n  parameter Modelica.SIunits.HeatCapacity C \"Thermal capacitance\";\n  parameter Modelica.SIunits.Temperature T0 \"Initial temperature\";\n  Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a node\n    annotation (Placement(transformation(extent={{-10,-10},{10,10}})));\ninitial equation\n  node.T = T0;\nequation\n  C*der(node.T) = node.Q_flow;\nend ThermalCapacitance;\n```\n\nModel description:\nA model of thermal capacitance.\n\nPrompt:\nTest this model, where the parameter C=0.12 and T0 = 363.15.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_ThermalCapacitance\n  ModelicaByExample.Components.HeatTransfer.ThermalCapacitance thermalCapacitance(\n   C=0.12, T0=363.15);\nend Test_ThermalCapacitance;\n",
            "feature": ""
        },
        {
            "id": 125,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Components.HeatTransfer;\nmodel Convection \"Modeling convection between port_a and port_b\"\n  parameter Modelica.SIunits.CoefficientOfHeatTransfer h;\n  parameter Modelica.SIunits.Area A;\n  Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a port_a\n    annotation (Placement(transformation(extent={{-110,-10},{-90,10}})));\n  Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_b port_b\n    annotation (Placement(transformation(extent={{90,-10},{110,10}})));\nequation\n  port_a.Q_flow + port_b.Q_flow = 0 \"Conservation of energy\";\n  port_a.Q_flow = h*A*(port_a.T-port_b.T) \"Heat transfer equation\";\nend Convection;\n```\n\nModel description:\nModeling convection between port_a and port_b.\n\nPrompt:\nTest this model, where the parameter h = 0.7 and A =1.0. Instantiate two interfaces using the ThermalCapacitance with parameter C=0.12, T0 = 363.15 and the AmbientCondition with parameter T_amb = 298.15.\nThe connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_Convection\n  ModelicaByExample.Components.HeatTransfer.Convection conv1(h = 0.7, A =1.0);\n  ModelicaByExample.Components.HeatTransfer.ThermalCapacitance cap1(C=0.12, T0 = 363.15);\n  ModelicaByExample.Components.HeatTransfer.AmbientCondition amb1(T_amb = 298.15);\nequation\n  connect(conv1.port_b, cap1.node);\n  connect(conv1.port_a, amb1.node);\nend Test_Convection;\n",
            "feature": ""
        },
        {
            "id": 126,
            "instruction": "Modelica model:```\nwithin ModelicaByExample.Components.HeatTransfer;\nmodel AmbientCondition\n  \"Model of an \\\"infinite reservoir\\\" at some ambient temperature\"\n  parameter Modelica.SIunits.Temperature T_amb \"Ambient temperature\";\n  Modelica.Thermal.HeatTransfer.Interfaces.HeatPort_a node annotation (\n      Placement(transformation(extent={{-10,-10},{10,10}}), iconTransformation(\n          extent={{-10,-10},{10,10}})));\nequation\n  node.T = T_amb;\nend AmbientCondition;\n```\n\nModel description:\nModel of an \"infinite reservoir\" at some ambient temperature.\n\nPrompt:\nTest this model, where the parameter T_amb = 363.15.\nPlease help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_AmbientCondition\n  ModelicaByExample.Components.HeatTransfer.AmbientCondition ambientCondition(T_amb=363.15);\nend Test_AmbientCondition;\n",
            "feature": ""
        },
        {
            "id": 127,
            "instruction": "Modelica model:```\nmodel PatientController\n  Modelica.Blocks.Interfaces.RealOutput opening \"Opening signal for patient valve [p.u.]\" annotation(\n    Placement(visible = true, transformation(extent = {{84, -2}, {104, 18}}, rotation = 0), iconTransformation(extent = {{80, -20}, {120, 20}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealInput dutyCycle \"Duty cycle [%]\" annotation(\n    Placement(visible = true, transformation(extent = {{-130, -36}, {-90, 4}}, rotation = 0), iconTransformation(extent = {{-120, -80}, {-80, -40}}, rotation = 0)));\n  Modelica.Blocks.Interfaces.RealInput RR \"Respiratory rate [acts/min]\" annotation(\n    Placement(visible = true, transformation(extent = {{-130, 16}, {-90, 56}}, rotation = 0), iconTransformation(extent = {{-120, 40}, {-80, 80}}, rotation = 0)));\n  discrete Modelica.SIunits.Time t_on \"Next opening time\";\n  discrete Modelica.SIunits.Time t_off \"Next closing time\";\n  Boolean active \"The controller is activated\";\ninitial equation\n  active = if RR > 1 then true else false;\n  if active then\n    t_on = time + 60/RR;\n    t_off = time + 60 / RR * dutyCycle / 100;\n  else\n    t_on = time;\n    t_off = time;\n  end if;\nequation\n  when RR > 1 then\n    active = true;\n  elsewhen RR < 1 then\n    active = false;\n  end when;\n  when pre(active) and time >= pre(t_on) then\n    t_on = time + 60 / RR;\n    t_off = time + 60 / RR * dutyCycle / 100;\n  end when;\n  opening = if active and time < t_off then 1 else 0;\nend PatientController;\n```\nModel description:\n\nPrompt:\nUse this model to test the Patient Controller of signals, where the signals are implemented by Modelica.Blocks.Sources.TimeTable with RR(table = [0, 30; 48, 30; 48, 20; 79, 20; 79, 0; 100, 0]) and dutyCycle(table = [0, 50; 20, 50; 50, 25; 100, 25]). The connection of the signal is based on 'connect'. Please help me generate this modelica model, you don't need to provide \"within\".",
            "input": "",
            "output": "model Test_PatientController\n  MEV.Controls.PatientController patientController;\n  Modelica.Blocks.Sources.TimeTable RR(table = [0, 30; 48, 30; 48, 20; 79, 20; 79, 0; 100, 0]);\n  Modelica.Blocks.Sources.TimeTable dutyCycle(table = [0, 50; 20, 50; 50, 25; 100, 25]);\nequation\n  connect(RR.y, patientController.RR);\n  connect(dutyCycle.y, patientController.dutyCycle);\nend Test_PatientController;\n",
            "feature": ""
        }
    ]
}